/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "errors_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_EDAMErrorCode(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case E_D_A_M_ERROR_CODE_UNKNOWN:return "E_D_A_M_ERROR_CODE_UNKNOWN";
  case E_D_A_M_ERROR_CODE_BAD_DATA_FORMAT:return "E_D_A_M_ERROR_CODE_BAD_DATA_FORMAT";
  case E_D_A_M_ERROR_CODE_PERMISSION_DENIED:return "E_D_A_M_ERROR_CODE_PERMISSION_DENIED";
  case E_D_A_M_ERROR_CODE_INTERNAL_ERROR:return "E_D_A_M_ERROR_CODE_INTERNAL_ERROR";
  case E_D_A_M_ERROR_CODE_DATA_REQUIRED:return "E_D_A_M_ERROR_CODE_DATA_REQUIRED";
  case E_D_A_M_ERROR_CODE_LIMIT_REACHED:return "E_D_A_M_ERROR_CODE_LIMIT_REACHED";
  case E_D_A_M_ERROR_CODE_QUOTA_REACHED:return "E_D_A_M_ERROR_CODE_QUOTA_REACHED";
  case E_D_A_M_ERROR_CODE_INVALID_AUTH:return "E_D_A_M_ERROR_CODE_INVALID_AUTH";
  case E_D_A_M_ERROR_CODE_AUTH_EXPIRED:return "E_D_A_M_ERROR_CODE_AUTH_EXPIRED";
  case E_D_A_M_ERROR_CODE_DATA_CONFLICT:return "E_D_A_M_ERROR_CODE_DATA_CONFLICT";
  case E_D_A_M_ERROR_CODE_ENML_VALIDATION:return "E_D_A_M_ERROR_CODE_ENML_VALIDATION";
  case E_D_A_M_ERROR_CODE_SHARD_UNAVAILABLE:return "E_D_A_M_ERROR_CODE_SHARD_UNAVAILABLE";
  case E_D_A_M_ERROR_CODE_LEN_TOO_SHORT:return "E_D_A_M_ERROR_CODE_LEN_TOO_SHORT";
  case E_D_A_M_ERROR_CODE_LEN_TOO_LONG:return "E_D_A_M_ERROR_CODE_LEN_TOO_LONG";
  case E_D_A_M_ERROR_CODE_TOO_FEW:return "E_D_A_M_ERROR_CODE_TOO_FEW";
  case E_D_A_M_ERROR_CODE_TOO_MANY:return "E_D_A_M_ERROR_CODE_TOO_MANY";
  case E_D_A_M_ERROR_CODE_UNSUPPORTED_OPERATION:return "E_D_A_M_ERROR_CODE_UNSUPPORTED_OPERATION";
  case E_D_A_M_ERROR_CODE_TAKEN_DOWN:return "E_D_A_M_ERROR_CODE_TAKEN_DOWN";
  case E_D_A_M_ERROR_CODE_RATE_LIMIT_REACHED:return "E_D_A_M_ERROR_CODE_RATE_LIMIT_REACHED";
  case E_D_A_M_ERROR_CODE_BUSINESS_SECURITY_LOGIN_REQUIRED:return "E_D_A_M_ERROR_CODE_BUSINESS_SECURITY_LOGIN_REQUIRED";
  case E_D_A_M_ERROR_CODE_DEVICE_LIMIT_REACHED:return "E_D_A_M_ERROR_CODE_DEVICE_LIMIT_REACHED";
  case E_D_A_M_ERROR_CODE_OPENID_ALREADY_TAKEN:return "E_D_A_M_ERROR_CODE_OPENID_ALREADY_TAKEN";
  case E_D_A_M_ERROR_CODE_INVALID_OPENID_TOKEN:return "E_D_A_M_ERROR_CODE_INVALID_OPENID_TOKEN";
  case E_D_A_M_ERROR_CODE_USER_NOT_ASSOCIATED:return "E_D_A_M_ERROR_CODE_USER_NOT_ASSOCIATED";
  case E_D_A_M_ERROR_CODE_USER_NOT_REGISTERED:return "E_D_A_M_ERROR_CODE_USER_NOT_REGISTERED";
  case E_D_A_M_ERROR_CODE_USER_ALREADY_ASSOCIATED:return "E_D_A_M_ERROR_CODE_USER_ALREADY_ASSOCIATED";
  case E_D_A_M_ERROR_CODE_ACCOUNT_CLEAR:return "E_D_A_M_ERROR_CODE_ACCOUNT_CLEAR";
  case E_D_A_M_ERROR_CODE_SSO_AUTHENTICATION_REQUIRED:return "E_D_A_M_ERROR_CODE_SSO_AUTHENTICATION_REQUIRED";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_EDAMInvalidContactReason(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case E_D_A_M_INVALID_CONTACT_REASON_BAD_ADDRESS:return "E_D_A_M_INVALID_CONTACT_REASON_BAD_ADDRESS";
  case E_D_A_M_INVALID_CONTACT_REASON_DUPLICATE_CONTACT:return "E_D_A_M_INVALID_CONTACT_REASON_DUPLICATE_CONTACT";
  case E_D_A_M_INVALID_CONTACT_REASON_NO_CONNECTION:return "E_D_A_M_INVALID_CONTACT_REASON_NO_CONNECTION";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _EDAMUserExceptionProperties
{
  PROP_E_D_A_M_USER_EXCEPTION_0,
  PROP_E_D_A_M_USER_EXCEPTION_ERROR_CODE,
  PROP_E_D_A_M_USER_EXCEPTION_PARAMETER
};

/* reads a e_d_a_m_user_exception object */
static gint32
e_d_a_m_user_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EDAMUserException * this_object = E_D_A_M_USER_EXCEPTION(object);
  gboolean isset_errorCode = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->errorCode = (EDAMErrorCode)ecast0;
          isset_errorCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->parameter != NULL)
          {
            g_free(this_object->parameter);
            this_object->parameter = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->parameter, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_parameter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_errorCode)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
e_d_a_m_user_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EDAMUserException * this_object = E_D_A_M_USER_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EDAMUserException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errorCode", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->errorCode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_parameter == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "parameter", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->parameter, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
e_d_a_m_user_exception_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  EDAMUserException *self = E_D_A_M_USER_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_E_D_A_M_USER_EXCEPTION_ERROR_CODE:
      self->errorCode = g_value_get_int (value);
      break;

    case PROP_E_D_A_M_USER_EXCEPTION_PARAMETER:
      if (self->parameter != NULL)
        g_free (self->parameter);
      self->parameter = g_value_dup_string (value);
      self->__isset_parameter = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
e_d_a_m_user_exception_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  EDAMUserException *self = E_D_A_M_USER_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_E_D_A_M_USER_EXCEPTION_ERROR_CODE:
      g_value_set_int (value, self->errorCode);
      break;

    case PROP_E_D_A_M_USER_EXCEPTION_PARAMETER:
      g_value_set_string (value, self->parameter);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
e_d_a_m_user_exception_instance_init (EDAMUserException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->parameter = NULL;
  object->__isset_parameter = FALSE;
}

static void 
e_d_a_m_user_exception_finalize (GObject *object)
{
  EDAMUserException *tobject = E_D_A_M_USER_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->parameter != NULL)
  {
    g_free(tobject->parameter);
    tobject->parameter = NULL;
  }
}

static void
e_d_a_m_user_exception_class_init (EDAMUserExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = e_d_a_m_user_exception_read;
  struct_class->write = e_d_a_m_user_exception_write;

  gobject_class->finalize = e_d_a_m_user_exception_finalize;
  gobject_class->get_property = e_d_a_m_user_exception_get_property;
  gobject_class->set_property = e_d_a_m_user_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_USER_EXCEPTION_ERROR_CODE,
     g_param_spec_int ("errorCode",
                       NULL,
                       NULL,
                       1,
                       28,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_USER_EXCEPTION_PARAMETER,
     g_param_spec_string ("parameter",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
e_d_a_m_user_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EDAMUserExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) e_d_a_m_user_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EDAMUserException),
      0, /* n_preallocs */
      (GInstanceInitFunc) e_d_a_m_user_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EDAMUserExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define E_D_A_M_USER_EXCEPTION_ERROR_DOMAIN "e_d_a_m_user_exception_error_quark"
GQuark
e_d_a_m_user_exception_error_quark (void)
{
  return g_quark_from_static_string (E_D_A_M_USER_EXCEPTION_ERROR_DOMAIN);
}

enum _EDAMSystemExceptionProperties
{
  PROP_E_D_A_M_SYSTEM_EXCEPTION_0,
  PROP_E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE,
  PROP_E_D_A_M_SYSTEM_EXCEPTION_MESSAGE,
  PROP_E_D_A_M_SYSTEM_EXCEPTION_RATE_LIMIT_DURATION
};

/* reads a e_d_a_m_system_exception object */
static gint32
e_d_a_m_system_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EDAMSystemException * this_object = E_D_A_M_SYSTEM_EXCEPTION(object);
  gboolean isset_errorCode = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast1;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->errorCode = (EDAMErrorCode)ecast1;
          isset_errorCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->rateLimitDuration, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rateLimitDuration = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_errorCode)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
e_d_a_m_system_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EDAMSystemException * this_object = E_D_A_M_SYSTEM_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EDAMSystemException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errorCode", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->errorCode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_message == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_rateLimitDuration == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rateLimitDuration", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->rateLimitDuration, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
e_d_a_m_system_exception_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  EDAMSystemException *self = E_D_A_M_SYSTEM_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE:
      self->errorCode = g_value_get_int (value);
      break;

    case PROP_E_D_A_M_SYSTEM_EXCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    case PROP_E_D_A_M_SYSTEM_EXCEPTION_RATE_LIMIT_DURATION:
      self->rateLimitDuration = g_value_get_int (value);
      self->__isset_rateLimitDuration = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
e_d_a_m_system_exception_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  EDAMSystemException *self = E_D_A_M_SYSTEM_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE:
      g_value_set_int (value, self->errorCode);
      break;

    case PROP_E_D_A_M_SYSTEM_EXCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    case PROP_E_D_A_M_SYSTEM_EXCEPTION_RATE_LIMIT_DURATION:
      g_value_set_int (value, self->rateLimitDuration);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
e_d_a_m_system_exception_instance_init (EDAMSystemException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
  object->rateLimitDuration = 0;
  object->__isset_rateLimitDuration = FALSE;
}

static void 
e_d_a_m_system_exception_finalize (GObject *object)
{
  EDAMSystemException *tobject = E_D_A_M_SYSTEM_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
e_d_a_m_system_exception_class_init (EDAMSystemExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = e_d_a_m_system_exception_read;
  struct_class->write = e_d_a_m_system_exception_write;

  gobject_class->finalize = e_d_a_m_system_exception_finalize;
  gobject_class->get_property = e_d_a_m_system_exception_get_property;
  gobject_class->set_property = e_d_a_m_system_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE,
     g_param_spec_int ("errorCode",
                       NULL,
                       NULL,
                       1,
                       28,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_SYSTEM_EXCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_SYSTEM_EXCEPTION_RATE_LIMIT_DURATION,
     g_param_spec_int ("rateLimitDuration",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
e_d_a_m_system_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EDAMSystemExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) e_d_a_m_system_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EDAMSystemException),
      0, /* n_preallocs */
      (GInstanceInitFunc) e_d_a_m_system_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EDAMSystemExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define E_D_A_M_SYSTEM_EXCEPTION_ERROR_DOMAIN "e_d_a_m_system_exception_error_quark"
GQuark
e_d_a_m_system_exception_error_quark (void)
{
  return g_quark_from_static_string (E_D_A_M_SYSTEM_EXCEPTION_ERROR_DOMAIN);
}

enum _EDAMNotFoundExceptionProperties
{
  PROP_E_D_A_M_NOT_FOUND_EXCEPTION_0,
  PROP_E_D_A_M_NOT_FOUND_EXCEPTION_IDENTIFIER,
  PROP_E_D_A_M_NOT_FOUND_EXCEPTION_KEY
};

/* reads a e_d_a_m_not_found_exception object */
static gint32
e_d_a_m_not_found_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EDAMNotFoundException * this_object = E_D_A_M_NOT_FOUND_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->identifier != NULL)
          {
            g_free(this_object->identifier);
            this_object->identifier = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->identifier, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_identifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
e_d_a_m_not_found_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EDAMNotFoundException * this_object = E_D_A_M_NOT_FOUND_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EDAMNotFoundException", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_identifier == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "identifier", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->identifier, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_key == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
e_d_a_m_not_found_exception_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  EDAMNotFoundException *self = E_D_A_M_NOT_FOUND_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_E_D_A_M_NOT_FOUND_EXCEPTION_IDENTIFIER:
      if (self->identifier != NULL)
        g_free (self->identifier);
      self->identifier = g_value_dup_string (value);
      self->__isset_identifier = TRUE;
      break;

    case PROP_E_D_A_M_NOT_FOUND_EXCEPTION_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
e_d_a_m_not_found_exception_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  EDAMNotFoundException *self = E_D_A_M_NOT_FOUND_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_E_D_A_M_NOT_FOUND_EXCEPTION_IDENTIFIER:
      g_value_set_string (value, self->identifier);
      break;

    case PROP_E_D_A_M_NOT_FOUND_EXCEPTION_KEY:
      g_value_set_string (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
e_d_a_m_not_found_exception_instance_init (EDAMNotFoundException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->identifier = NULL;
  object->__isset_identifier = FALSE;
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
e_d_a_m_not_found_exception_finalize (GObject *object)
{
  EDAMNotFoundException *tobject = E_D_A_M_NOT_FOUND_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->identifier != NULL)
  {
    g_free(tobject->identifier);
    tobject->identifier = NULL;
  }
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
e_d_a_m_not_found_exception_class_init (EDAMNotFoundExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = e_d_a_m_not_found_exception_read;
  struct_class->write = e_d_a_m_not_found_exception_write;

  gobject_class->finalize = e_d_a_m_not_found_exception_finalize;
  gobject_class->get_property = e_d_a_m_not_found_exception_get_property;
  gobject_class->set_property = e_d_a_m_not_found_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_NOT_FOUND_EXCEPTION_IDENTIFIER,
     g_param_spec_string ("identifier",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_NOT_FOUND_EXCEPTION_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
e_d_a_m_not_found_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EDAMNotFoundExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) e_d_a_m_not_found_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EDAMNotFoundException),
      0, /* n_preallocs */
      (GInstanceInitFunc) e_d_a_m_not_found_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EDAMNotFoundExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_DOMAIN "e_d_a_m_not_found_exception_error_quark"
GQuark
e_d_a_m_not_found_exception_error_quark (void)
{
  return g_quark_from_static_string (E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_DOMAIN);
}

enum _EDAMInvalidContactsExceptionProperties
{
  PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_0,
  PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_CONTACTS,
  PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_PARAMETER,
  PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_REASONS
};

/* reads a e_d_a_m_invalid_contacts_exception object */
static gint32
e_d_a_m_invalid_contacts_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EDAMInvalidContactsException * this_object = E_D_A_M_INVALID_CONTACTS_EXCEPTION(object);
  gboolean isset_contacts = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Contact * _elem2 = NULL;
              if ( _elem2 != NULL)
              {
                g_object_unref (_elem2);
              }
              _elem2 = g_object_new (TYPE_CONTACT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem2), protocol, error)) < 0)
              {
                g_object_unref (_elem2);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->contacts, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_contacts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->parameter != NULL)
          {
            g_free(this_object->parameter);
            this_object->parameter = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->parameter, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_parameter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              EDAMInvalidContactReason* _elem3 = g_new (EDAMInvalidContactReason, 1);
              gint32 ecast4;
              if ((ret = thrift_protocol_read_i32 (protocol, &ecast4, error)) < 0)
                return -1;
              xfer += ret;
              *_elem3 = (EDAMInvalidContactReason)ecast4;
              g_array_append_vals (this_object->reasons, _elem3, 1);
              g_free (_elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_reasons = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_contacts)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
e_d_a_m_invalid_contacts_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EDAMInvalidContactsException * this_object = E_D_A_M_INVALID_CONTACTS_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EDAMInvalidContactsException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "contacts", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i5;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->contacts ? this_object->contacts->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i5 = 0; i5 < (this_object->contacts ? this_object->contacts->len : 0); i5++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->contacts, i5))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_parameter == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "parameter", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->parameter, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_reasons == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "reasons", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i6;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->reasons ? this_object->reasons->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i6 = 0; i6 < (this_object->reasons ? this_object->reasons->len : 0); i6++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (gint32) (g_array_index (this_object->reasons, EDAMInvalidContactReason, i6)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
e_d_a_m_invalid_contacts_exception_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  EDAMInvalidContactsException *self = E_D_A_M_INVALID_CONTACTS_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_CONTACTS:
      if (self->contacts != NULL)
        g_ptr_array_unref (self->contacts);
      self->contacts = g_value_dup_boxed (value);
      break;

    case PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_PARAMETER:
      if (self->parameter != NULL)
        g_free (self->parameter);
      self->parameter = g_value_dup_string (value);
      self->__isset_parameter = TRUE;
      break;

    case PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_REASONS:
      if (self->reasons != NULL)
        g_array_unref (self->reasons);
      self->reasons = g_value_dup_boxed (value);
      self->__isset_reasons = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
e_d_a_m_invalid_contacts_exception_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  EDAMInvalidContactsException *self = E_D_A_M_INVALID_CONTACTS_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_CONTACTS:
      g_value_set_boxed (value, self->contacts);
      break;

    case PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_PARAMETER:
      g_value_set_string (value, self->parameter);
      break;

    case PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_REASONS:
      g_value_set_boxed (value, self->reasons);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
e_d_a_m_invalid_contacts_exception_instance_init (EDAMInvalidContactsException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->contacts = g_ptr_array_new_with_free_func (g_object_unref);
  object->parameter = NULL;
  object->__isset_parameter = FALSE;
  object->reasons = g_array_new (0, 1, sizeof (EDAMInvalidContactReason));
  object->__isset_reasons = FALSE;
}

static void 
e_d_a_m_invalid_contacts_exception_finalize (GObject *object)
{
  EDAMInvalidContactsException *tobject = E_D_A_M_INVALID_CONTACTS_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->contacts != NULL)
  {
    g_ptr_array_unref (tobject->contacts);
    tobject->contacts = NULL;
  }
  if (tobject->parameter != NULL)
  {
    g_free(tobject->parameter);
    tobject->parameter = NULL;
  }
  if (tobject->reasons != NULL)
  {
    g_array_unref (tobject->reasons);
    tobject->reasons = NULL;
  }
}

static void
e_d_a_m_invalid_contacts_exception_class_init (EDAMInvalidContactsExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = e_d_a_m_invalid_contacts_exception_read;
  struct_class->write = e_d_a_m_invalid_contacts_exception_write;

  gobject_class->finalize = e_d_a_m_invalid_contacts_exception_finalize;
  gobject_class->get_property = e_d_a_m_invalid_contacts_exception_get_property;
  gobject_class->set_property = e_d_a_m_invalid_contacts_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_CONTACTS,
     g_param_spec_boxed ("contacts",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_PARAMETER,
     g_param_spec_string ("parameter",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_E_D_A_M_INVALID_CONTACTS_EXCEPTION_REASONS,
     g_param_spec_boxed ("reasons",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
e_d_a_m_invalid_contacts_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EDAMInvalidContactsExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) e_d_a_m_invalid_contacts_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EDAMInvalidContactsException),
      0, /* n_preallocs */
      (GInstanceInitFunc) e_d_a_m_invalid_contacts_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EDAMInvalidContactsExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define E_D_A_M_INVALID_CONTACTS_EXCEPTION_ERROR_DOMAIN "e_d_a_m_invalid_contacts_exception_error_quark"
GQuark
e_d_a_m_invalid_contacts_exception_error_quark (void)
{
  return g_quark_from_static_string (E_D_A_M_INVALID_CONTACTS_EXCEPTION_ERROR_DOMAIN);
}

/* constants */

