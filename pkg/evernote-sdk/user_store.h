/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef USER_STORE_H
#define USER_STORE_H

#include <thrift/c_glib/processor/thrift_dispatch_processor.h>

#include "user_store_types.h"

/* UserStore service interface */
typedef struct _UserStoreIf UserStoreIf;  /* dummy object */

struct _UserStoreIfInterface
{
  GTypeInterface parent;

  gboolean (*check_version) (UserStoreIf *iface, gboolean* _return, const gchar * clientName, const gint16 edamVersionMajor, const gint16 edamVersionMinor, GError **error);
  gboolean (*get_bootstrap_info) (UserStoreIf *iface, BootstrapInfo ** _return, const gchar * locale, GError **error);
  gboolean (*authenticate_long_session) (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * username, const gchar * password, const gchar * consumerKey, const gchar * consumerSecret, const gchar * deviceIdentifier, const gchar * deviceDescription, const gboolean supportsTwoFactor, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*complete_two_factor_authentication) (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * authenticationToken, const gchar * oneTimeCode, const gchar * deviceIdentifier, const gchar * deviceDescription, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*revoke_long_session) (UserStoreIf *iface, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*authenticate_to_business) (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*get_user) (UserStoreIf *iface, User ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*get_public_user_info) (UserStoreIf *iface, PublicUserInfo ** _return, const gchar * username, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMUserException ** userException, GError **error);
  gboolean (*get_user_urls) (UserStoreIf *iface, UserUrls ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*invite_to_business) (UserStoreIf *iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*remove_from_business) (UserStoreIf *iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error);
  gboolean (*update_business_user_identifier) (UserStoreIf *iface, const gchar * authenticationToken, const gchar * oldEmailAddress, const gchar * newEmailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error);
  gboolean (*list_business_users) (UserStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*list_business_invitations) (UserStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, const gboolean includeRequestedInvitations, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*get_account_limits) (UserStoreIf *iface, AccountLimits ** _return, const ServiceLevel serviceLevel, EDAMUserException ** userException, GError **error);
};
typedef struct _UserStoreIfInterface UserStoreIfInterface;

GType user_store_if_get_type (void);
#define TYPE_USER_STORE_IF (user_store_if_get_type())
#define USER_STORE_IF(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_STORE_IF, UserStoreIf))
#define IS_USER_STORE_IF(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_STORE_IF))
#define USER_STORE_IF_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), TYPE_USER_STORE_IF, UserStoreIfInterface))

gboolean user_store_if_check_version (UserStoreIf *iface, gboolean* _return, const gchar * clientName, const gint16 edamVersionMajor, const gint16 edamVersionMinor, GError **error);
gboolean user_store_if_get_bootstrap_info (UserStoreIf *iface, BootstrapInfo ** _return, const gchar * locale, GError **error);
gboolean user_store_if_authenticate_long_session (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * username, const gchar * password, const gchar * consumerKey, const gchar * consumerSecret, const gchar * deviceIdentifier, const gchar * deviceDescription, const gboolean supportsTwoFactor, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_complete_two_factor_authentication (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * authenticationToken, const gchar * oneTimeCode, const gchar * deviceIdentifier, const gchar * deviceDescription, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_revoke_long_session (UserStoreIf *iface, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_authenticate_to_business (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_get_user (UserStoreIf *iface, User ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_get_public_user_info (UserStoreIf *iface, PublicUserInfo ** _return, const gchar * username, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMUserException ** userException, GError **error);
gboolean user_store_if_get_user_urls (UserStoreIf *iface, UserUrls ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_invite_to_business (UserStoreIf *iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_remove_from_business (UserStoreIf *iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error);
gboolean user_store_if_update_business_user_identifier (UserStoreIf *iface, const gchar * authenticationToken, const gchar * oldEmailAddress, const gchar * newEmailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error);
gboolean user_store_if_list_business_users (UserStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_list_business_invitations (UserStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, const gboolean includeRequestedInvitations, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_if_get_account_limits (UserStoreIf *iface, AccountLimits ** _return, const ServiceLevel serviceLevel, EDAMUserException ** userException, GError **error);

/* UserStore service client */
struct _UserStoreClient
{
  GObject parent;

  ThriftProtocol *input_protocol;
  ThriftProtocol *output_protocol;
};
typedef struct _UserStoreClient UserStoreClient;

struct _UserStoreClientClass
{
  GObjectClass parent;
};
typedef struct _UserStoreClientClass UserStoreClientClass;

GType user_store_client_get_type (void);
#define TYPE_USER_STORE_CLIENT (user_store_client_get_type())
#define USER_STORE_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_STORE_CLIENT, UserStoreClient))
#define USER_STORE_CLIENT_CLASS(c) (G_TYPE_CHECK_CLASS_CAST ((c), TYPE_USER_STORE_CLIENT, UserStoreClientClass))
#define USER_STORE_IS_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_STORE_CLIENT))
#define USER_STORE_IS_CLIENT_CLASS(c) (G_TYPE_CHECK_CLASS_TYPE ((c), TYPE_USER_STORE_CLIENT))
#define USER_STORE_CLIENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_STORE_CLIENT, UserStoreClientClass))

gboolean user_store_client_check_version (UserStoreIf * iface, gboolean* _return, const gchar * clientName, const gint16 edamVersionMajor, const gint16 edamVersionMinor, GError ** error);
gboolean user_store_client_send_check_version (UserStoreIf * iface, const gchar * clientName, const gint16 edamVersionMajor, const gint16 edamVersionMinor, GError ** error);
gboolean user_store_client_recv_check_version (UserStoreIf * iface, gboolean* _return, GError ** error);
gboolean user_store_client_get_bootstrap_info (UserStoreIf * iface, BootstrapInfo ** _return, const gchar * locale, GError ** error);
gboolean user_store_client_send_get_bootstrap_info (UserStoreIf * iface, const gchar * locale, GError ** error);
gboolean user_store_client_recv_get_bootstrap_info (UserStoreIf * iface, BootstrapInfo ** _return, GError ** error);
gboolean user_store_client_authenticate_long_session (UserStoreIf * iface, AuthenticationResult ** _return, const gchar * username, const gchar * password, const gchar * consumerKey, const gchar * consumerSecret, const gchar * deviceIdentifier, const gchar * deviceDescription, const gboolean supportsTwoFactor, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_authenticate_long_session (UserStoreIf * iface, const gchar * username, const gchar * password, const gchar * consumerKey, const gchar * consumerSecret, const gchar * deviceIdentifier, const gchar * deviceDescription, const gboolean supportsTwoFactor, GError ** error);
gboolean user_store_client_recv_authenticate_long_session (UserStoreIf * iface, AuthenticationResult ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_complete_two_factor_authentication (UserStoreIf * iface, AuthenticationResult ** _return, const gchar * authenticationToken, const gchar * oneTimeCode, const gchar * deviceIdentifier, const gchar * deviceDescription, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_complete_two_factor_authentication (UserStoreIf * iface, const gchar * authenticationToken, const gchar * oneTimeCode, const gchar * deviceIdentifier, const gchar * deviceDescription, GError ** error);
gboolean user_store_client_recv_complete_two_factor_authentication (UserStoreIf * iface, AuthenticationResult ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_revoke_long_session (UserStoreIf * iface, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_revoke_long_session (UserStoreIf * iface, const gchar * authenticationToken, GError ** error);
gboolean user_store_client_recv_revoke_long_session (UserStoreIf * iface, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_authenticate_to_business (UserStoreIf * iface, AuthenticationResult ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_authenticate_to_business (UserStoreIf * iface, const gchar * authenticationToken, GError ** error);
gboolean user_store_client_recv_authenticate_to_business (UserStoreIf * iface, AuthenticationResult ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_get_user (UserStoreIf * iface, User ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_get_user (UserStoreIf * iface, const gchar * authenticationToken, GError ** error);
gboolean user_store_client_recv_get_user (UserStoreIf * iface, User ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_get_public_user_info (UserStoreIf * iface, PublicUserInfo ** _return, const gchar * username, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMUserException ** userException, GError ** error);
gboolean user_store_client_send_get_public_user_info (UserStoreIf * iface, const gchar * username, GError ** error);
gboolean user_store_client_recv_get_public_user_info (UserStoreIf * iface, PublicUserInfo ** _return, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMUserException ** userException, GError ** error);
gboolean user_store_client_get_user_urls (UserStoreIf * iface, UserUrls ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_get_user_urls (UserStoreIf * iface, const gchar * authenticationToken, GError ** error);
gboolean user_store_client_recv_get_user_urls (UserStoreIf * iface, UserUrls ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_invite_to_business (UserStoreIf * iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_invite_to_business (UserStoreIf * iface, const gchar * authenticationToken, const gchar * emailAddress, GError ** error);
gboolean user_store_client_recv_invite_to_business (UserStoreIf * iface, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_remove_from_business (UserStoreIf * iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error);
gboolean user_store_client_send_remove_from_business (UserStoreIf * iface, const gchar * authenticationToken, const gchar * emailAddress, GError ** error);
gboolean user_store_client_recv_remove_from_business (UserStoreIf * iface, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error);
gboolean user_store_client_update_business_user_identifier (UserStoreIf * iface, const gchar * authenticationToken, const gchar * oldEmailAddress, const gchar * newEmailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error);
gboolean user_store_client_send_update_business_user_identifier (UserStoreIf * iface, const gchar * authenticationToken, const gchar * oldEmailAddress, const gchar * newEmailAddress, GError ** error);
gboolean user_store_client_recv_update_business_user_identifier (UserStoreIf * iface, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error);
gboolean user_store_client_list_business_users (UserStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_list_business_users (UserStoreIf * iface, const gchar * authenticationToken, GError ** error);
gboolean user_store_client_recv_list_business_users (UserStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_list_business_invitations (UserStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, const gboolean includeRequestedInvitations, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_send_list_business_invitations (UserStoreIf * iface, const gchar * authenticationToken, const gboolean includeRequestedInvitations, GError ** error);
gboolean user_store_client_recv_list_business_invitations (UserStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error);
gboolean user_store_client_get_account_limits (UserStoreIf * iface, AccountLimits ** _return, const ServiceLevel serviceLevel, EDAMUserException ** userException, GError ** error);
gboolean user_store_client_send_get_account_limits (UserStoreIf * iface, const ServiceLevel serviceLevel, GError ** error);
gboolean user_store_client_recv_get_account_limits (UserStoreIf * iface, AccountLimits ** _return, EDAMUserException ** userException, GError ** error);
void user_store_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec);
void user_store_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec);

/* UserStore handler (abstract base class) */
struct _UserStoreHandler
{
  GObject parent;
};
typedef struct _UserStoreHandler UserStoreHandler;

struct _UserStoreHandlerClass
{
  GObjectClass parent;

  gboolean (*check_version) (UserStoreIf *iface, gboolean* _return, const gchar * clientName, const gint16 edamVersionMajor, const gint16 edamVersionMinor, GError **error);
  gboolean (*get_bootstrap_info) (UserStoreIf *iface, BootstrapInfo ** _return, const gchar * locale, GError **error);
  gboolean (*authenticate_long_session) (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * username, const gchar * password, const gchar * consumerKey, const gchar * consumerSecret, const gchar * deviceIdentifier, const gchar * deviceDescription, const gboolean supportsTwoFactor, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*complete_two_factor_authentication) (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * authenticationToken, const gchar * oneTimeCode, const gchar * deviceIdentifier, const gchar * deviceDescription, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*revoke_long_session) (UserStoreIf *iface, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*authenticate_to_business) (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*get_user) (UserStoreIf *iface, User ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*get_public_user_info) (UserStoreIf *iface, PublicUserInfo ** _return, const gchar * username, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMUserException ** userException, GError **error);
  gboolean (*get_user_urls) (UserStoreIf *iface, UserUrls ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*invite_to_business) (UserStoreIf *iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*remove_from_business) (UserStoreIf *iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error);
  gboolean (*update_business_user_identifier) (UserStoreIf *iface, const gchar * authenticationToken, const gchar * oldEmailAddress, const gchar * newEmailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error);
  gboolean (*list_business_users) (UserStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*list_business_invitations) (UserStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, const gboolean includeRequestedInvitations, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
  gboolean (*get_account_limits) (UserStoreIf *iface, AccountLimits ** _return, const ServiceLevel serviceLevel, EDAMUserException ** userException, GError **error);
};
typedef struct _UserStoreHandlerClass UserStoreHandlerClass;

GType user_store_handler_get_type (void);
#define TYPE_USER_STORE_HANDLER (user_store_handler_get_type())
#define USER_STORE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_STORE_HANDLER, UserStoreHandler))
#define IS_USER_STORE_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_STORE_HANDLER))
#define USER_STORE_HANDLER_CLASS(c) (G_TYPE_CHECK_CLASS_CAST ((c), TYPE_USER_STORE_HANDLER, UserStoreHandlerClass))
#define IS_USER_STORE_HANDLER_CLASS(c) (G_TYPE_CHECK_CLASS_TYPE ((c), TYPE_USER_STORE_HANDLER))
#define USER_STORE_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_STORE_HANDLER, UserStoreHandlerClass))

gboolean user_store_handler_check_version (UserStoreIf *iface, gboolean* _return, const gchar * clientName, const gint16 edamVersionMajor, const gint16 edamVersionMinor, GError **error);
gboolean user_store_handler_get_bootstrap_info (UserStoreIf *iface, BootstrapInfo ** _return, const gchar * locale, GError **error);
gboolean user_store_handler_authenticate_long_session (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * username, const gchar * password, const gchar * consumerKey, const gchar * consumerSecret, const gchar * deviceIdentifier, const gchar * deviceDescription, const gboolean supportsTwoFactor, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_complete_two_factor_authentication (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * authenticationToken, const gchar * oneTimeCode, const gchar * deviceIdentifier, const gchar * deviceDescription, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_revoke_long_session (UserStoreIf *iface, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_authenticate_to_business (UserStoreIf *iface, AuthenticationResult ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_get_user (UserStoreIf *iface, User ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_get_public_user_info (UserStoreIf *iface, PublicUserInfo ** _return, const gchar * username, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMUserException ** userException, GError **error);
gboolean user_store_handler_get_user_urls (UserStoreIf *iface, UserUrls ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_invite_to_business (UserStoreIf *iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_remove_from_business (UserStoreIf *iface, const gchar * authenticationToken, const gchar * emailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error);
gboolean user_store_handler_update_business_user_identifier (UserStoreIf *iface, const gchar * authenticationToken, const gchar * oldEmailAddress, const gchar * newEmailAddress, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error);
gboolean user_store_handler_list_business_users (UserStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_list_business_invitations (UserStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, const gboolean includeRequestedInvitations, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error);
gboolean user_store_handler_get_account_limits (UserStoreIf *iface, AccountLimits ** _return, const ServiceLevel serviceLevel, EDAMUserException ** userException, GError **error);

/* UserStore processor */
struct _UserStoreProcessor
{
  ThriftDispatchProcessor parent;

  /* protected */
  UserStoreHandler *handler;
  GHashTable *process_map;
};
typedef struct _UserStoreProcessor UserStoreProcessor;

struct _UserStoreProcessorClass
{
  ThriftDispatchProcessorClass parent;

  /* protected */
  gboolean (*dispatch_call) (ThriftDispatchProcessor *processor,
                             ThriftProtocol *in,
                             ThriftProtocol *out,
                             gchar *fname,
                             gint32 seqid,
                             GError **error);
};
typedef struct _UserStoreProcessorClass UserStoreProcessorClass;

GType user_store_processor_get_type (void);
#define TYPE_USER_STORE_PROCESSOR (user_store_processor_get_type())
#define USER_STORE_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_STORE_PROCESSOR, UserStoreProcessor))
#define IS_USER_STORE_PROCESSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_STORE_PROCESSOR))
#define USER_STORE_PROCESSOR_CLASS(c) (G_TYPE_CHECK_CLASS_CAST ((c), TYPE_USER_STORE_PROCESSOR, UserStoreProcessorClass))
#define IS_USER_STORE_PROCESSOR_CLASS(c) (G_TYPE_CHECK_CLASS_TYPE ((c), TYPE_USER_STORE_PROCESSOR))
#define USER_STORE_PROCESSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_STORE_PROCESSOR, UserStoreProcessorClass))

#endif /* USER_STORE_H */
