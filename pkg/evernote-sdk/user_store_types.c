/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "user_store_types.h"
#include <thrift/c_glib/thrift.h>

enum _PublicUserInfoProperties
{
  PROP_PUBLIC_USER_INFO_0,
  PROP_PUBLIC_USER_INFO_USER_ID,
  PROP_PUBLIC_USER_INFO_SERVICE_LEVEL,
  PROP_PUBLIC_USER_INFO_USERNAME,
  PROP_PUBLIC_USER_INFO_NOTE_STORE_URL,
  PROP_PUBLIC_USER_INFO_WEB_API_URL_PREFIX
};

/* reads a public_user_info object */
static gint32
public_user_info_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PublicUserInfo * this_object = PUBLIC_USER_INFO(object);
  gboolean isset_userId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->userId, error)) < 0)
            return -1;
          xfer += ret;
          isset_userId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->serviceLevel = (ServiceLevel)ecast0;
          this_object->__isset_serviceLevel = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->username != NULL)
          {
            g_free(this_object->username);
            this_object->username = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->username, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_username = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->noteStoreUrl != NULL)
          {
            g_free(this_object->noteStoreUrl);
            this_object->noteStoreUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteStoreUrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteStoreUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->webApiUrlPrefix != NULL)
          {
            g_free(this_object->webApiUrlPrefix);
            this_object->webApiUrlPrefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->webApiUrlPrefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_webApiUrlPrefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_userId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
public_user_info_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PublicUserInfo * this_object = PUBLIC_USER_INFO(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PublicUserInfo", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "userId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->userId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_serviceLevel == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "serviceLevel", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->serviceLevel, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_username == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "username", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->username, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noteStoreUrl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteStoreUrl", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->noteStoreUrl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_webApiUrlPrefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "webApiUrlPrefix", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->webApiUrlPrefix, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
public_user_info_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  PublicUserInfo *self = PUBLIC_USER_INFO (object);

  switch (property_id)
  {
    case PROP_PUBLIC_USER_INFO_USER_ID:
      self->userId = g_value_get_int (value);
      break;

    case PROP_PUBLIC_USER_INFO_SERVICE_LEVEL:
      self->serviceLevel = g_value_get_int (value);
      self->__isset_serviceLevel = TRUE;
      break;

    case PROP_PUBLIC_USER_INFO_USERNAME:
      if (self->username != NULL)
        g_free (self->username);
      self->username = g_value_dup_string (value);
      self->__isset_username = TRUE;
      break;

    case PROP_PUBLIC_USER_INFO_NOTE_STORE_URL:
      if (self->noteStoreUrl != NULL)
        g_free (self->noteStoreUrl);
      self->noteStoreUrl = g_value_dup_string (value);
      self->__isset_noteStoreUrl = TRUE;
      break;

    case PROP_PUBLIC_USER_INFO_WEB_API_URL_PREFIX:
      if (self->webApiUrlPrefix != NULL)
        g_free (self->webApiUrlPrefix);
      self->webApiUrlPrefix = g_value_dup_string (value);
      self->__isset_webApiUrlPrefix = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
public_user_info_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  PublicUserInfo *self = PUBLIC_USER_INFO (object);

  switch (property_id)
  {
    case PROP_PUBLIC_USER_INFO_USER_ID:
      g_value_set_int (value, self->userId);
      break;

    case PROP_PUBLIC_USER_INFO_SERVICE_LEVEL:
      g_value_set_int (value, self->serviceLevel);
      break;

    case PROP_PUBLIC_USER_INFO_USERNAME:
      g_value_set_string (value, self->username);
      break;

    case PROP_PUBLIC_USER_INFO_NOTE_STORE_URL:
      g_value_set_string (value, self->noteStoreUrl);
      break;

    case PROP_PUBLIC_USER_INFO_WEB_API_URL_PREFIX:
      g_value_set_string (value, self->webApiUrlPrefix);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
public_user_info_instance_init (PublicUserInfo * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userId = 0;
  object->__isset_serviceLevel = FALSE;
  object->username = NULL;
  object->__isset_username = FALSE;
  object->noteStoreUrl = NULL;
  object->__isset_noteStoreUrl = FALSE;
  object->webApiUrlPrefix = NULL;
  object->__isset_webApiUrlPrefix = FALSE;
}

static void 
public_user_info_finalize (GObject *object)
{
  PublicUserInfo *tobject = PUBLIC_USER_INFO (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->username != NULL)
  {
    g_free(tobject->username);
    tobject->username = NULL;
  }
  if (tobject->noteStoreUrl != NULL)
  {
    g_free(tobject->noteStoreUrl);
    tobject->noteStoreUrl = NULL;
  }
  if (tobject->webApiUrlPrefix != NULL)
  {
    g_free(tobject->webApiUrlPrefix);
    tobject->webApiUrlPrefix = NULL;
  }
}

static void
public_user_info_class_init (PublicUserInfoClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = public_user_info_read;
  struct_class->write = public_user_info_write;

  gobject_class->finalize = public_user_info_finalize;
  gobject_class->get_property = public_user_info_get_property;
  gobject_class->set_property = public_user_info_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PUBLIC_USER_INFO_USER_ID,
     g_param_spec_int ("userId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PUBLIC_USER_INFO_SERVICE_LEVEL,
     g_param_spec_int ("serviceLevel",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PUBLIC_USER_INFO_USERNAME,
     g_param_spec_string ("username",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PUBLIC_USER_INFO_NOTE_STORE_URL,
     g_param_spec_string ("noteStoreUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PUBLIC_USER_INFO_WEB_API_URL_PREFIX,
     g_param_spec_string ("webApiUrlPrefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
public_user_info_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PublicUserInfoClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) public_user_info_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PublicUserInfo),
      0, /* n_preallocs */
      (GInstanceInitFunc) public_user_info_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PublicUserInfoType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserUrlsProperties
{
  PROP_USER_URLS_0,
  PROP_USER_URLS_NOTE_STORE_URL,
  PROP_USER_URLS_WEB_API_URL_PREFIX,
  PROP_USER_URLS_USER_STORE_URL,
  PROP_USER_URLS_UTILITY_URL,
  PROP_USER_URLS_MESSAGE_STORE_URL,
  PROP_USER_URLS_USER_WEB_SOCKET_URL
};

/* reads a user_urls object */
static gint32
user_urls_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserUrls * this_object = USER_URLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->noteStoreUrl != NULL)
          {
            g_free(this_object->noteStoreUrl);
            this_object->noteStoreUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteStoreUrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteStoreUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->webApiUrlPrefix != NULL)
          {
            g_free(this_object->webApiUrlPrefix);
            this_object->webApiUrlPrefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->webApiUrlPrefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_webApiUrlPrefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->userStoreUrl != NULL)
          {
            g_free(this_object->userStoreUrl);
            this_object->userStoreUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->userStoreUrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_userStoreUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->utilityUrl != NULL)
          {
            g_free(this_object->utilityUrl);
            this_object->utilityUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->utilityUrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_utilityUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->messageStoreUrl != NULL)
          {
            g_free(this_object->messageStoreUrl);
            this_object->messageStoreUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->messageStoreUrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_messageStoreUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->userWebSocketUrl != NULL)
          {
            g_free(this_object->userWebSocketUrl);
            this_object->userWebSocketUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->userWebSocketUrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_userWebSocketUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_urls_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserUrls * this_object = USER_URLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserUrls", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_noteStoreUrl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteStoreUrl", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->noteStoreUrl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_webApiUrlPrefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "webApiUrlPrefix", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->webApiUrlPrefix, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userStoreUrl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userStoreUrl", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->userStoreUrl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_utilityUrl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "utilityUrl", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->utilityUrl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_messageStoreUrl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "messageStoreUrl", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->messageStoreUrl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userWebSocketUrl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userWebSocketUrl", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->userWebSocketUrl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_urls_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  UserUrls *self = USER_URLS (object);

  switch (property_id)
  {
    case PROP_USER_URLS_NOTE_STORE_URL:
      if (self->noteStoreUrl != NULL)
        g_free (self->noteStoreUrl);
      self->noteStoreUrl = g_value_dup_string (value);
      self->__isset_noteStoreUrl = TRUE;
      break;

    case PROP_USER_URLS_WEB_API_URL_PREFIX:
      if (self->webApiUrlPrefix != NULL)
        g_free (self->webApiUrlPrefix);
      self->webApiUrlPrefix = g_value_dup_string (value);
      self->__isset_webApiUrlPrefix = TRUE;
      break;

    case PROP_USER_URLS_USER_STORE_URL:
      if (self->userStoreUrl != NULL)
        g_free (self->userStoreUrl);
      self->userStoreUrl = g_value_dup_string (value);
      self->__isset_userStoreUrl = TRUE;
      break;

    case PROP_USER_URLS_UTILITY_URL:
      if (self->utilityUrl != NULL)
        g_free (self->utilityUrl);
      self->utilityUrl = g_value_dup_string (value);
      self->__isset_utilityUrl = TRUE;
      break;

    case PROP_USER_URLS_MESSAGE_STORE_URL:
      if (self->messageStoreUrl != NULL)
        g_free (self->messageStoreUrl);
      self->messageStoreUrl = g_value_dup_string (value);
      self->__isset_messageStoreUrl = TRUE;
      break;

    case PROP_USER_URLS_USER_WEB_SOCKET_URL:
      if (self->userWebSocketUrl != NULL)
        g_free (self->userWebSocketUrl);
      self->userWebSocketUrl = g_value_dup_string (value);
      self->__isset_userWebSocketUrl = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_urls_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  UserUrls *self = USER_URLS (object);

  switch (property_id)
  {
    case PROP_USER_URLS_NOTE_STORE_URL:
      g_value_set_string (value, self->noteStoreUrl);
      break;

    case PROP_USER_URLS_WEB_API_URL_PREFIX:
      g_value_set_string (value, self->webApiUrlPrefix);
      break;

    case PROP_USER_URLS_USER_STORE_URL:
      g_value_set_string (value, self->userStoreUrl);
      break;

    case PROP_USER_URLS_UTILITY_URL:
      g_value_set_string (value, self->utilityUrl);
      break;

    case PROP_USER_URLS_MESSAGE_STORE_URL:
      g_value_set_string (value, self->messageStoreUrl);
      break;

    case PROP_USER_URLS_USER_WEB_SOCKET_URL:
      g_value_set_string (value, self->userWebSocketUrl);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_urls_instance_init (UserUrls * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->noteStoreUrl = NULL;
  object->__isset_noteStoreUrl = FALSE;
  object->webApiUrlPrefix = NULL;
  object->__isset_webApiUrlPrefix = FALSE;
  object->userStoreUrl = NULL;
  object->__isset_userStoreUrl = FALSE;
  object->utilityUrl = NULL;
  object->__isset_utilityUrl = FALSE;
  object->messageStoreUrl = NULL;
  object->__isset_messageStoreUrl = FALSE;
  object->userWebSocketUrl = NULL;
  object->__isset_userWebSocketUrl = FALSE;
}

static void 
user_urls_finalize (GObject *object)
{
  UserUrls *tobject = USER_URLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->noteStoreUrl != NULL)
  {
    g_free(tobject->noteStoreUrl);
    tobject->noteStoreUrl = NULL;
  }
  if (tobject->webApiUrlPrefix != NULL)
  {
    g_free(tobject->webApiUrlPrefix);
    tobject->webApiUrlPrefix = NULL;
  }
  if (tobject->userStoreUrl != NULL)
  {
    g_free(tobject->userStoreUrl);
    tobject->userStoreUrl = NULL;
  }
  if (tobject->utilityUrl != NULL)
  {
    g_free(tobject->utilityUrl);
    tobject->utilityUrl = NULL;
  }
  if (tobject->messageStoreUrl != NULL)
  {
    g_free(tobject->messageStoreUrl);
    tobject->messageStoreUrl = NULL;
  }
  if (tobject->userWebSocketUrl != NULL)
  {
    g_free(tobject->userWebSocketUrl);
    tobject->userWebSocketUrl = NULL;
  }
}

static void
user_urls_class_init (UserUrlsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_urls_read;
  struct_class->write = user_urls_write;

  gobject_class->finalize = user_urls_finalize;
  gobject_class->get_property = user_urls_get_property;
  gobject_class->set_property = user_urls_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_URLS_NOTE_STORE_URL,
     g_param_spec_string ("noteStoreUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_URLS_WEB_API_URL_PREFIX,
     g_param_spec_string ("webApiUrlPrefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_URLS_USER_STORE_URL,
     g_param_spec_string ("userStoreUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_URLS_UTILITY_URL,
     g_param_spec_string ("utilityUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_URLS_MESSAGE_STORE_URL,
     g_param_spec_string ("messageStoreUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_URLS_USER_WEB_SOCKET_URL,
     g_param_spec_string ("userWebSocketUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_urls_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserUrlsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_urls_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserUrls),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_urls_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserUrlsType",
                                   &type_info, 0);
  }

  return type;
}

enum _AuthenticationResultProperties
{
  PROP_AUTHENTICATION_RESULT_0,
  PROP_AUTHENTICATION_RESULT_CURRENT_TIME,
  PROP_AUTHENTICATION_RESULT_AUTHENTICATION_TOKEN,
  PROP_AUTHENTICATION_RESULT_EXPIRATION,
  PROP_AUTHENTICATION_RESULT_USER,
  PROP_AUTHENTICATION_RESULT_PUBLIC_USER_INFO,
  PROP_AUTHENTICATION_RESULT_NOTE_STORE_URL,
  PROP_AUTHENTICATION_RESULT_WEB_API_URL_PREFIX,
  PROP_AUTHENTICATION_RESULT_SECOND_FACTOR_REQUIRED,
  PROP_AUTHENTICATION_RESULT_SECOND_FACTOR_DELIVERY_HINT,
  PROP_AUTHENTICATION_RESULT_URLS
};

/* reads a authentication_result object */
static gint32
authentication_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AuthenticationResult * this_object = AUTHENTICATION_RESULT(object);
  gboolean isset_currentTime = FALSE;
  gboolean isset_authenticationToken = FALSE;
  gboolean isset_expiration = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->currentTime, error)) < 0)
            return -1;
          xfer += ret;
          isset_currentTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->expiration, error)) < 0)
            return -1;
          xfer += ret;
          isset_expiration = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->user), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_user = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->publicUserInfo), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_publicUserInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->noteStoreUrl != NULL)
          {
            g_free(this_object->noteStoreUrl);
            this_object->noteStoreUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteStoreUrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteStoreUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->webApiUrlPrefix != NULL)
          {
            g_free(this_object->webApiUrlPrefix);
            this_object->webApiUrlPrefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->webApiUrlPrefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_webApiUrlPrefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->secondFactorRequired, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_secondFactorRequired = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->secondFactorDeliveryHint != NULL)
          {
            g_free(this_object->secondFactorDeliveryHint);
            this_object->secondFactorDeliveryHint = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->secondFactorDeliveryHint, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_secondFactorDeliveryHint = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->urls), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_urls = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_currentTime)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_authenticationToken)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_expiration)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
authentication_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AuthenticationResult * this_object = AUTHENTICATION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthenticationResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "currentTime", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->currentTime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "expiration", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->expiration, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_user == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "user", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->user), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_publicUserInfo == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "publicUserInfo", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->publicUserInfo), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noteStoreUrl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteStoreUrl", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->noteStoreUrl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_webApiUrlPrefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "webApiUrlPrefix", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->webApiUrlPrefix, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_secondFactorRequired == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "secondFactorRequired", T_BOOL, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->secondFactorRequired, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_secondFactorDeliveryHint == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "secondFactorDeliveryHint", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->secondFactorDeliveryHint, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_urls == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "urls", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->urls), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
authentication_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  AuthenticationResult *self = AUTHENTICATION_RESULT (object);

  switch (property_id)
  {
    case PROP_AUTHENTICATION_RESULT_CURRENT_TIME:
      self->currentTime = g_value_get_int64 (value);
      break;

    case PROP_AUTHENTICATION_RESULT_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      break;

    case PROP_AUTHENTICATION_RESULT_EXPIRATION:
      self->expiration = g_value_get_int64 (value);
      break;

    case PROP_AUTHENTICATION_RESULT_USER:
      if (self->user != NULL)
        g_object_unref (self->user);
      self->user = g_value_dup_object (value);
      self->__isset_user = TRUE;
      break;

    case PROP_AUTHENTICATION_RESULT_PUBLIC_USER_INFO:
      if (self->publicUserInfo != NULL)
        g_object_unref (self->publicUserInfo);
      self->publicUserInfo = g_value_dup_object (value);
      self->__isset_publicUserInfo = TRUE;
      break;

    case PROP_AUTHENTICATION_RESULT_NOTE_STORE_URL:
      if (self->noteStoreUrl != NULL)
        g_free (self->noteStoreUrl);
      self->noteStoreUrl = g_value_dup_string (value);
      self->__isset_noteStoreUrl = TRUE;
      break;

    case PROP_AUTHENTICATION_RESULT_WEB_API_URL_PREFIX:
      if (self->webApiUrlPrefix != NULL)
        g_free (self->webApiUrlPrefix);
      self->webApiUrlPrefix = g_value_dup_string (value);
      self->__isset_webApiUrlPrefix = TRUE;
      break;

    case PROP_AUTHENTICATION_RESULT_SECOND_FACTOR_REQUIRED:
      self->secondFactorRequired = g_value_get_boolean (value);
      self->__isset_secondFactorRequired = TRUE;
      break;

    case PROP_AUTHENTICATION_RESULT_SECOND_FACTOR_DELIVERY_HINT:
      if (self->secondFactorDeliveryHint != NULL)
        g_free (self->secondFactorDeliveryHint);
      self->secondFactorDeliveryHint = g_value_dup_string (value);
      self->__isset_secondFactorDeliveryHint = TRUE;
      break;

    case PROP_AUTHENTICATION_RESULT_URLS:
      if (self->urls != NULL)
        g_object_unref (self->urls);
      self->urls = g_value_dup_object (value);
      self->__isset_urls = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
authentication_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  AuthenticationResult *self = AUTHENTICATION_RESULT (object);

  switch (property_id)
  {
    case PROP_AUTHENTICATION_RESULT_CURRENT_TIME:
      g_value_set_int64 (value, self->currentTime);
      break;

    case PROP_AUTHENTICATION_RESULT_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_AUTHENTICATION_RESULT_EXPIRATION:
      g_value_set_int64 (value, self->expiration);
      break;

    case PROP_AUTHENTICATION_RESULT_USER:
      g_value_set_object (value, self->user);
      break;

    case PROP_AUTHENTICATION_RESULT_PUBLIC_USER_INFO:
      g_value_set_object (value, self->publicUserInfo);
      break;

    case PROP_AUTHENTICATION_RESULT_NOTE_STORE_URL:
      g_value_set_string (value, self->noteStoreUrl);
      break;

    case PROP_AUTHENTICATION_RESULT_WEB_API_URL_PREFIX:
      g_value_set_string (value, self->webApiUrlPrefix);
      break;

    case PROP_AUTHENTICATION_RESULT_SECOND_FACTOR_REQUIRED:
      g_value_set_boolean (value, self->secondFactorRequired);
      break;

    case PROP_AUTHENTICATION_RESULT_SECOND_FACTOR_DELIVERY_HINT:
      g_value_set_string (value, self->secondFactorDeliveryHint);
      break;

    case PROP_AUTHENTICATION_RESULT_URLS:
      g_value_set_object (value, self->urls);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
authentication_result_instance_init (AuthenticationResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->currentTime = 0;
  object->authenticationToken = NULL;
  object->expiration = 0;
  object->user = g_object_new (TYPE_USER, NULL);
  object->__isset_user = FALSE;
  object->publicUserInfo = g_object_new (TYPE_PUBLIC_USER_INFO, NULL);
  object->__isset_publicUserInfo = FALSE;
  object->noteStoreUrl = NULL;
  object->__isset_noteStoreUrl = FALSE;
  object->webApiUrlPrefix = NULL;
  object->__isset_webApiUrlPrefix = FALSE;
  object->secondFactorRequired = 0;
  object->__isset_secondFactorRequired = FALSE;
  object->secondFactorDeliveryHint = NULL;
  object->__isset_secondFactorDeliveryHint = FALSE;
  object->urls = g_object_new (TYPE_USER_URLS, NULL);
  object->__isset_urls = FALSE;
}

static void 
authentication_result_finalize (GObject *object)
{
  AuthenticationResult *tobject = AUTHENTICATION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->user != NULL)
  {
    g_object_unref(tobject->user);
    tobject->user = NULL;
  }
  if (tobject->publicUserInfo != NULL)
  {
    g_object_unref(tobject->publicUserInfo);
    tobject->publicUserInfo = NULL;
  }
  if (tobject->noteStoreUrl != NULL)
  {
    g_free(tobject->noteStoreUrl);
    tobject->noteStoreUrl = NULL;
  }
  if (tobject->webApiUrlPrefix != NULL)
  {
    g_free(tobject->webApiUrlPrefix);
    tobject->webApiUrlPrefix = NULL;
  }
  if (tobject->secondFactorDeliveryHint != NULL)
  {
    g_free(tobject->secondFactorDeliveryHint);
    tobject->secondFactorDeliveryHint = NULL;
  }
  if (tobject->urls != NULL)
  {
    g_object_unref(tobject->urls);
    tobject->urls = NULL;
  }
}

static void
authentication_result_class_init (AuthenticationResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = authentication_result_read;
  struct_class->write = authentication_result_write;

  gobject_class->finalize = authentication_result_finalize;
  gobject_class->get_property = authentication_result_get_property;
  gobject_class->set_property = authentication_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_CURRENT_TIME,
     g_param_spec_int64 ("currentTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_EXPIRATION,
     g_param_spec_int64 ("expiration",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_USER,
     g_param_spec_object ("user",
                         NULL,
                         NULL,
                         TYPE_USER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_PUBLIC_USER_INFO,
     g_param_spec_object ("publicUserInfo",
                         NULL,
                         NULL,
                         TYPE_PUBLIC_USER_INFO,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_NOTE_STORE_URL,
     g_param_spec_string ("noteStoreUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_WEB_API_URL_PREFIX,
     g_param_spec_string ("webApiUrlPrefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_SECOND_FACTOR_REQUIRED,
     g_param_spec_boolean ("secondFactorRequired",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_SECOND_FACTOR_DELIVERY_HINT,
     g_param_spec_string ("secondFactorDeliveryHint",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AUTHENTICATION_RESULT_URLS,
     g_param_spec_object ("urls",
                         NULL,
                         NULL,
                         TYPE_USER_URLS,
                         G_PARAM_READWRITE));
}

GType
authentication_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AuthenticationResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) authentication_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (AuthenticationResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) authentication_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AuthenticationResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BootstrapSettingsProperties
{
  PROP_BOOTSTRAP_SETTINGS_0,
  PROP_BOOTSTRAP_SETTINGS_SERVICE_HOST,
  PROP_BOOTSTRAP_SETTINGS_MARKETING_URL,
  PROP_BOOTSTRAP_SETTINGS_SUPPORT_URL,
  PROP_BOOTSTRAP_SETTINGS_ACCOUNT_EMAIL_DOMAIN,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_FACEBOOK_SHARING,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_GIFT_SUBSCRIPTIONS,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_SUPPORT_TICKETS,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_SHARED_NOTEBOOKS,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_SINGLE_NOTE_SHARING,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_SPONSORED_ACCOUNTS,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_TWITTER_SHARING,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_LINKED_IN_SHARING,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_PUBLIC_NOTEBOOKS,
  PROP_BOOTSTRAP_SETTINGS_ENABLE_GOOGLE
};

/* reads a bootstrap_settings object */
static gint32
bootstrap_settings_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BootstrapSettings * this_object = BOOTSTRAP_SETTINGS(object);
  gboolean isset_serviceHost = FALSE;
  gboolean isset_marketingUrl = FALSE;
  gboolean isset_supportUrl = FALSE;
  gboolean isset_accountEmailDomain = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->serviceHost != NULL)
          {
            g_free(this_object->serviceHost);
            this_object->serviceHost = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->serviceHost, error)) < 0)
            return -1;
          xfer += ret;
          isset_serviceHost = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->marketingUrl != NULL)
          {
            g_free(this_object->marketingUrl);
            this_object->marketingUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->marketingUrl, error)) < 0)
            return -1;
          xfer += ret;
          isset_marketingUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->supportUrl != NULL)
          {
            g_free(this_object->supportUrl);
            this_object->supportUrl = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->supportUrl, error)) < 0)
            return -1;
          xfer += ret;
          isset_supportUrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->accountEmailDomain != NULL)
          {
            g_free(this_object->accountEmailDomain);
            this_object->accountEmailDomain = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->accountEmailDomain, error)) < 0)
            return -1;
          xfer += ret;
          isset_accountEmailDomain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableFacebookSharing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableFacebookSharing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableGiftSubscriptions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableGiftSubscriptions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableSupportTickets, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableSupportTickets = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableSharedNotebooks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableSharedNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableSingleNoteSharing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableSingleNoteSharing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableSponsoredAccounts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableSponsoredAccounts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableTwitterSharing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableTwitterSharing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableLinkedInSharing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableLinkedInSharing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enablePublicNotebooks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enablePublicNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enableGoogle, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enableGoogle = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_serviceHost)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_marketingUrl)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_supportUrl)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_accountEmailDomain)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
bootstrap_settings_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BootstrapSettings * this_object = BOOTSTRAP_SETTINGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BootstrapSettings", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serviceHost", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->serviceHost, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "marketingUrl", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->marketingUrl, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "supportUrl", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->supportUrl, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "accountEmailDomain", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->accountEmailDomain, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_enableFacebookSharing == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableFacebookSharing", T_BOOL, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableFacebookSharing, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enableGiftSubscriptions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableGiftSubscriptions", T_BOOL, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableGiftSubscriptions, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enableSupportTickets == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableSupportTickets", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableSupportTickets, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enableSharedNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableSharedNotebooks", T_BOOL, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableSharedNotebooks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enableSingleNoteSharing == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableSingleNoteSharing", T_BOOL, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableSingleNoteSharing, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enableSponsoredAccounts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableSponsoredAccounts", T_BOOL, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableSponsoredAccounts, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enableTwitterSharing == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableTwitterSharing", T_BOOL, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableTwitterSharing, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enableLinkedInSharing == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableLinkedInSharing", T_BOOL, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableLinkedInSharing, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enablePublicNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enablePublicNotebooks", T_BOOL, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enablePublicNotebooks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_enableGoogle == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "enableGoogle", T_BOOL, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->enableGoogle, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bootstrap_settings_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  BootstrapSettings *self = BOOTSTRAP_SETTINGS (object);

  switch (property_id)
  {
    case PROP_BOOTSTRAP_SETTINGS_SERVICE_HOST:
      if (self->serviceHost != NULL)
        g_free (self->serviceHost);
      self->serviceHost = g_value_dup_string (value);
      break;

    case PROP_BOOTSTRAP_SETTINGS_MARKETING_URL:
      if (self->marketingUrl != NULL)
        g_free (self->marketingUrl);
      self->marketingUrl = g_value_dup_string (value);
      break;

    case PROP_BOOTSTRAP_SETTINGS_SUPPORT_URL:
      if (self->supportUrl != NULL)
        g_free (self->supportUrl);
      self->supportUrl = g_value_dup_string (value);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ACCOUNT_EMAIL_DOMAIN:
      if (self->accountEmailDomain != NULL)
        g_free (self->accountEmailDomain);
      self->accountEmailDomain = g_value_dup_string (value);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_FACEBOOK_SHARING:
      self->enableFacebookSharing = g_value_get_boolean (value);
      self->__isset_enableFacebookSharing = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_GIFT_SUBSCRIPTIONS:
      self->enableGiftSubscriptions = g_value_get_boolean (value);
      self->__isset_enableGiftSubscriptions = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_SUPPORT_TICKETS:
      self->enableSupportTickets = g_value_get_boolean (value);
      self->__isset_enableSupportTickets = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_SHARED_NOTEBOOKS:
      self->enableSharedNotebooks = g_value_get_boolean (value);
      self->__isset_enableSharedNotebooks = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_SINGLE_NOTE_SHARING:
      self->enableSingleNoteSharing = g_value_get_boolean (value);
      self->__isset_enableSingleNoteSharing = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_SPONSORED_ACCOUNTS:
      self->enableSponsoredAccounts = g_value_get_boolean (value);
      self->__isset_enableSponsoredAccounts = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_TWITTER_SHARING:
      self->enableTwitterSharing = g_value_get_boolean (value);
      self->__isset_enableTwitterSharing = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_LINKED_IN_SHARING:
      self->enableLinkedInSharing = g_value_get_boolean (value);
      self->__isset_enableLinkedInSharing = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_PUBLIC_NOTEBOOKS:
      self->enablePublicNotebooks = g_value_get_boolean (value);
      self->__isset_enablePublicNotebooks = TRUE;
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_GOOGLE:
      self->enableGoogle = g_value_get_boolean (value);
      self->__isset_enableGoogle = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bootstrap_settings_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  BootstrapSettings *self = BOOTSTRAP_SETTINGS (object);

  switch (property_id)
  {
    case PROP_BOOTSTRAP_SETTINGS_SERVICE_HOST:
      g_value_set_string (value, self->serviceHost);
      break;

    case PROP_BOOTSTRAP_SETTINGS_MARKETING_URL:
      g_value_set_string (value, self->marketingUrl);
      break;

    case PROP_BOOTSTRAP_SETTINGS_SUPPORT_URL:
      g_value_set_string (value, self->supportUrl);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ACCOUNT_EMAIL_DOMAIN:
      g_value_set_string (value, self->accountEmailDomain);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_FACEBOOK_SHARING:
      g_value_set_boolean (value, self->enableFacebookSharing);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_GIFT_SUBSCRIPTIONS:
      g_value_set_boolean (value, self->enableGiftSubscriptions);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_SUPPORT_TICKETS:
      g_value_set_boolean (value, self->enableSupportTickets);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_SHARED_NOTEBOOKS:
      g_value_set_boolean (value, self->enableSharedNotebooks);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_SINGLE_NOTE_SHARING:
      g_value_set_boolean (value, self->enableSingleNoteSharing);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_SPONSORED_ACCOUNTS:
      g_value_set_boolean (value, self->enableSponsoredAccounts);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_TWITTER_SHARING:
      g_value_set_boolean (value, self->enableTwitterSharing);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_LINKED_IN_SHARING:
      g_value_set_boolean (value, self->enableLinkedInSharing);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_PUBLIC_NOTEBOOKS:
      g_value_set_boolean (value, self->enablePublicNotebooks);
      break;

    case PROP_BOOTSTRAP_SETTINGS_ENABLE_GOOGLE:
      g_value_set_boolean (value, self->enableGoogle);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bootstrap_settings_instance_init (BootstrapSettings * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->serviceHost = NULL;
  object->marketingUrl = NULL;
  object->supportUrl = NULL;
  object->accountEmailDomain = NULL;
  object->enableFacebookSharing = 0;
  object->__isset_enableFacebookSharing = FALSE;
  object->enableGiftSubscriptions = 0;
  object->__isset_enableGiftSubscriptions = FALSE;
  object->enableSupportTickets = 0;
  object->__isset_enableSupportTickets = FALSE;
  object->enableSharedNotebooks = 0;
  object->__isset_enableSharedNotebooks = FALSE;
  object->enableSingleNoteSharing = 0;
  object->__isset_enableSingleNoteSharing = FALSE;
  object->enableSponsoredAccounts = 0;
  object->__isset_enableSponsoredAccounts = FALSE;
  object->enableTwitterSharing = 0;
  object->__isset_enableTwitterSharing = FALSE;
  object->enableLinkedInSharing = 0;
  object->__isset_enableLinkedInSharing = FALSE;
  object->enablePublicNotebooks = 0;
  object->__isset_enablePublicNotebooks = FALSE;
  object->enableGoogle = 0;
  object->__isset_enableGoogle = FALSE;
}

static void 
bootstrap_settings_finalize (GObject *object)
{
  BootstrapSettings *tobject = BOOTSTRAP_SETTINGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->serviceHost != NULL)
  {
    g_free(tobject->serviceHost);
    tobject->serviceHost = NULL;
  }
  if (tobject->marketingUrl != NULL)
  {
    g_free(tobject->marketingUrl);
    tobject->marketingUrl = NULL;
  }
  if (tobject->supportUrl != NULL)
  {
    g_free(tobject->supportUrl);
    tobject->supportUrl = NULL;
  }
  if (tobject->accountEmailDomain != NULL)
  {
    g_free(tobject->accountEmailDomain);
    tobject->accountEmailDomain = NULL;
  }
}

static void
bootstrap_settings_class_init (BootstrapSettingsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bootstrap_settings_read;
  struct_class->write = bootstrap_settings_write;

  gobject_class->finalize = bootstrap_settings_finalize;
  gobject_class->get_property = bootstrap_settings_get_property;
  gobject_class->set_property = bootstrap_settings_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_SERVICE_HOST,
     g_param_spec_string ("serviceHost",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_MARKETING_URL,
     g_param_spec_string ("marketingUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_SUPPORT_URL,
     g_param_spec_string ("supportUrl",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ACCOUNT_EMAIL_DOMAIN,
     g_param_spec_string ("accountEmailDomain",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_FACEBOOK_SHARING,
     g_param_spec_boolean ("enableFacebookSharing",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_GIFT_SUBSCRIPTIONS,
     g_param_spec_boolean ("enableGiftSubscriptions",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_SUPPORT_TICKETS,
     g_param_spec_boolean ("enableSupportTickets",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_SHARED_NOTEBOOKS,
     g_param_spec_boolean ("enableSharedNotebooks",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_SINGLE_NOTE_SHARING,
     g_param_spec_boolean ("enableSingleNoteSharing",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_SPONSORED_ACCOUNTS,
     g_param_spec_boolean ("enableSponsoredAccounts",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_TWITTER_SHARING,
     g_param_spec_boolean ("enableTwitterSharing",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_LINKED_IN_SHARING,
     g_param_spec_boolean ("enableLinkedInSharing",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_PUBLIC_NOTEBOOKS,
     g_param_spec_boolean ("enablePublicNotebooks",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_SETTINGS_ENABLE_GOOGLE,
     g_param_spec_boolean ("enableGoogle",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
bootstrap_settings_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BootstrapSettingsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bootstrap_settings_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BootstrapSettings),
      0, /* n_preallocs */
      (GInstanceInitFunc) bootstrap_settings_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BootstrapSettingsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BootstrapProfileProperties
{
  PROP_BOOTSTRAP_PROFILE_0,
  PROP_BOOTSTRAP_PROFILE_NAME,
  PROP_BOOTSTRAP_PROFILE_SETTINGS
};

/* reads a bootstrap_profile object */
static gint32
bootstrap_profile_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BootstrapProfile * this_object = BOOTSTRAP_PROFILE(object);
  gboolean isset_name = FALSE;
  gboolean isset_settings = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->settings), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_settings = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_settings)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
bootstrap_profile_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BootstrapProfile * this_object = BOOTSTRAP_PROFILE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BootstrapProfile", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "settings", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->settings), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bootstrap_profile_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  BootstrapProfile *self = BOOTSTRAP_PROFILE (object);

  switch (property_id)
  {
    case PROP_BOOTSTRAP_PROFILE_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      break;

    case PROP_BOOTSTRAP_PROFILE_SETTINGS:
      if (self->settings != NULL)
        g_object_unref (self->settings);
      self->settings = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bootstrap_profile_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  BootstrapProfile *self = BOOTSTRAP_PROFILE (object);

  switch (property_id)
  {
    case PROP_BOOTSTRAP_PROFILE_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_BOOTSTRAP_PROFILE_SETTINGS:
      g_value_set_object (value, self->settings);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bootstrap_profile_instance_init (BootstrapProfile * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->settings = g_object_new (TYPE_BOOTSTRAP_SETTINGS, NULL);
}

static void 
bootstrap_profile_finalize (GObject *object)
{
  BootstrapProfile *tobject = BOOTSTRAP_PROFILE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->settings != NULL)
  {
    g_object_unref(tobject->settings);
    tobject->settings = NULL;
  }
}

static void
bootstrap_profile_class_init (BootstrapProfileClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bootstrap_profile_read;
  struct_class->write = bootstrap_profile_write;

  gobject_class->finalize = bootstrap_profile_finalize;
  gobject_class->get_property = bootstrap_profile_get_property;
  gobject_class->set_property = bootstrap_profile_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_PROFILE_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_PROFILE_SETTINGS,
     g_param_spec_object ("settings",
                         NULL,
                         NULL,
                         TYPE_BOOTSTRAP_SETTINGS,
                         G_PARAM_READWRITE));
}

GType
bootstrap_profile_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BootstrapProfileClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bootstrap_profile_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BootstrapProfile),
      0, /* n_preallocs */
      (GInstanceInitFunc) bootstrap_profile_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BootstrapProfileType",
                                   &type_info, 0);
  }

  return type;
}

enum _BootstrapInfoProperties
{
  PROP_BOOTSTRAP_INFO_0,
  PROP_BOOTSTRAP_INFO_PROFILES
};

/* reads a bootstrap_info object */
static gint32
bootstrap_info_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BootstrapInfo * this_object = BOOTSTRAP_INFO(object);
  gboolean isset_profiles = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              BootstrapProfile * _elem1 = NULL;
              if ( _elem1 != NULL)
              {
                g_object_unref (_elem1);
              }
              _elem1 = g_object_new (TYPE_BOOTSTRAP_PROFILE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1), protocol, error)) < 0)
              {
                g_object_unref (_elem1);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->profiles, _elem1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_profiles = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_profiles)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
bootstrap_info_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BootstrapInfo * this_object = BOOTSTRAP_INFO(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BootstrapInfo", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "profiles", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i2;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->profiles ? this_object->profiles->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i2 = 0; i2 < (this_object->profiles ? this_object->profiles->len : 0); i2++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->profiles, i2))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bootstrap_info_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  BootstrapInfo *self = BOOTSTRAP_INFO (object);

  switch (property_id)
  {
    case PROP_BOOTSTRAP_INFO_PROFILES:
      if (self->profiles != NULL)
        g_ptr_array_unref (self->profiles);
      self->profiles = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bootstrap_info_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  BootstrapInfo *self = BOOTSTRAP_INFO (object);

  switch (property_id)
  {
    case PROP_BOOTSTRAP_INFO_PROFILES:
      g_value_set_boxed (value, self->profiles);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bootstrap_info_instance_init (BootstrapInfo * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->profiles = g_ptr_array_new_with_free_func (g_object_unref);
}

static void 
bootstrap_info_finalize (GObject *object)
{
  BootstrapInfo *tobject = BOOTSTRAP_INFO (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->profiles != NULL)
  {
    g_ptr_array_unref (tobject->profiles);
    tobject->profiles = NULL;
  }
}

static void
bootstrap_info_class_init (BootstrapInfoClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bootstrap_info_read;
  struct_class->write = bootstrap_info_write;

  gobject_class->finalize = bootstrap_info_finalize;
  gobject_class->get_property = bootstrap_info_get_property;
  gobject_class->set_property = bootstrap_info_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BOOTSTRAP_INFO_PROFILES,
     g_param_spec_boxed ("profiles",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
bootstrap_info_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BootstrapInfoClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bootstrap_info_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BootstrapInfo),
      0, /* n_preallocs */
      (GInstanceInitFunc) bootstrap_info_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BootstrapInfoType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _UserStoreCheckVersionArgsProperties
{
  PROP_USER_STORE_CHECK_VERSION_ARGS_0,
  PROP_USER_STORE_CHECK_VERSION_ARGS_CLIENT_NAME,
  PROP_USER_STORE_CHECK_VERSION_ARGS_EDAM_VERSION_MAJOR,
  PROP_USER_STORE_CHECK_VERSION_ARGS_EDAM_VERSION_MINOR
};

/* reads a user_store_check_version_args object */
static gint32
user_store_check_version_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreCheckVersionArgs * this_object = USER_STORE_CHECK_VERSION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->clientName != NULL)
          {
            g_free(this_object->clientName);
            this_object->clientName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->clientName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_clientName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->edamVersionMajor, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_edamVersionMajor = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->edamVersionMinor, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_edamVersionMinor = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_check_version_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreCheckVersionArgs * this_object = USER_STORE_CHECK_VERSION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreCheckVersionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "clientName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->clientName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "edamVersionMajor", T_I16, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->edamVersionMajor, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "edamVersionMinor", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->edamVersionMinor, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_check_version_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  UserStoreCheckVersionArgs *self = USER_STORE_CHECK_VERSION_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_CHECK_VERSION_ARGS_CLIENT_NAME:
      if (self->clientName != NULL)
        g_free (self->clientName);
      self->clientName = g_value_dup_string (value);
      self->__isset_clientName = TRUE;
      break;

    case PROP_USER_STORE_CHECK_VERSION_ARGS_EDAM_VERSION_MAJOR:
      self->edamVersionMajor = g_value_get_int (value);
      self->__isset_edamVersionMajor = TRUE;
      break;

    case PROP_USER_STORE_CHECK_VERSION_ARGS_EDAM_VERSION_MINOR:
      self->edamVersionMinor = g_value_get_int (value);
      self->__isset_edamVersionMinor = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_check_version_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  UserStoreCheckVersionArgs *self = USER_STORE_CHECK_VERSION_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_CHECK_VERSION_ARGS_CLIENT_NAME:
      g_value_set_string (value, self->clientName);
      break;

    case PROP_USER_STORE_CHECK_VERSION_ARGS_EDAM_VERSION_MAJOR:
      g_value_set_int (value, self->edamVersionMajor);
      break;

    case PROP_USER_STORE_CHECK_VERSION_ARGS_EDAM_VERSION_MINOR:
      g_value_set_int (value, self->edamVersionMinor);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_check_version_args_instance_init (UserStoreCheckVersionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->clientName = NULL;
  object->__isset_clientName = FALSE;
  object->edamVersionMajor = 1;
  object->__isset_edamVersionMajor = FALSE;
  object->edamVersionMinor = 28;
  object->__isset_edamVersionMinor = FALSE;
}

static void 
user_store_check_version_args_finalize (GObject *object)
{
  UserStoreCheckVersionArgs *tobject = USER_STORE_CHECK_VERSION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->clientName != NULL)
  {
    g_free(tobject->clientName);
    tobject->clientName = NULL;
  }
}

static void
user_store_check_version_args_class_init (UserStoreCheckVersionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_check_version_args_read;
  struct_class->write = user_store_check_version_args_write;

  gobject_class->finalize = user_store_check_version_args_finalize;
  gobject_class->get_property = user_store_check_version_args_get_property;
  gobject_class->set_property = user_store_check_version_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_CHECK_VERSION_ARGS_CLIENT_NAME,
     g_param_spec_string ("clientName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_CHECK_VERSION_ARGS_EDAM_VERSION_MAJOR,
     g_param_spec_int ("edamVersionMajor",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_CHECK_VERSION_ARGS_EDAM_VERSION_MINOR,
     g_param_spec_int ("edamVersionMinor",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       28,
                       G_PARAM_READWRITE));
}

GType
user_store_check_version_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreCheckVersionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_check_version_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreCheckVersionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_check_version_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreCheckVersionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreCheckVersionResultProperties
{
  PROP_USER_STORE_CHECK_VERSION_RESULT_0,
  PROP_USER_STORE_CHECK_VERSION_RESULT_SUCCESS
};

/* reads a user_store_check_version_result object */
static gint32
user_store_check_version_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreCheckVersionResult * this_object = USER_STORE_CHECK_VERSION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_check_version_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreCheckVersionResult * this_object = USER_STORE_CHECK_VERSION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreCheckVersionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_check_version_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  UserStoreCheckVersionResult *self = USER_STORE_CHECK_VERSION_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_CHECK_VERSION_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_check_version_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  UserStoreCheckVersionResult *self = USER_STORE_CHECK_VERSION_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_CHECK_VERSION_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_check_version_result_instance_init (UserStoreCheckVersionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
user_store_check_version_result_finalize (GObject *object)
{
  UserStoreCheckVersionResult *tobject = USER_STORE_CHECK_VERSION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
user_store_check_version_result_class_init (UserStoreCheckVersionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_check_version_result_read;
  struct_class->write = user_store_check_version_result_write;

  gobject_class->finalize = user_store_check_version_result_finalize;
  gobject_class->get_property = user_store_check_version_result_get_property;
  gobject_class->set_property = user_store_check_version_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_CHECK_VERSION_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
user_store_check_version_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreCheckVersionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_check_version_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreCheckVersionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_check_version_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreCheckVersionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetBootstrapInfoArgsProperties
{
  PROP_USER_STORE_GET_BOOTSTRAP_INFO_ARGS_0,
  PROP_USER_STORE_GET_BOOTSTRAP_INFO_ARGS_LOCALE
};

/* reads a user_store_get_bootstrap_info_args object */
static gint32
user_store_get_bootstrap_info_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetBootstrapInfoArgs * this_object = USER_STORE_GET_BOOTSTRAP_INFO_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->locale != NULL)
          {
            g_free(this_object->locale);
            this_object->locale = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->locale, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_locale = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_bootstrap_info_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetBootstrapInfoArgs * this_object = USER_STORE_GET_BOOTSTRAP_INFO_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetBootstrapInfoArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "locale", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->locale, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_bootstrap_info_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  UserStoreGetBootstrapInfoArgs *self = USER_STORE_GET_BOOTSTRAP_INFO_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_BOOTSTRAP_INFO_ARGS_LOCALE:
      if (self->locale != NULL)
        g_free (self->locale);
      self->locale = g_value_dup_string (value);
      self->__isset_locale = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_bootstrap_info_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  UserStoreGetBootstrapInfoArgs *self = USER_STORE_GET_BOOTSTRAP_INFO_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_BOOTSTRAP_INFO_ARGS_LOCALE:
      g_value_set_string (value, self->locale);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_bootstrap_info_args_instance_init (UserStoreGetBootstrapInfoArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->locale = NULL;
  object->__isset_locale = FALSE;
}

static void 
user_store_get_bootstrap_info_args_finalize (GObject *object)
{
  UserStoreGetBootstrapInfoArgs *tobject = USER_STORE_GET_BOOTSTRAP_INFO_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->locale != NULL)
  {
    g_free(tobject->locale);
    tobject->locale = NULL;
  }
}

static void
user_store_get_bootstrap_info_args_class_init (UserStoreGetBootstrapInfoArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_bootstrap_info_args_read;
  struct_class->write = user_store_get_bootstrap_info_args_write;

  gobject_class->finalize = user_store_get_bootstrap_info_args_finalize;
  gobject_class->get_property = user_store_get_bootstrap_info_args_get_property;
  gobject_class->set_property = user_store_get_bootstrap_info_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_BOOTSTRAP_INFO_ARGS_LOCALE,
     g_param_spec_string ("locale",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_get_bootstrap_info_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetBootstrapInfoArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_bootstrap_info_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetBootstrapInfoArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_bootstrap_info_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetBootstrapInfoArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetBootstrapInfoResultProperties
{
  PROP_USER_STORE_GET_BOOTSTRAP_INFO_RESULT_0,
  PROP_USER_STORE_GET_BOOTSTRAP_INFO_RESULT_SUCCESS
};

/* reads a user_store_get_bootstrap_info_result object */
static gint32
user_store_get_bootstrap_info_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetBootstrapInfoResult * this_object = USER_STORE_GET_BOOTSTRAP_INFO_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_bootstrap_info_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetBootstrapInfoResult * this_object = USER_STORE_GET_BOOTSTRAP_INFO_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetBootstrapInfoResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_bootstrap_info_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreGetBootstrapInfoResult *self = USER_STORE_GET_BOOTSTRAP_INFO_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_BOOTSTRAP_INFO_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_bootstrap_info_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreGetBootstrapInfoResult *self = USER_STORE_GET_BOOTSTRAP_INFO_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_BOOTSTRAP_INFO_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_bootstrap_info_result_instance_init (UserStoreGetBootstrapInfoResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_BOOTSTRAP_INFO, NULL);
  object->__isset_success = FALSE;
}

static void 
user_store_get_bootstrap_info_result_finalize (GObject *object)
{
  UserStoreGetBootstrapInfoResult *tobject = USER_STORE_GET_BOOTSTRAP_INFO_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
user_store_get_bootstrap_info_result_class_init (UserStoreGetBootstrapInfoResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_bootstrap_info_result_read;
  struct_class->write = user_store_get_bootstrap_info_result_write;

  gobject_class->finalize = user_store_get_bootstrap_info_result_finalize;
  gobject_class->get_property = user_store_get_bootstrap_info_result_get_property;
  gobject_class->set_property = user_store_get_bootstrap_info_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_BOOTSTRAP_INFO_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_BOOTSTRAP_INFO,
                         G_PARAM_READWRITE));
}

GType
user_store_get_bootstrap_info_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetBootstrapInfoResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_bootstrap_info_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetBootstrapInfoResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_bootstrap_info_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetBootstrapInfoResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreAuthenticateLongSessionArgsProperties
{
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_0,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_USERNAME,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_PASSWORD,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_CONSUMER_KEY,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_CONSUMER_SECRET,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_DEVICE_IDENTIFIER,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_DEVICE_DESCRIPTION,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_SUPPORTS_TWO_FACTOR
};

/* reads a user_store_authenticate_long_session_args object */
static gint32
user_store_authenticate_long_session_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreAuthenticateLongSessionArgs * this_object = USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->username != NULL)
          {
            g_free(this_object->username);
            this_object->username = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->username, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_username = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->password != NULL)
          {
            g_free(this_object->password);
            this_object->password = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->password, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_password = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->consumerKey != NULL)
          {
            g_free(this_object->consumerKey);
            this_object->consumerKey = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->consumerKey, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_consumerKey = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->consumerSecret != NULL)
          {
            g_free(this_object->consumerSecret);
            this_object->consumerSecret = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->consumerSecret, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_consumerSecret = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->deviceIdentifier != NULL)
          {
            g_free(this_object->deviceIdentifier);
            this_object->deviceIdentifier = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->deviceIdentifier, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceIdentifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->deviceDescription != NULL)
          {
            g_free(this_object->deviceDescription);
            this_object->deviceDescription = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->deviceDescription, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceDescription = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->supportsTwoFactor, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_supportsTwoFactor = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_authenticate_long_session_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreAuthenticateLongSessionArgs * this_object = USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreAuthenticateLongSessionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "username", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->username, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->password, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "consumerKey", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->consumerKey, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "consumerSecret", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->consumerSecret, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceIdentifier", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->deviceIdentifier, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceDescription", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->deviceDescription, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "supportsTwoFactor", T_BOOL, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->supportsTwoFactor, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_authenticate_long_session_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  UserStoreAuthenticateLongSessionArgs *self = USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_USERNAME:
      if (self->username != NULL)
        g_free (self->username);
      self->username = g_value_dup_string (value);
      self->__isset_username = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_PASSWORD:
      if (self->password != NULL)
        g_free (self->password);
      self->password = g_value_dup_string (value);
      self->__isset_password = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_CONSUMER_KEY:
      if (self->consumerKey != NULL)
        g_free (self->consumerKey);
      self->consumerKey = g_value_dup_string (value);
      self->__isset_consumerKey = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_CONSUMER_SECRET:
      if (self->consumerSecret != NULL)
        g_free (self->consumerSecret);
      self->consumerSecret = g_value_dup_string (value);
      self->__isset_consumerSecret = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_DEVICE_IDENTIFIER:
      if (self->deviceIdentifier != NULL)
        g_free (self->deviceIdentifier);
      self->deviceIdentifier = g_value_dup_string (value);
      self->__isset_deviceIdentifier = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_DEVICE_DESCRIPTION:
      if (self->deviceDescription != NULL)
        g_free (self->deviceDescription);
      self->deviceDescription = g_value_dup_string (value);
      self->__isset_deviceDescription = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_SUPPORTS_TWO_FACTOR:
      self->supportsTwoFactor = g_value_get_boolean (value);
      self->__isset_supportsTwoFactor = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_authenticate_long_session_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  UserStoreAuthenticateLongSessionArgs *self = USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_USERNAME:
      g_value_set_string (value, self->username);
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_PASSWORD:
      g_value_set_string (value, self->password);
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_CONSUMER_KEY:
      g_value_set_string (value, self->consumerKey);
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_CONSUMER_SECRET:
      g_value_set_string (value, self->consumerSecret);
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_DEVICE_IDENTIFIER:
      g_value_set_string (value, self->deviceIdentifier);
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_DEVICE_DESCRIPTION:
      g_value_set_string (value, self->deviceDescription);
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_SUPPORTS_TWO_FACTOR:
      g_value_set_boolean (value, self->supportsTwoFactor);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_authenticate_long_session_args_instance_init (UserStoreAuthenticateLongSessionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->username = NULL;
  object->__isset_username = FALSE;
  object->password = NULL;
  object->__isset_password = FALSE;
  object->consumerKey = NULL;
  object->__isset_consumerKey = FALSE;
  object->consumerSecret = NULL;
  object->__isset_consumerSecret = FALSE;
  object->deviceIdentifier = NULL;
  object->__isset_deviceIdentifier = FALSE;
  object->deviceDescription = NULL;
  object->__isset_deviceDescription = FALSE;
  object->supportsTwoFactor = 0;
  object->__isset_supportsTwoFactor = FALSE;
}

static void 
user_store_authenticate_long_session_args_finalize (GObject *object)
{
  UserStoreAuthenticateLongSessionArgs *tobject = USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->username != NULL)
  {
    g_free(tobject->username);
    tobject->username = NULL;
  }
  if (tobject->password != NULL)
  {
    g_free(tobject->password);
    tobject->password = NULL;
  }
  if (tobject->consumerKey != NULL)
  {
    g_free(tobject->consumerKey);
    tobject->consumerKey = NULL;
  }
  if (tobject->consumerSecret != NULL)
  {
    g_free(tobject->consumerSecret);
    tobject->consumerSecret = NULL;
  }
  if (tobject->deviceIdentifier != NULL)
  {
    g_free(tobject->deviceIdentifier);
    tobject->deviceIdentifier = NULL;
  }
  if (tobject->deviceDescription != NULL)
  {
    g_free(tobject->deviceDescription);
    tobject->deviceDescription = NULL;
  }
}

static void
user_store_authenticate_long_session_args_class_init (UserStoreAuthenticateLongSessionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_authenticate_long_session_args_read;
  struct_class->write = user_store_authenticate_long_session_args_write;

  gobject_class->finalize = user_store_authenticate_long_session_args_finalize;
  gobject_class->get_property = user_store_authenticate_long_session_args_get_property;
  gobject_class->set_property = user_store_authenticate_long_session_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_USERNAME,
     g_param_spec_string ("username",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_PASSWORD,
     g_param_spec_string ("password",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_CONSUMER_KEY,
     g_param_spec_string ("consumerKey",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_CONSUMER_SECRET,
     g_param_spec_string ("consumerSecret",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_DEVICE_IDENTIFIER,
     g_param_spec_string ("deviceIdentifier",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_DEVICE_DESCRIPTION,
     g_param_spec_string ("deviceDescription",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_ARGS_SUPPORTS_TWO_FACTOR,
     g_param_spec_boolean ("supportsTwoFactor",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
user_store_authenticate_long_session_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreAuthenticateLongSessionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_authenticate_long_session_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreAuthenticateLongSessionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_authenticate_long_session_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreAuthenticateLongSessionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreAuthenticateLongSessionResultProperties
{
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_0,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_SUCCESS,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_authenticate_long_session_result object */
static gint32
user_store_authenticate_long_session_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreAuthenticateLongSessionResult * this_object = USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_authenticate_long_session_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreAuthenticateLongSessionResult * this_object = USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreAuthenticateLongSessionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_authenticate_long_session_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  UserStoreAuthenticateLongSessionResult *self = USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_authenticate_long_session_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  UserStoreAuthenticateLongSessionResult *self = USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_authenticate_long_session_result_instance_init (UserStoreAuthenticateLongSessionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_AUTHENTICATION_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_authenticate_long_session_result_finalize (GObject *object)
{
  UserStoreAuthenticateLongSessionResult *tobject = USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_authenticate_long_session_result_class_init (UserStoreAuthenticateLongSessionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_authenticate_long_session_result_read;
  struct_class->write = user_store_authenticate_long_session_result_write;

  gobject_class->finalize = user_store_authenticate_long_session_result_finalize;
  gobject_class->get_property = user_store_authenticate_long_session_result_get_property;
  gobject_class->set_property = user_store_authenticate_long_session_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_AUTHENTICATION_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_LONG_SESSION_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_authenticate_long_session_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreAuthenticateLongSessionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_authenticate_long_session_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreAuthenticateLongSessionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_authenticate_long_session_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreAuthenticateLongSessionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreCompleteTwoFactorAuthenticationArgsProperties
{
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_0,
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_AUTHENTICATION_TOKEN,
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_ONE_TIME_CODE,
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_DEVICE_IDENTIFIER,
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_DEVICE_DESCRIPTION
};

/* reads a user_store_complete_two_factor_authentication_args object */
static gint32
user_store_complete_two_factor_authentication_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreCompleteTwoFactorAuthenticationArgs * this_object = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->oneTimeCode != NULL)
          {
            g_free(this_object->oneTimeCode);
            this_object->oneTimeCode = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->oneTimeCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_oneTimeCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->deviceIdentifier != NULL)
          {
            g_free(this_object->deviceIdentifier);
            this_object->deviceIdentifier = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->deviceIdentifier, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceIdentifier = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->deviceDescription != NULL)
          {
            g_free(this_object->deviceDescription);
            this_object->deviceDescription = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->deviceDescription, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceDescription = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_complete_two_factor_authentication_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreCompleteTwoFactorAuthenticationArgs * this_object = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreCompleteTwoFactorAuthenticationArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "oneTimeCode", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->oneTimeCode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceIdentifier", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->deviceIdentifier, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceDescription", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->deviceDescription, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_complete_two_factor_authentication_args_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  UserStoreCompleteTwoFactorAuthenticationArgs *self = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_ONE_TIME_CODE:
      if (self->oneTimeCode != NULL)
        g_free (self->oneTimeCode);
      self->oneTimeCode = g_value_dup_string (value);
      self->__isset_oneTimeCode = TRUE;
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_DEVICE_IDENTIFIER:
      if (self->deviceIdentifier != NULL)
        g_free (self->deviceIdentifier);
      self->deviceIdentifier = g_value_dup_string (value);
      self->__isset_deviceIdentifier = TRUE;
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_DEVICE_DESCRIPTION:
      if (self->deviceDescription != NULL)
        g_free (self->deviceDescription);
      self->deviceDescription = g_value_dup_string (value);
      self->__isset_deviceDescription = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_complete_two_factor_authentication_args_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  UserStoreCompleteTwoFactorAuthenticationArgs *self = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_ONE_TIME_CODE:
      g_value_set_string (value, self->oneTimeCode);
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_DEVICE_IDENTIFIER:
      g_value_set_string (value, self->deviceIdentifier);
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_DEVICE_DESCRIPTION:
      g_value_set_string (value, self->deviceDescription);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_complete_two_factor_authentication_args_instance_init (UserStoreCompleteTwoFactorAuthenticationArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->oneTimeCode = NULL;
  object->__isset_oneTimeCode = FALSE;
  object->deviceIdentifier = NULL;
  object->__isset_deviceIdentifier = FALSE;
  object->deviceDescription = NULL;
  object->__isset_deviceDescription = FALSE;
}

static void 
user_store_complete_two_factor_authentication_args_finalize (GObject *object)
{
  UserStoreCompleteTwoFactorAuthenticationArgs *tobject = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->oneTimeCode != NULL)
  {
    g_free(tobject->oneTimeCode);
    tobject->oneTimeCode = NULL;
  }
  if (tobject->deviceIdentifier != NULL)
  {
    g_free(tobject->deviceIdentifier);
    tobject->deviceIdentifier = NULL;
  }
  if (tobject->deviceDescription != NULL)
  {
    g_free(tobject->deviceDescription);
    tobject->deviceDescription = NULL;
  }
}

static void
user_store_complete_two_factor_authentication_args_class_init (UserStoreCompleteTwoFactorAuthenticationArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_complete_two_factor_authentication_args_read;
  struct_class->write = user_store_complete_two_factor_authentication_args_write;

  gobject_class->finalize = user_store_complete_two_factor_authentication_args_finalize;
  gobject_class->get_property = user_store_complete_two_factor_authentication_args_get_property;
  gobject_class->set_property = user_store_complete_two_factor_authentication_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_ONE_TIME_CODE,
     g_param_spec_string ("oneTimeCode",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_DEVICE_IDENTIFIER,
     g_param_spec_string ("deviceIdentifier",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_ARGS_DEVICE_DESCRIPTION,
     g_param_spec_string ("deviceDescription",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_complete_two_factor_authentication_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreCompleteTwoFactorAuthenticationArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_complete_two_factor_authentication_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreCompleteTwoFactorAuthenticationArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_complete_two_factor_authentication_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreCompleteTwoFactorAuthenticationArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreCompleteTwoFactorAuthenticationResultProperties
{
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_0,
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_SUCCESS,
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_complete_two_factor_authentication_result object */
static gint32
user_store_complete_two_factor_authentication_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreCompleteTwoFactorAuthenticationResult * this_object = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_complete_two_factor_authentication_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreCompleteTwoFactorAuthenticationResult * this_object = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreCompleteTwoFactorAuthenticationResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_complete_two_factor_authentication_result_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  UserStoreCompleteTwoFactorAuthenticationResult *self = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_complete_two_factor_authentication_result_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  UserStoreCompleteTwoFactorAuthenticationResult *self = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_complete_two_factor_authentication_result_instance_init (UserStoreCompleteTwoFactorAuthenticationResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_AUTHENTICATION_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_complete_two_factor_authentication_result_finalize (GObject *object)
{
  UserStoreCompleteTwoFactorAuthenticationResult *tobject = USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_complete_two_factor_authentication_result_class_init (UserStoreCompleteTwoFactorAuthenticationResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_complete_two_factor_authentication_result_read;
  struct_class->write = user_store_complete_two_factor_authentication_result_write;

  gobject_class->finalize = user_store_complete_two_factor_authentication_result_finalize;
  gobject_class->get_property = user_store_complete_two_factor_authentication_result_get_property;
  gobject_class->set_property = user_store_complete_two_factor_authentication_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_AUTHENTICATION_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_COMPLETE_TWO_FACTOR_AUTHENTICATION_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_complete_two_factor_authentication_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreCompleteTwoFactorAuthenticationResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_complete_two_factor_authentication_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreCompleteTwoFactorAuthenticationResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_complete_two_factor_authentication_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreCompleteTwoFactorAuthenticationResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreRevokeLongSessionArgsProperties
{
  PROP_USER_STORE_REVOKE_LONG_SESSION_ARGS_0,
  PROP_USER_STORE_REVOKE_LONG_SESSION_ARGS_AUTHENTICATION_TOKEN
};

/* reads a user_store_revoke_long_session_args object */
static gint32
user_store_revoke_long_session_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreRevokeLongSessionArgs * this_object = USER_STORE_REVOKE_LONG_SESSION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_revoke_long_session_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreRevokeLongSessionArgs * this_object = USER_STORE_REVOKE_LONG_SESSION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreRevokeLongSessionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_revoke_long_session_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  UserStoreRevokeLongSessionArgs *self = USER_STORE_REVOKE_LONG_SESSION_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_REVOKE_LONG_SESSION_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_revoke_long_session_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  UserStoreRevokeLongSessionArgs *self = USER_STORE_REVOKE_LONG_SESSION_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_REVOKE_LONG_SESSION_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_revoke_long_session_args_instance_init (UserStoreRevokeLongSessionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
user_store_revoke_long_session_args_finalize (GObject *object)
{
  UserStoreRevokeLongSessionArgs *tobject = USER_STORE_REVOKE_LONG_SESSION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
user_store_revoke_long_session_args_class_init (UserStoreRevokeLongSessionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_revoke_long_session_args_read;
  struct_class->write = user_store_revoke_long_session_args_write;

  gobject_class->finalize = user_store_revoke_long_session_args_finalize;
  gobject_class->get_property = user_store_revoke_long_session_args_get_property;
  gobject_class->set_property = user_store_revoke_long_session_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_REVOKE_LONG_SESSION_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_revoke_long_session_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreRevokeLongSessionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_revoke_long_session_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreRevokeLongSessionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_revoke_long_session_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreRevokeLongSessionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreRevokeLongSessionResultProperties
{
  PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_0,
  PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_revoke_long_session_result object */
static gint32
user_store_revoke_long_session_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreRevokeLongSessionResult * this_object = USER_STORE_REVOKE_LONG_SESSION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_revoke_long_session_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreRevokeLongSessionResult * this_object = USER_STORE_REVOKE_LONG_SESSION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreRevokeLongSessionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_revoke_long_session_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  UserStoreRevokeLongSessionResult *self = USER_STORE_REVOKE_LONG_SESSION_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_revoke_long_session_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  UserStoreRevokeLongSessionResult *self = USER_STORE_REVOKE_LONG_SESSION_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_revoke_long_session_result_instance_init (UserStoreRevokeLongSessionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_revoke_long_session_result_finalize (GObject *object)
{
  UserStoreRevokeLongSessionResult *tobject = USER_STORE_REVOKE_LONG_SESSION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_revoke_long_session_result_class_init (UserStoreRevokeLongSessionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_revoke_long_session_result_read;
  struct_class->write = user_store_revoke_long_session_result_write;

  gobject_class->finalize = user_store_revoke_long_session_result_finalize;
  gobject_class->get_property = user_store_revoke_long_session_result_get_property;
  gobject_class->set_property = user_store_revoke_long_session_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_REVOKE_LONG_SESSION_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_revoke_long_session_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreRevokeLongSessionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_revoke_long_session_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreRevokeLongSessionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_revoke_long_session_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreRevokeLongSessionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreAuthenticateToBusinessArgsProperties
{
  PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS_0,
  PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS_AUTHENTICATION_TOKEN
};

/* reads a user_store_authenticate_to_business_args object */
static gint32
user_store_authenticate_to_business_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreAuthenticateToBusinessArgs * this_object = USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_authenticate_to_business_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreAuthenticateToBusinessArgs * this_object = USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreAuthenticateToBusinessArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_authenticate_to_business_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  UserStoreAuthenticateToBusinessArgs *self = USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_authenticate_to_business_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  UserStoreAuthenticateToBusinessArgs *self = USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_authenticate_to_business_args_instance_init (UserStoreAuthenticateToBusinessArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
user_store_authenticate_to_business_args_finalize (GObject *object)
{
  UserStoreAuthenticateToBusinessArgs *tobject = USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
user_store_authenticate_to_business_args_class_init (UserStoreAuthenticateToBusinessArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_authenticate_to_business_args_read;
  struct_class->write = user_store_authenticate_to_business_args_write;

  gobject_class->finalize = user_store_authenticate_to_business_args_finalize;
  gobject_class->get_property = user_store_authenticate_to_business_args_get_property;
  gobject_class->set_property = user_store_authenticate_to_business_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_authenticate_to_business_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreAuthenticateToBusinessArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_authenticate_to_business_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreAuthenticateToBusinessArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_authenticate_to_business_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreAuthenticateToBusinessArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreAuthenticateToBusinessResultProperties
{
  PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_0,
  PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_SUCCESS,
  PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_authenticate_to_business_result object */
static gint32
user_store_authenticate_to_business_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreAuthenticateToBusinessResult * this_object = USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_authenticate_to_business_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreAuthenticateToBusinessResult * this_object = USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreAuthenticateToBusinessResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_authenticate_to_business_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  UserStoreAuthenticateToBusinessResult *self = USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_authenticate_to_business_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  UserStoreAuthenticateToBusinessResult *self = USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_authenticate_to_business_result_instance_init (UserStoreAuthenticateToBusinessResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_AUTHENTICATION_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_authenticate_to_business_result_finalize (GObject *object)
{
  UserStoreAuthenticateToBusinessResult *tobject = USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_authenticate_to_business_result_class_init (UserStoreAuthenticateToBusinessResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_authenticate_to_business_result_read;
  struct_class->write = user_store_authenticate_to_business_result_write;

  gobject_class->finalize = user_store_authenticate_to_business_result_finalize;
  gobject_class->get_property = user_store_authenticate_to_business_result_get_property;
  gobject_class->set_property = user_store_authenticate_to_business_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_AUTHENTICATION_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_AUTHENTICATE_TO_BUSINESS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_authenticate_to_business_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreAuthenticateToBusinessResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_authenticate_to_business_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreAuthenticateToBusinessResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_authenticate_to_business_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreAuthenticateToBusinessResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetUserArgsProperties
{
  PROP_USER_STORE_GET_USER_ARGS_0,
  PROP_USER_STORE_GET_USER_ARGS_AUTHENTICATION_TOKEN
};

/* reads a user_store_get_user_args object */
static gint32
user_store_get_user_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetUserArgs * this_object = USER_STORE_GET_USER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_user_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetUserArgs * this_object = USER_STORE_GET_USER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetUserArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_user_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  UserStoreGetUserArgs *self = USER_STORE_GET_USER_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_USER_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_user_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  UserStoreGetUserArgs *self = USER_STORE_GET_USER_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_USER_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_user_args_instance_init (UserStoreGetUserArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
user_store_get_user_args_finalize (GObject *object)
{
  UserStoreGetUserArgs *tobject = USER_STORE_GET_USER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
user_store_get_user_args_class_init (UserStoreGetUserArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_user_args_read;
  struct_class->write = user_store_get_user_args_write;

  gobject_class->finalize = user_store_get_user_args_finalize;
  gobject_class->get_property = user_store_get_user_args_get_property;
  gobject_class->set_property = user_store_get_user_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_USER_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_get_user_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetUserArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_user_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetUserArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_user_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetUserArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetUserResultProperties
{
  PROP_USER_STORE_GET_USER_RESULT_0,
  PROP_USER_STORE_GET_USER_RESULT_SUCCESS,
  PROP_USER_STORE_GET_USER_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_GET_USER_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_get_user_result object */
static gint32
user_store_get_user_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetUserResult * this_object = USER_STORE_GET_USER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_user_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetUserResult * this_object = USER_STORE_GET_USER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetUserResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_user_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  UserStoreGetUserResult *self = USER_STORE_GET_USER_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_USER_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_GET_USER_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_GET_USER_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_user_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  UserStoreGetUserResult *self = USER_STORE_GET_USER_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_USER_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_USER_STORE_GET_USER_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_GET_USER_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_user_result_instance_init (UserStoreGetUserResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_USER, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_get_user_result_finalize (GObject *object)
{
  UserStoreGetUserResult *tobject = USER_STORE_GET_USER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_get_user_result_class_init (UserStoreGetUserResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_user_result_read;
  struct_class->write = user_store_get_user_result_write;

  gobject_class->finalize = user_store_get_user_result_finalize;
  gobject_class->get_property = user_store_get_user_result_get_property;
  gobject_class->set_property = user_store_get_user_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_USER_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_USER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_USER_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_USER_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_get_user_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetUserResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_user_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetUserResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_user_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetUserResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetPublicUserInfoArgsProperties
{
  PROP_USER_STORE_GET_PUBLIC_USER_INFO_ARGS_0,
  PROP_USER_STORE_GET_PUBLIC_USER_INFO_ARGS_USERNAME
};

/* reads a user_store_get_public_user_info_args object */
static gint32
user_store_get_public_user_info_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetPublicUserInfoArgs * this_object = USER_STORE_GET_PUBLIC_USER_INFO_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->username != NULL)
          {
            g_free(this_object->username);
            this_object->username = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->username, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_username = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_public_user_info_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetPublicUserInfoArgs * this_object = USER_STORE_GET_PUBLIC_USER_INFO_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetPublicUserInfoArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "username", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->username, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_public_user_info_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreGetPublicUserInfoArgs *self = USER_STORE_GET_PUBLIC_USER_INFO_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_ARGS_USERNAME:
      if (self->username != NULL)
        g_free (self->username);
      self->username = g_value_dup_string (value);
      self->__isset_username = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_public_user_info_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreGetPublicUserInfoArgs *self = USER_STORE_GET_PUBLIC_USER_INFO_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_ARGS_USERNAME:
      g_value_set_string (value, self->username);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_public_user_info_args_instance_init (UserStoreGetPublicUserInfoArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->username = NULL;
  object->__isset_username = FALSE;
}

static void 
user_store_get_public_user_info_args_finalize (GObject *object)
{
  UserStoreGetPublicUserInfoArgs *tobject = USER_STORE_GET_PUBLIC_USER_INFO_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->username != NULL)
  {
    g_free(tobject->username);
    tobject->username = NULL;
  }
}

static void
user_store_get_public_user_info_args_class_init (UserStoreGetPublicUserInfoArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_public_user_info_args_read;
  struct_class->write = user_store_get_public_user_info_args_write;

  gobject_class->finalize = user_store_get_public_user_info_args_finalize;
  gobject_class->get_property = user_store_get_public_user_info_args_get_property;
  gobject_class->set_property = user_store_get_public_user_info_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_PUBLIC_USER_INFO_ARGS_USERNAME,
     g_param_spec_string ("username",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_get_public_user_info_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetPublicUserInfoArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_public_user_info_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetPublicUserInfoArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_public_user_info_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetPublicUserInfoArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetPublicUserInfoResultProperties
{
  PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_0,
  PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_SUCCESS,
  PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_NOT_FOUND_EXCEPTION,
  PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_SYSTEM_EXCEPTION,
  PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_USER_EXCEPTION
};

/* reads a user_store_get_public_user_info_result object */
static gint32
user_store_get_public_user_info_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetPublicUserInfoResult * this_object = USER_STORE_GET_PUBLIC_USER_INFO_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_public_user_info_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetPublicUserInfoResult * this_object = USER_STORE_GET_PUBLIC_USER_INFO_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetPublicUserInfoResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_public_user_info_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  UserStoreGetPublicUserInfoResult *self = USER_STORE_GET_PUBLIC_USER_INFO_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_public_user_info_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  UserStoreGetPublicUserInfoResult *self = USER_STORE_GET_PUBLIC_USER_INFO_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_public_user_info_result_instance_init (UserStoreGetPublicUserInfoResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PUBLIC_USER_INFO, NULL);
  object->__isset_success = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
}

static void 
user_store_get_public_user_info_result_finalize (GObject *object)
{
  UserStoreGetPublicUserInfoResult *tobject = USER_STORE_GET_PUBLIC_USER_INFO_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
}

static void
user_store_get_public_user_info_result_class_init (UserStoreGetPublicUserInfoResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_public_user_info_result_read;
  struct_class->write = user_store_get_public_user_info_result_write;

  gobject_class->finalize = user_store_get_public_user_info_result_finalize;
  gobject_class->get_property = user_store_get_public_user_info_result_get_property;
  gobject_class->set_property = user_store_get_public_user_info_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PUBLIC_USER_INFO,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_PUBLIC_USER_INFO_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_get_public_user_info_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetPublicUserInfoResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_public_user_info_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetPublicUserInfoResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_public_user_info_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetPublicUserInfoResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetUserUrlsArgsProperties
{
  PROP_USER_STORE_GET_USER_URLS_ARGS_0,
  PROP_USER_STORE_GET_USER_URLS_ARGS_AUTHENTICATION_TOKEN
};

/* reads a user_store_get_user_urls_args object */
static gint32
user_store_get_user_urls_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetUserUrlsArgs * this_object = USER_STORE_GET_USER_URLS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_user_urls_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetUserUrlsArgs * this_object = USER_STORE_GET_USER_URLS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetUserUrlsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_user_urls_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  UserStoreGetUserUrlsArgs *self = USER_STORE_GET_USER_URLS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_USER_URLS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_user_urls_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  UserStoreGetUserUrlsArgs *self = USER_STORE_GET_USER_URLS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_USER_URLS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_user_urls_args_instance_init (UserStoreGetUserUrlsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
user_store_get_user_urls_args_finalize (GObject *object)
{
  UserStoreGetUserUrlsArgs *tobject = USER_STORE_GET_USER_URLS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
user_store_get_user_urls_args_class_init (UserStoreGetUserUrlsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_user_urls_args_read;
  struct_class->write = user_store_get_user_urls_args_write;

  gobject_class->finalize = user_store_get_user_urls_args_finalize;
  gobject_class->get_property = user_store_get_user_urls_args_get_property;
  gobject_class->set_property = user_store_get_user_urls_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_USER_URLS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_get_user_urls_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetUserUrlsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_user_urls_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetUserUrlsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_user_urls_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetUserUrlsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetUserUrlsResultProperties
{
  PROP_USER_STORE_GET_USER_URLS_RESULT_0,
  PROP_USER_STORE_GET_USER_URLS_RESULT_SUCCESS,
  PROP_USER_STORE_GET_USER_URLS_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_GET_USER_URLS_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_get_user_urls_result object */
static gint32
user_store_get_user_urls_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetUserUrlsResult * this_object = USER_STORE_GET_USER_URLS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_user_urls_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetUserUrlsResult * this_object = USER_STORE_GET_USER_URLS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetUserUrlsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_user_urls_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  UserStoreGetUserUrlsResult *self = USER_STORE_GET_USER_URLS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_USER_URLS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_GET_USER_URLS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_GET_USER_URLS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_user_urls_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  UserStoreGetUserUrlsResult *self = USER_STORE_GET_USER_URLS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_USER_URLS_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_USER_STORE_GET_USER_URLS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_GET_USER_URLS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_user_urls_result_instance_init (UserStoreGetUserUrlsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_USER_URLS, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_get_user_urls_result_finalize (GObject *object)
{
  UserStoreGetUserUrlsResult *tobject = USER_STORE_GET_USER_URLS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_get_user_urls_result_class_init (UserStoreGetUserUrlsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_user_urls_result_read;
  struct_class->write = user_store_get_user_urls_result_write;

  gobject_class->finalize = user_store_get_user_urls_result_finalize;
  gobject_class->get_property = user_store_get_user_urls_result_get_property;
  gobject_class->set_property = user_store_get_user_urls_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_USER_URLS_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_USER_URLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_USER_URLS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_USER_URLS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_get_user_urls_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetUserUrlsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_user_urls_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetUserUrlsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_user_urls_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetUserUrlsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreInviteToBusinessArgsProperties
{
  PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_0,
  PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_AUTHENTICATION_TOKEN,
  PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_EMAIL_ADDRESS
};

/* reads a user_store_invite_to_business_args object */
static gint32
user_store_invite_to_business_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreInviteToBusinessArgs * this_object = USER_STORE_INVITE_TO_BUSINESS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->emailAddress != NULL)
          {
            g_free(this_object->emailAddress);
            this_object->emailAddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->emailAddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_emailAddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_invite_to_business_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreInviteToBusinessArgs * this_object = USER_STORE_INVITE_TO_BUSINESS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreInviteToBusinessArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "emailAddress", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->emailAddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_invite_to_business_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  UserStoreInviteToBusinessArgs *self = USER_STORE_INVITE_TO_BUSINESS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_EMAIL_ADDRESS:
      if (self->emailAddress != NULL)
        g_free (self->emailAddress);
      self->emailAddress = g_value_dup_string (value);
      self->__isset_emailAddress = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_invite_to_business_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  UserStoreInviteToBusinessArgs *self = USER_STORE_INVITE_TO_BUSINESS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_EMAIL_ADDRESS:
      g_value_set_string (value, self->emailAddress);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_invite_to_business_args_instance_init (UserStoreInviteToBusinessArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->emailAddress = NULL;
  object->__isset_emailAddress = FALSE;
}

static void 
user_store_invite_to_business_args_finalize (GObject *object)
{
  UserStoreInviteToBusinessArgs *tobject = USER_STORE_INVITE_TO_BUSINESS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->emailAddress != NULL)
  {
    g_free(tobject->emailAddress);
    tobject->emailAddress = NULL;
  }
}

static void
user_store_invite_to_business_args_class_init (UserStoreInviteToBusinessArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_invite_to_business_args_read;
  struct_class->write = user_store_invite_to_business_args_write;

  gobject_class->finalize = user_store_invite_to_business_args_finalize;
  gobject_class->get_property = user_store_invite_to_business_args_get_property;
  gobject_class->set_property = user_store_invite_to_business_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_INVITE_TO_BUSINESS_ARGS_EMAIL_ADDRESS,
     g_param_spec_string ("emailAddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_invite_to_business_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreInviteToBusinessArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_invite_to_business_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreInviteToBusinessArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_invite_to_business_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreInviteToBusinessArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreInviteToBusinessResultProperties
{
  PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_0,
  PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_invite_to_business_result object */
static gint32
user_store_invite_to_business_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreInviteToBusinessResult * this_object = USER_STORE_INVITE_TO_BUSINESS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_invite_to_business_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreInviteToBusinessResult * this_object = USER_STORE_INVITE_TO_BUSINESS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreInviteToBusinessResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_invite_to_business_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreInviteToBusinessResult *self = USER_STORE_INVITE_TO_BUSINESS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_invite_to_business_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreInviteToBusinessResult *self = USER_STORE_INVITE_TO_BUSINESS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_invite_to_business_result_instance_init (UserStoreInviteToBusinessResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_invite_to_business_result_finalize (GObject *object)
{
  UserStoreInviteToBusinessResult *tobject = USER_STORE_INVITE_TO_BUSINESS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_invite_to_business_result_class_init (UserStoreInviteToBusinessResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_invite_to_business_result_read;
  struct_class->write = user_store_invite_to_business_result_write;

  gobject_class->finalize = user_store_invite_to_business_result_finalize;
  gobject_class->get_property = user_store_invite_to_business_result_get_property;
  gobject_class->set_property = user_store_invite_to_business_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_INVITE_TO_BUSINESS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_invite_to_business_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreInviteToBusinessResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_invite_to_business_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreInviteToBusinessResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_invite_to_business_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreInviteToBusinessResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreRemoveFromBusinessArgsProperties
{
  PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_0,
  PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_AUTHENTICATION_TOKEN,
  PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_EMAIL_ADDRESS
};

/* reads a user_store_remove_from_business_args object */
static gint32
user_store_remove_from_business_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreRemoveFromBusinessArgs * this_object = USER_STORE_REMOVE_FROM_BUSINESS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->emailAddress != NULL)
          {
            g_free(this_object->emailAddress);
            this_object->emailAddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->emailAddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_emailAddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_remove_from_business_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreRemoveFromBusinessArgs * this_object = USER_STORE_REMOVE_FROM_BUSINESS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreRemoveFromBusinessArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "emailAddress", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->emailAddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_remove_from_business_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreRemoveFromBusinessArgs *self = USER_STORE_REMOVE_FROM_BUSINESS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_EMAIL_ADDRESS:
      if (self->emailAddress != NULL)
        g_free (self->emailAddress);
      self->emailAddress = g_value_dup_string (value);
      self->__isset_emailAddress = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_remove_from_business_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreRemoveFromBusinessArgs *self = USER_STORE_REMOVE_FROM_BUSINESS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_EMAIL_ADDRESS:
      g_value_set_string (value, self->emailAddress);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_remove_from_business_args_instance_init (UserStoreRemoveFromBusinessArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->emailAddress = NULL;
  object->__isset_emailAddress = FALSE;
}

static void 
user_store_remove_from_business_args_finalize (GObject *object)
{
  UserStoreRemoveFromBusinessArgs *tobject = USER_STORE_REMOVE_FROM_BUSINESS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->emailAddress != NULL)
  {
    g_free(tobject->emailAddress);
    tobject->emailAddress = NULL;
  }
}

static void
user_store_remove_from_business_args_class_init (UserStoreRemoveFromBusinessArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_remove_from_business_args_read;
  struct_class->write = user_store_remove_from_business_args_write;

  gobject_class->finalize = user_store_remove_from_business_args_finalize;
  gobject_class->get_property = user_store_remove_from_business_args_get_property;
  gobject_class->set_property = user_store_remove_from_business_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_REMOVE_FROM_BUSINESS_ARGS_EMAIL_ADDRESS,
     g_param_spec_string ("emailAddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_remove_from_business_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreRemoveFromBusinessArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_remove_from_business_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreRemoveFromBusinessArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_remove_from_business_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreRemoveFromBusinessArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreRemoveFromBusinessResultProperties
{
  PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_0,
  PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_SYSTEM_EXCEPTION,
  PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a user_store_remove_from_business_result object */
static gint32
user_store_remove_from_business_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreRemoveFromBusinessResult * this_object = USER_STORE_REMOVE_FROM_BUSINESS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_remove_from_business_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreRemoveFromBusinessResult * this_object = USER_STORE_REMOVE_FROM_BUSINESS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreRemoveFromBusinessResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_remove_from_business_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  UserStoreRemoveFromBusinessResult *self = USER_STORE_REMOVE_FROM_BUSINESS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_remove_from_business_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  UserStoreRemoveFromBusinessResult *self = USER_STORE_REMOVE_FROM_BUSINESS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_remove_from_business_result_instance_init (UserStoreRemoveFromBusinessResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
user_store_remove_from_business_result_finalize (GObject *object)
{
  UserStoreRemoveFromBusinessResult *tobject = USER_STORE_REMOVE_FROM_BUSINESS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
user_store_remove_from_business_result_class_init (UserStoreRemoveFromBusinessResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_remove_from_business_result_read;
  struct_class->write = user_store_remove_from_business_result_write;

  gobject_class->finalize = user_store_remove_from_business_result_finalize;
  gobject_class->get_property = user_store_remove_from_business_result_get_property;
  gobject_class->set_property = user_store_remove_from_business_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_REMOVE_FROM_BUSINESS_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_remove_from_business_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreRemoveFromBusinessResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_remove_from_business_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreRemoveFromBusinessResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_remove_from_business_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreRemoveFromBusinessResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreUpdateBusinessUserIdentifierArgsProperties
{
  PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_0,
  PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_AUTHENTICATION_TOKEN,
  PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_OLD_EMAIL_ADDRESS,
  PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_NEW_EMAIL_ADDRESS
};

/* reads a user_store_update_business_user_identifier_args object */
static gint32
user_store_update_business_user_identifier_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreUpdateBusinessUserIdentifierArgs * this_object = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->oldEmailAddress != NULL)
          {
            g_free(this_object->oldEmailAddress);
            this_object->oldEmailAddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->oldEmailAddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_oldEmailAddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->newEmailAddress != NULL)
          {
            g_free(this_object->newEmailAddress);
            this_object->newEmailAddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->newEmailAddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_newEmailAddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_update_business_user_identifier_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreUpdateBusinessUserIdentifierArgs * this_object = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreUpdateBusinessUserIdentifierArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "oldEmailAddress", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->oldEmailAddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newEmailAddress", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->newEmailAddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_update_business_user_identifier_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  UserStoreUpdateBusinessUserIdentifierArgs *self = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_OLD_EMAIL_ADDRESS:
      if (self->oldEmailAddress != NULL)
        g_free (self->oldEmailAddress);
      self->oldEmailAddress = g_value_dup_string (value);
      self->__isset_oldEmailAddress = TRUE;
      break;

    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_NEW_EMAIL_ADDRESS:
      if (self->newEmailAddress != NULL)
        g_free (self->newEmailAddress);
      self->newEmailAddress = g_value_dup_string (value);
      self->__isset_newEmailAddress = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_update_business_user_identifier_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  UserStoreUpdateBusinessUserIdentifierArgs *self = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_OLD_EMAIL_ADDRESS:
      g_value_set_string (value, self->oldEmailAddress);
      break;

    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_NEW_EMAIL_ADDRESS:
      g_value_set_string (value, self->newEmailAddress);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_update_business_user_identifier_args_instance_init (UserStoreUpdateBusinessUserIdentifierArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->oldEmailAddress = NULL;
  object->__isset_oldEmailAddress = FALSE;
  object->newEmailAddress = NULL;
  object->__isset_newEmailAddress = FALSE;
}

static void 
user_store_update_business_user_identifier_args_finalize (GObject *object)
{
  UserStoreUpdateBusinessUserIdentifierArgs *tobject = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->oldEmailAddress != NULL)
  {
    g_free(tobject->oldEmailAddress);
    tobject->oldEmailAddress = NULL;
  }
  if (tobject->newEmailAddress != NULL)
  {
    g_free(tobject->newEmailAddress);
    tobject->newEmailAddress = NULL;
  }
}

static void
user_store_update_business_user_identifier_args_class_init (UserStoreUpdateBusinessUserIdentifierArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_update_business_user_identifier_args_read;
  struct_class->write = user_store_update_business_user_identifier_args_write;

  gobject_class->finalize = user_store_update_business_user_identifier_args_finalize;
  gobject_class->get_property = user_store_update_business_user_identifier_args_get_property;
  gobject_class->set_property = user_store_update_business_user_identifier_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_OLD_EMAIL_ADDRESS,
     g_param_spec_string ("oldEmailAddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_ARGS_NEW_EMAIL_ADDRESS,
     g_param_spec_string ("newEmailAddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_update_business_user_identifier_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreUpdateBusinessUserIdentifierArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_update_business_user_identifier_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreUpdateBusinessUserIdentifierArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_update_business_user_identifier_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreUpdateBusinessUserIdentifierArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreUpdateBusinessUserIdentifierResultProperties
{
  PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_0,
  PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_SYSTEM_EXCEPTION,
  PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a user_store_update_business_user_identifier_result object */
static gint32
user_store_update_business_user_identifier_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreUpdateBusinessUserIdentifierResult * this_object = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_update_business_user_identifier_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreUpdateBusinessUserIdentifierResult * this_object = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreUpdateBusinessUserIdentifierResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_update_business_user_identifier_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  UserStoreUpdateBusinessUserIdentifierResult *self = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_update_business_user_identifier_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  UserStoreUpdateBusinessUserIdentifierResult *self = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_update_business_user_identifier_result_instance_init (UserStoreUpdateBusinessUserIdentifierResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
user_store_update_business_user_identifier_result_finalize (GObject *object)
{
  UserStoreUpdateBusinessUserIdentifierResult *tobject = USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
user_store_update_business_user_identifier_result_class_init (UserStoreUpdateBusinessUserIdentifierResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_update_business_user_identifier_result_read;
  struct_class->write = user_store_update_business_user_identifier_result_write;

  gobject_class->finalize = user_store_update_business_user_identifier_result_finalize;
  gobject_class->get_property = user_store_update_business_user_identifier_result_get_property;
  gobject_class->set_property = user_store_update_business_user_identifier_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_UPDATE_BUSINESS_USER_IDENTIFIER_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_update_business_user_identifier_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreUpdateBusinessUserIdentifierResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_update_business_user_identifier_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreUpdateBusinessUserIdentifierResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_update_business_user_identifier_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreUpdateBusinessUserIdentifierResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreListBusinessUsersArgsProperties
{
  PROP_USER_STORE_LIST_BUSINESS_USERS_ARGS_0,
  PROP_USER_STORE_LIST_BUSINESS_USERS_ARGS_AUTHENTICATION_TOKEN
};

/* reads a user_store_list_business_users_args object */
static gint32
user_store_list_business_users_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreListBusinessUsersArgs * this_object = USER_STORE_LIST_BUSINESS_USERS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_list_business_users_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreListBusinessUsersArgs * this_object = USER_STORE_LIST_BUSINESS_USERS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreListBusinessUsersArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_list_business_users_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  UserStoreListBusinessUsersArgs *self = USER_STORE_LIST_BUSINESS_USERS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_LIST_BUSINESS_USERS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_list_business_users_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  UserStoreListBusinessUsersArgs *self = USER_STORE_LIST_BUSINESS_USERS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_LIST_BUSINESS_USERS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_list_business_users_args_instance_init (UserStoreListBusinessUsersArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
user_store_list_business_users_args_finalize (GObject *object)
{
  UserStoreListBusinessUsersArgs *tobject = USER_STORE_LIST_BUSINESS_USERS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
user_store_list_business_users_args_class_init (UserStoreListBusinessUsersArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_list_business_users_args_read;
  struct_class->write = user_store_list_business_users_args_write;

  gobject_class->finalize = user_store_list_business_users_args_finalize;
  gobject_class->get_property = user_store_list_business_users_args_get_property;
  gobject_class->set_property = user_store_list_business_users_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_USERS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
user_store_list_business_users_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreListBusinessUsersArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_list_business_users_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreListBusinessUsersArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_list_business_users_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreListBusinessUsersArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreListBusinessUsersResultProperties
{
  PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_0,
  PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_SUCCESS,
  PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_list_business_users_result object */
static gint32
user_store_list_business_users_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreListBusinessUsersResult * this_object = USER_STORE_LIST_BUSINESS_USERS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              UserProfile * _elem3 = NULL;
              if ( _elem3 != NULL)
              {
                g_object_unref (_elem3);
              }
              _elem3 = g_object_new (TYPE_USER_PROFILE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem3), protocol, error)) < 0)
              {
                g_object_unref (_elem3);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_list_business_users_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreListBusinessUsersResult * this_object = USER_STORE_LIST_BUSINESS_USERS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreListBusinessUsersResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i4;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i4 = 0; i4 < (this_object->success ? this_object->success->len : 0); i4++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i4))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_list_business_users_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  UserStoreListBusinessUsersResult *self = USER_STORE_LIST_BUSINESS_USERS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_list_business_users_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  UserStoreListBusinessUsersResult *self = USER_STORE_LIST_BUSINESS_USERS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_list_business_users_result_instance_init (UserStoreListBusinessUsersResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_list_business_users_result_finalize (GObject *object)
{
  UserStoreListBusinessUsersResult *tobject = USER_STORE_LIST_BUSINESS_USERS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_list_business_users_result_class_init (UserStoreListBusinessUsersResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_list_business_users_result_read;
  struct_class->write = user_store_list_business_users_result_write;

  gobject_class->finalize = user_store_list_business_users_result_finalize;
  gobject_class->get_property = user_store_list_business_users_result_get_property;
  gobject_class->set_property = user_store_list_business_users_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_USERS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_list_business_users_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreListBusinessUsersResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_list_business_users_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreListBusinessUsersResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_list_business_users_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreListBusinessUsersResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreListBusinessInvitationsArgsProperties
{
  PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_0,
  PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_AUTHENTICATION_TOKEN,
  PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_INCLUDE_REQUESTED_INVITATIONS
};

/* reads a user_store_list_business_invitations_args object */
static gint32
user_store_list_business_invitations_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreListBusinessInvitationsArgs * this_object = USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeRequestedInvitations, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeRequestedInvitations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_list_business_invitations_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreListBusinessInvitationsArgs * this_object = USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreListBusinessInvitationsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "includeRequestedInvitations", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->includeRequestedInvitations, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_list_business_invitations_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  UserStoreListBusinessInvitationsArgs *self = USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_INCLUDE_REQUESTED_INVITATIONS:
      self->includeRequestedInvitations = g_value_get_boolean (value);
      self->__isset_includeRequestedInvitations = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_list_business_invitations_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  UserStoreListBusinessInvitationsArgs *self = USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_INCLUDE_REQUESTED_INVITATIONS:
      g_value_set_boolean (value, self->includeRequestedInvitations);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_list_business_invitations_args_instance_init (UserStoreListBusinessInvitationsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->includeRequestedInvitations = 0;
  object->__isset_includeRequestedInvitations = FALSE;
}

static void 
user_store_list_business_invitations_args_finalize (GObject *object)
{
  UserStoreListBusinessInvitationsArgs *tobject = USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
user_store_list_business_invitations_args_class_init (UserStoreListBusinessInvitationsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_list_business_invitations_args_read;
  struct_class->write = user_store_list_business_invitations_args_write;

  gobject_class->finalize = user_store_list_business_invitations_args_finalize;
  gobject_class->get_property = user_store_list_business_invitations_args_get_property;
  gobject_class->set_property = user_store_list_business_invitations_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_ARGS_INCLUDE_REQUESTED_INVITATIONS,
     g_param_spec_boolean ("includeRequestedInvitations",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
user_store_list_business_invitations_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreListBusinessInvitationsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_list_business_invitations_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreListBusinessInvitationsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_list_business_invitations_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreListBusinessInvitationsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreListBusinessInvitationsResultProperties
{
  PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_0,
  PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_SUCCESS,
  PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_USER_EXCEPTION,
  PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_SYSTEM_EXCEPTION
};

/* reads a user_store_list_business_invitations_result object */
static gint32
user_store_list_business_invitations_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreListBusinessInvitationsResult * this_object = USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              BusinessInvitation * _elem5 = NULL;
              if ( _elem5 != NULL)
              {
                g_object_unref (_elem5);
              }
              _elem5 = g_object_new (TYPE_BUSINESS_INVITATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem5), protocol, error)) < 0)
              {
                g_object_unref (_elem5);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem5);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_list_business_invitations_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreListBusinessInvitationsResult * this_object = USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreListBusinessInvitationsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i6;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i6 = 0; i6 < (this_object->success ? this_object->success->len : 0); i6++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i6))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_list_business_invitations_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  UserStoreListBusinessInvitationsResult *self = USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_list_business_invitations_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  UserStoreListBusinessInvitationsResult *self = USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_list_business_invitations_result_instance_init (UserStoreListBusinessInvitationsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
user_store_list_business_invitations_result_finalize (GObject *object)
{
  UserStoreListBusinessInvitationsResult *tobject = USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
user_store_list_business_invitations_result_class_init (UserStoreListBusinessInvitationsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_list_business_invitations_result_read;
  struct_class->write = user_store_list_business_invitations_result_write;

  gobject_class->finalize = user_store_list_business_invitations_result_finalize;
  gobject_class->get_property = user_store_list_business_invitations_result_get_property;
  gobject_class->set_property = user_store_list_business_invitations_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_LIST_BUSINESS_INVITATIONS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_list_business_invitations_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreListBusinessInvitationsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_list_business_invitations_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreListBusinessInvitationsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_list_business_invitations_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreListBusinessInvitationsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetAccountLimitsArgsProperties
{
  PROP_USER_STORE_GET_ACCOUNT_LIMITS_ARGS_0,
  PROP_USER_STORE_GET_ACCOUNT_LIMITS_ARGS_SERVICE_LEVEL
};

/* reads a user_store_get_account_limits_args object */
static gint32
user_store_get_account_limits_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetAccountLimitsArgs * this_object = USER_STORE_GET_ACCOUNT_LIMITS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->serviceLevel = (ServiceLevel)ecast7;
          this_object->__isset_serviceLevel = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_account_limits_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetAccountLimitsArgs * this_object = USER_STORE_GET_ACCOUNT_LIMITS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetAccountLimitsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serviceLevel", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->serviceLevel, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_account_limits_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  UserStoreGetAccountLimitsArgs *self = USER_STORE_GET_ACCOUNT_LIMITS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_ACCOUNT_LIMITS_ARGS_SERVICE_LEVEL:
      self->serviceLevel = g_value_get_int (value);
      self->__isset_serviceLevel = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_account_limits_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  UserStoreGetAccountLimitsArgs *self = USER_STORE_GET_ACCOUNT_LIMITS_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_ACCOUNT_LIMITS_ARGS_SERVICE_LEVEL:
      g_value_set_int (value, self->serviceLevel);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_account_limits_args_instance_init (UserStoreGetAccountLimitsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_serviceLevel = FALSE;
}

static void 
user_store_get_account_limits_args_finalize (GObject *object)
{
  UserStoreGetAccountLimitsArgs *tobject = USER_STORE_GET_ACCOUNT_LIMITS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
user_store_get_account_limits_args_class_init (UserStoreGetAccountLimitsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_account_limits_args_read;
  struct_class->write = user_store_get_account_limits_args_write;

  gobject_class->finalize = user_store_get_account_limits_args_finalize;
  gobject_class->get_property = user_store_get_account_limits_args_get_property;
  gobject_class->set_property = user_store_get_account_limits_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_ACCOUNT_LIMITS_ARGS_SERVICE_LEVEL,
     g_param_spec_int ("serviceLevel",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));
}

GType
user_store_get_account_limits_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetAccountLimitsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_account_limits_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetAccountLimitsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_account_limits_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetAccountLimitsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _UserStoreGetAccountLimitsResultProperties
{
  PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_0,
  PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_SUCCESS,
  PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_USER_EXCEPTION
};

/* reads a user_store_get_account_limits_result object */
static gint32
user_store_get_account_limits_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UserStoreGetAccountLimitsResult * this_object = USER_STORE_GET_ACCOUNT_LIMITS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_store_get_account_limits_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UserStoreGetAccountLimitsResult * this_object = USER_STORE_GET_ACCOUNT_LIMITS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserStoreGetAccountLimitsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_store_get_account_limits_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreGetAccountLimitsResult *self = USER_STORE_GET_ACCOUNT_LIMITS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_store_get_account_limits_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  UserStoreGetAccountLimitsResult *self = USER_STORE_GET_ACCOUNT_LIMITS_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_store_get_account_limits_result_instance_init (UserStoreGetAccountLimitsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_ACCOUNT_LIMITS, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
}

static void 
user_store_get_account_limits_result_finalize (GObject *object)
{
  UserStoreGetAccountLimitsResult *tobject = USER_STORE_GET_ACCOUNT_LIMITS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
}

static void
user_store_get_account_limits_result_class_init (UserStoreGetAccountLimitsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_store_get_account_limits_result_read;
  struct_class->write = user_store_get_account_limits_result_write;

  gobject_class->finalize = user_store_get_account_limits_result_finalize;
  gobject_class->get_property = user_store_get_account_limits_result_get_property;
  gobject_class->set_property = user_store_get_account_limits_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_ACCOUNT_LIMITS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_STORE_GET_ACCOUNT_LIMITS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
user_store_get_account_limits_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UserStoreGetAccountLimitsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_store_get_account_limits_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UserStoreGetAccountLimitsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_store_get_account_limits_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UserStoreGetAccountLimitsResultType",
                                   &type_info, 0);
  }

  return type;
}

