/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "note_store_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_ShareRelationshipPrivilegeLevel(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SHARE_RELATIONSHIP_PRIVILEGE_LEVEL_READ_NOTEBOOK:return "SHARE_RELATIONSHIP_PRIVILEGE_LEVEL_READ_NOTEBOOK";
  case SHARE_RELATIONSHIP_PRIVILEGE_LEVEL_READ_NOTEBOOK_PLUS_ACTIVITY:return "SHARE_RELATIONSHIP_PRIVILEGE_LEVEL_READ_NOTEBOOK_PLUS_ACTIVITY";
  case SHARE_RELATIONSHIP_PRIVILEGE_LEVEL_MODIFY_NOTEBOOK_PLUS_ACTIVITY:return "SHARE_RELATIONSHIP_PRIVILEGE_LEVEL_MODIFY_NOTEBOOK_PLUS_ACTIVITY";
  case SHARE_RELATIONSHIP_PRIVILEGE_LEVEL_FULL_ACCESS:return "SHARE_RELATIONSHIP_PRIVILEGE_LEVEL_FULL_ACCESS";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _SyncStateProperties
{
  PROP_SYNC_STATE_0,
  PROP_SYNC_STATE_CURRENT_TIME,
  PROP_SYNC_STATE_FULL_SYNC_BEFORE,
  PROP_SYNC_STATE_UPDATE_COUNT,
  PROP_SYNC_STATE_UPLOADED,
  PROP_SYNC_STATE_USER_LAST_UPDATED,
  PROP_SYNC_STATE_USER_MAX_MESSAGE_EVENT_ID
};

/* reads a sync_state object */
static gint32
sync_state_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SyncState * this_object = SYNC_STATE(object);
  gboolean isset_currentTime = FALSE;
  gboolean isset_fullSyncBefore = FALSE;
  gboolean isset_updateCount = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->currentTime, error)) < 0)
            return -1;
          xfer += ret;
          isset_currentTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->fullSyncBefore, error)) < 0)
            return -1;
          xfer += ret;
          isset_fullSyncBefore = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->updateCount, error)) < 0)
            return -1;
          xfer += ret;
          isset_updateCount = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->uploaded, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_uploaded = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->userLastUpdated, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_userLastUpdated = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->userMaxMessageEventId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_userMaxMessageEventId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_currentTime)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_fullSyncBefore)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_updateCount)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
sync_state_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SyncState * this_object = SYNC_STATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SyncState", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "currentTime", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->currentTime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fullSyncBefore", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->fullSyncBefore, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updateCount", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->updateCount, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_uploaded == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "uploaded", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->uploaded, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userLastUpdated == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userLastUpdated", T_I64, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->userLastUpdated, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userMaxMessageEventId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userMaxMessageEventId", T_I64, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->userMaxMessageEventId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sync_state_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  SyncState *self = SYNC_STATE (object);

  switch (property_id)
  {
    case PROP_SYNC_STATE_CURRENT_TIME:
      self->currentTime = g_value_get_int64 (value);
      break;

    case PROP_SYNC_STATE_FULL_SYNC_BEFORE:
      self->fullSyncBefore = g_value_get_int64 (value);
      break;

    case PROP_SYNC_STATE_UPDATE_COUNT:
      self->updateCount = g_value_get_int (value);
      break;

    case PROP_SYNC_STATE_UPLOADED:
      self->uploaded = g_value_get_int64 (value);
      self->__isset_uploaded = TRUE;
      break;

    case PROP_SYNC_STATE_USER_LAST_UPDATED:
      self->userLastUpdated = g_value_get_int64 (value);
      self->__isset_userLastUpdated = TRUE;
      break;

    case PROP_SYNC_STATE_USER_MAX_MESSAGE_EVENT_ID:
      self->userMaxMessageEventId = g_value_get_int64 (value);
      self->__isset_userMaxMessageEventId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sync_state_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  SyncState *self = SYNC_STATE (object);

  switch (property_id)
  {
    case PROP_SYNC_STATE_CURRENT_TIME:
      g_value_set_int64 (value, self->currentTime);
      break;

    case PROP_SYNC_STATE_FULL_SYNC_BEFORE:
      g_value_set_int64 (value, self->fullSyncBefore);
      break;

    case PROP_SYNC_STATE_UPDATE_COUNT:
      g_value_set_int (value, self->updateCount);
      break;

    case PROP_SYNC_STATE_UPLOADED:
      g_value_set_int64 (value, self->uploaded);
      break;

    case PROP_SYNC_STATE_USER_LAST_UPDATED:
      g_value_set_int64 (value, self->userLastUpdated);
      break;

    case PROP_SYNC_STATE_USER_MAX_MESSAGE_EVENT_ID:
      g_value_set_int64 (value, self->userMaxMessageEventId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sync_state_instance_init (SyncState * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->currentTime = 0;
  object->fullSyncBefore = 0;
  object->updateCount = 0;
  object->uploaded = 0;
  object->__isset_uploaded = FALSE;
  object->userLastUpdated = 0;
  object->__isset_userLastUpdated = FALSE;
  object->userMaxMessageEventId = 0;
  object->__isset_userMaxMessageEventId = FALSE;
}

static void 
sync_state_finalize (GObject *object)
{
  SyncState *tobject = SYNC_STATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
sync_state_class_init (SyncStateClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sync_state_read;
  struct_class->write = sync_state_write;

  gobject_class->finalize = sync_state_finalize;
  gobject_class->get_property = sync_state_get_property;
  gobject_class->set_property = sync_state_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_STATE_CURRENT_TIME,
     g_param_spec_int64 ("currentTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_STATE_FULL_SYNC_BEFORE,
     g_param_spec_int64 ("fullSyncBefore",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_STATE_UPDATE_COUNT,
     g_param_spec_int ("updateCount",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_STATE_UPLOADED,
     g_param_spec_int64 ("uploaded",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_STATE_USER_LAST_UPDATED,
     g_param_spec_int64 ("userLastUpdated",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_STATE_USER_MAX_MESSAGE_EVENT_ID,
     g_param_spec_int64 ("userMaxMessageEventId",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
sync_state_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SyncStateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sync_state_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SyncState),
      0, /* n_preallocs */
      (GInstanceInitFunc) sync_state_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SyncStateType",
                                   &type_info, 0);
  }

  return type;
}

enum _SyncChunkProperties
{
  PROP_SYNC_CHUNK_0,
  PROP_SYNC_CHUNK_CURRENT_TIME,
  PROP_SYNC_CHUNK_CHUNK_HIGH_U_S_N,
  PROP_SYNC_CHUNK_UPDATE_COUNT,
  PROP_SYNC_CHUNK_NOTES,
  PROP_SYNC_CHUNK_NOTEBOOKS,
  PROP_SYNC_CHUNK_TAGS,
  PROP_SYNC_CHUNK_SEARCHES,
  PROP_SYNC_CHUNK_RESOURCES,
  PROP_SYNC_CHUNK_EXPUNGED_NOTES,
  PROP_SYNC_CHUNK_EXPUNGED_NOTEBOOKS,
  PROP_SYNC_CHUNK_EXPUNGED_TAGS,
  PROP_SYNC_CHUNK_EXPUNGED_SEARCHES,
  PROP_SYNC_CHUNK_LINKED_NOTEBOOKS,
  PROP_SYNC_CHUNK_EXPUNGED_LINKED_NOTEBOOKS
};

/* reads a sync_chunk object */
static gint32
sync_chunk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SyncChunk * this_object = SYNC_CHUNK(object);
  gboolean isset_currentTime = FALSE;
  gboolean isset_updateCount = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->currentTime, error)) < 0)
            return -1;
          xfer += ret;
          isset_currentTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->chunkHighUSN, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_chunkHighUSN = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->updateCount, error)) < 0)
            return -1;
          xfer += ret;
          isset_updateCount = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Note * _elem0 = NULL;
              if ( _elem0 != NULL)
              {
                g_object_unref (_elem0);
              }
              _elem0 = g_object_new (TYPE_NOTE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem0), protocol, error)) < 0)
              {
                g_object_unref (_elem0);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->notes, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_notes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Notebook * _elem1 = NULL;
              if ( _elem1 != NULL)
              {
                g_object_unref (_elem1);
              }
              _elem1 = g_object_new (TYPE_NOTEBOOK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1), protocol, error)) < 0)
              {
                g_object_unref (_elem1);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->notebooks, _elem1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_notebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Tag * _elem2 = NULL;
              if ( _elem2 != NULL)
              {
                g_object_unref (_elem2);
              }
              _elem2 = g_object_new (TYPE_TAG, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem2), protocol, error)) < 0)
              {
                g_object_unref (_elem2);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->tags, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_tags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              SavedSearch * _elem3 = NULL;
              if ( _elem3 != NULL)
              {
                g_object_unref (_elem3);
              }
              _elem3 = g_object_new (TYPE_SAVED_SEARCH, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem3), protocol, error)) < 0)
              {
                g_object_unref (_elem3);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->searches, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_searches = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Resource * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (TYPE_RESOURCE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->resources, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_resources = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem5 = NULL;
              if (_elem5 != NULL)
              {
                g_free(_elem5);
                _elem5 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem5, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->expungedNotes, _elem5);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_expungedNotes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem6 = NULL;
              if (_elem6 != NULL)
              {
                g_free(_elem6);
                _elem6 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem6, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->expungedNotebooks, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_expungedNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem7 = NULL;
              if (_elem7 != NULL)
              {
                g_free(_elem7);
                _elem7 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem7, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->expungedTags, _elem7);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_expungedTags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem8 = NULL;
              if (_elem8 != NULL)
              {
                g_free(_elem8);
                _elem8 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem8, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->expungedSearches, _elem8);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_expungedSearches = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LinkedNotebook * _elem9 = NULL;
              if ( _elem9 != NULL)
              {
                g_object_unref (_elem9);
              }
              _elem9 = g_object_new (TYPE_LINKED_NOTEBOOK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem9), protocol, error)) < 0)
              {
                g_object_unref (_elem9);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->linkedNotebooks, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_linkedNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem10 = NULL;
              if (_elem10 != NULL)
              {
                g_free(_elem10);
                _elem10 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem10, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->expungedLinkedNotebooks, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_expungedLinkedNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_currentTime)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_updateCount)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
sync_chunk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SyncChunk * this_object = SYNC_CHUNK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SyncChunk", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "currentTime", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->currentTime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_chunkHighUSN == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "chunkHighUSN", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->chunkHighUSN, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "updateCount", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->updateCount, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_notes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notes", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i11;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->notes ? this_object->notes->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i11 = 0; i11 < (this_object->notes ? this_object->notes->len : 0); i11++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->notes, i11))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebooks", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i12;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->notebooks ? this_object->notebooks->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i12 = 0; i12 < (this_object->notebooks ? this_object->notebooks->len : 0); i12++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->notebooks, i12))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_tags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tags", T_LIST, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i13;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->tags ? this_object->tags->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i13 = 0; i13 < (this_object->tags ? this_object->tags->len : 0); i13++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->tags, i13))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_searches == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "searches", T_LIST, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i14;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->searches ? this_object->searches->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i14 = 0; i14 < (this_object->searches ? this_object->searches->len : 0); i14++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->searches, i14))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_resources == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "resources", T_LIST, 8, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i15;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->resources ? this_object->resources->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i15 = 0; i15 < (this_object->resources ? this_object->resources->len : 0); i15++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->resources, i15))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_expungedNotes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "expungedNotes", T_LIST, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i16;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->expungedNotes ? this_object->expungedNotes->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i16 = 0; i16 < (this_object->expungedNotes ? this_object->expungedNotes->len : 0); i16++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->expungedNotes, i16)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_expungedNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "expungedNotebooks", T_LIST, 10, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i17;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->expungedNotebooks ? this_object->expungedNotebooks->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i17 = 0; i17 < (this_object->expungedNotebooks ? this_object->expungedNotebooks->len : 0); i17++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->expungedNotebooks, i17)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_expungedTags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "expungedTags", T_LIST, 11, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i18;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->expungedTags ? this_object->expungedTags->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i18 = 0; i18 < (this_object->expungedTags ? this_object->expungedTags->len : 0); i18++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->expungedTags, i18)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_expungedSearches == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "expungedSearches", T_LIST, 12, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i19;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->expungedSearches ? this_object->expungedSearches->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i19 = 0; i19 < (this_object->expungedSearches ? this_object->expungedSearches->len : 0); i19++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->expungedSearches, i19)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_linkedNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebooks", T_LIST, 13, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i20;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->linkedNotebooks ? this_object->linkedNotebooks->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i20 = 0; i20 < (this_object->linkedNotebooks ? this_object->linkedNotebooks->len : 0); i20++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->linkedNotebooks, i20))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_expungedLinkedNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "expungedLinkedNotebooks", T_LIST, 14, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i21;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->expungedLinkedNotebooks ? this_object->expungedLinkedNotebooks->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i21 = 0; i21 < (this_object->expungedLinkedNotebooks ? this_object->expungedLinkedNotebooks->len : 0); i21++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->expungedLinkedNotebooks, i21)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sync_chunk_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  SyncChunk *self = SYNC_CHUNK (object);

  switch (property_id)
  {
    case PROP_SYNC_CHUNK_CURRENT_TIME:
      self->currentTime = g_value_get_int64 (value);
      break;

    case PROP_SYNC_CHUNK_CHUNK_HIGH_U_S_N:
      self->chunkHighUSN = g_value_get_int (value);
      self->__isset_chunkHighUSN = TRUE;
      break;

    case PROP_SYNC_CHUNK_UPDATE_COUNT:
      self->updateCount = g_value_get_int (value);
      break;

    case PROP_SYNC_CHUNK_NOTES:
      if (self->notes != NULL)
        g_ptr_array_unref (self->notes);
      self->notes = g_value_dup_boxed (value);
      self->__isset_notes = TRUE;
      break;

    case PROP_SYNC_CHUNK_NOTEBOOKS:
      if (self->notebooks != NULL)
        g_ptr_array_unref (self->notebooks);
      self->notebooks = g_value_dup_boxed (value);
      self->__isset_notebooks = TRUE;
      break;

    case PROP_SYNC_CHUNK_TAGS:
      if (self->tags != NULL)
        g_ptr_array_unref (self->tags);
      self->tags = g_value_dup_boxed (value);
      self->__isset_tags = TRUE;
      break;

    case PROP_SYNC_CHUNK_SEARCHES:
      if (self->searches != NULL)
        g_ptr_array_unref (self->searches);
      self->searches = g_value_dup_boxed (value);
      self->__isset_searches = TRUE;
      break;

    case PROP_SYNC_CHUNK_RESOURCES:
      if (self->resources != NULL)
        g_ptr_array_unref (self->resources);
      self->resources = g_value_dup_boxed (value);
      self->__isset_resources = TRUE;
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_NOTES:
      if (self->expungedNotes != NULL)
        g_ptr_array_unref (self->expungedNotes);
      self->expungedNotes = g_value_dup_boxed (value);
      self->__isset_expungedNotes = TRUE;
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_NOTEBOOKS:
      if (self->expungedNotebooks != NULL)
        g_ptr_array_unref (self->expungedNotebooks);
      self->expungedNotebooks = g_value_dup_boxed (value);
      self->__isset_expungedNotebooks = TRUE;
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_TAGS:
      if (self->expungedTags != NULL)
        g_ptr_array_unref (self->expungedTags);
      self->expungedTags = g_value_dup_boxed (value);
      self->__isset_expungedTags = TRUE;
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_SEARCHES:
      if (self->expungedSearches != NULL)
        g_ptr_array_unref (self->expungedSearches);
      self->expungedSearches = g_value_dup_boxed (value);
      self->__isset_expungedSearches = TRUE;
      break;

    case PROP_SYNC_CHUNK_LINKED_NOTEBOOKS:
      if (self->linkedNotebooks != NULL)
        g_ptr_array_unref (self->linkedNotebooks);
      self->linkedNotebooks = g_value_dup_boxed (value);
      self->__isset_linkedNotebooks = TRUE;
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_LINKED_NOTEBOOKS:
      if (self->expungedLinkedNotebooks != NULL)
        g_ptr_array_unref (self->expungedLinkedNotebooks);
      self->expungedLinkedNotebooks = g_value_dup_boxed (value);
      self->__isset_expungedLinkedNotebooks = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sync_chunk_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  SyncChunk *self = SYNC_CHUNK (object);

  switch (property_id)
  {
    case PROP_SYNC_CHUNK_CURRENT_TIME:
      g_value_set_int64 (value, self->currentTime);
      break;

    case PROP_SYNC_CHUNK_CHUNK_HIGH_U_S_N:
      g_value_set_int (value, self->chunkHighUSN);
      break;

    case PROP_SYNC_CHUNK_UPDATE_COUNT:
      g_value_set_int (value, self->updateCount);
      break;

    case PROP_SYNC_CHUNK_NOTES:
      g_value_set_boxed (value, self->notes);
      break;

    case PROP_SYNC_CHUNK_NOTEBOOKS:
      g_value_set_boxed (value, self->notebooks);
      break;

    case PROP_SYNC_CHUNK_TAGS:
      g_value_set_boxed (value, self->tags);
      break;

    case PROP_SYNC_CHUNK_SEARCHES:
      g_value_set_boxed (value, self->searches);
      break;

    case PROP_SYNC_CHUNK_RESOURCES:
      g_value_set_boxed (value, self->resources);
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_NOTES:
      g_value_set_boxed (value, self->expungedNotes);
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_NOTEBOOKS:
      g_value_set_boxed (value, self->expungedNotebooks);
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_TAGS:
      g_value_set_boxed (value, self->expungedTags);
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_SEARCHES:
      g_value_set_boxed (value, self->expungedSearches);
      break;

    case PROP_SYNC_CHUNK_LINKED_NOTEBOOKS:
      g_value_set_boxed (value, self->linkedNotebooks);
      break;

    case PROP_SYNC_CHUNK_EXPUNGED_LINKED_NOTEBOOKS:
      g_value_set_boxed (value, self->expungedLinkedNotebooks);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sync_chunk_instance_init (SyncChunk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->currentTime = 0;
  object->chunkHighUSN = 0;
  object->__isset_chunkHighUSN = FALSE;
  object->updateCount = 0;
  object->notes = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_notes = FALSE;
  object->notebooks = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_notebooks = FALSE;
  object->tags = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_tags = FALSE;
  object->searches = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_searches = FALSE;
  object->resources = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_resources = FALSE;
  object->expungedNotes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_expungedNotes = FALSE;
  object->expungedNotebooks = g_ptr_array_new_with_free_func (g_free);
  object->__isset_expungedNotebooks = FALSE;
  object->expungedTags = g_ptr_array_new_with_free_func (g_free);
  object->__isset_expungedTags = FALSE;
  object->expungedSearches = g_ptr_array_new_with_free_func (g_free);
  object->__isset_expungedSearches = FALSE;
  object->linkedNotebooks = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_linkedNotebooks = FALSE;
  object->expungedLinkedNotebooks = g_ptr_array_new_with_free_func (g_free);
  object->__isset_expungedLinkedNotebooks = FALSE;
}

static void 
sync_chunk_finalize (GObject *object)
{
  SyncChunk *tobject = SYNC_CHUNK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->notes != NULL)
  {
    g_ptr_array_unref (tobject->notes);
    tobject->notes = NULL;
  }
  if (tobject->notebooks != NULL)
  {
    g_ptr_array_unref (tobject->notebooks);
    tobject->notebooks = NULL;
  }
  if (tobject->tags != NULL)
  {
    g_ptr_array_unref (tobject->tags);
    tobject->tags = NULL;
  }
  if (tobject->searches != NULL)
  {
    g_ptr_array_unref (tobject->searches);
    tobject->searches = NULL;
  }
  if (tobject->resources != NULL)
  {
    g_ptr_array_unref (tobject->resources);
    tobject->resources = NULL;
  }
  if (tobject->expungedNotes != NULL)
  {
    g_ptr_array_unref (tobject->expungedNotes);
    tobject->expungedNotes = NULL;
  }
  if (tobject->expungedNotebooks != NULL)
  {
    g_ptr_array_unref (tobject->expungedNotebooks);
    tobject->expungedNotebooks = NULL;
  }
  if (tobject->expungedTags != NULL)
  {
    g_ptr_array_unref (tobject->expungedTags);
    tobject->expungedTags = NULL;
  }
  if (tobject->expungedSearches != NULL)
  {
    g_ptr_array_unref (tobject->expungedSearches);
    tobject->expungedSearches = NULL;
  }
  if (tobject->linkedNotebooks != NULL)
  {
    g_ptr_array_unref (tobject->linkedNotebooks);
    tobject->linkedNotebooks = NULL;
  }
  if (tobject->expungedLinkedNotebooks != NULL)
  {
    g_ptr_array_unref (tobject->expungedLinkedNotebooks);
    tobject->expungedLinkedNotebooks = NULL;
  }
}

static void
sync_chunk_class_init (SyncChunkClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sync_chunk_read;
  struct_class->write = sync_chunk_write;

  gobject_class->finalize = sync_chunk_finalize;
  gobject_class->get_property = sync_chunk_get_property;
  gobject_class->set_property = sync_chunk_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_CURRENT_TIME,
     g_param_spec_int64 ("currentTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_CHUNK_HIGH_U_S_N,
     g_param_spec_int ("chunkHighUSN",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_UPDATE_COUNT,
     g_param_spec_int ("updateCount",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_NOTES,
     g_param_spec_boxed ("notes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_NOTEBOOKS,
     g_param_spec_boxed ("notebooks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_TAGS,
     g_param_spec_boxed ("tags",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_SEARCHES,
     g_param_spec_boxed ("searches",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_RESOURCES,
     g_param_spec_boxed ("resources",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_EXPUNGED_NOTES,
     g_param_spec_boxed ("expungedNotes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_EXPUNGED_NOTEBOOKS,
     g_param_spec_boxed ("expungedNotebooks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_EXPUNGED_TAGS,
     g_param_spec_boxed ("expungedTags",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_EXPUNGED_SEARCHES,
     g_param_spec_boxed ("expungedSearches",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_LINKED_NOTEBOOKS,
     g_param_spec_boxed ("linkedNotebooks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_EXPUNGED_LINKED_NOTEBOOKS,
     g_param_spec_boxed ("expungedLinkedNotebooks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
sync_chunk_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SyncChunkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sync_chunk_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SyncChunk),
      0, /* n_preallocs */
      (GInstanceInitFunc) sync_chunk_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SyncChunkType",
                                   &type_info, 0);
  }

  return type;
}

enum _SyncChunkFilterProperties
{
  PROP_SYNC_CHUNK_FILTER_0,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTES,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_RESOURCES,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_ATTRIBUTES,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTEBOOKS,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_TAGS,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_SEARCHES,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_RESOURCES,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_LINKED_NOTEBOOKS,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_EXPUNGED,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_APPLICATION_DATA_FULL_MAP,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_RESOURCE_APPLICATION_DATA_FULL_MAP,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_RESOURCE_APPLICATION_DATA_FULL_MAP,
  PROP_SYNC_CHUNK_FILTER_INCLUDE_SHARED_NOTES,
  PROP_SYNC_CHUNK_FILTER_OMIT_SHARED_NOTEBOOKS,
  PROP_SYNC_CHUNK_FILTER_REQUIRE_NOTE_CONTENT_CLASS,
  PROP_SYNC_CHUNK_FILTER_NOTEBOOK_GUIDS
};

/* reads a sync_chunk_filter object */
static gint32
sync_chunk_filter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SyncChunkFilter * this_object = SYNC_CHUNK_FILTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeNotes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeNotes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeNoteResources, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeNoteResources = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeNoteAttributes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeNoteAttributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeNotebooks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeTags, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeTags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeSearches, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeSearches = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeResources, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeResources = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeLinkedNotebooks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeLinkedNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeExpunged, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeExpunged = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeNoteApplicationDataFullMap, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeNoteApplicationDataFullMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeResourceApplicationDataFullMap, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeResourceApplicationDataFullMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeNoteResourceApplicationDataFullMap, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeNoteResourceApplicationDataFullMap = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeSharedNotes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeSharedNotes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->omitSharedNotebooks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_omitSharedNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->requireNoteContentClass != NULL)
          {
            g_free(this_object->requireNoteContentClass);
            this_object->requireNoteContentClass = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->requireNoteContentClass, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_requireNoteContentClass = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              gchar * _elem22 = NULL;
              if (_elem22 != NULL)
              {
                g_free(_elem22);
                _elem22 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem22, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->notebookGuids && _elem22)
                g_hash_table_insert ((GHashTable *) this_object->notebookGuids, (gpointer) _elem22, (gpointer) _elem22);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_notebookGuids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sync_chunk_filter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SyncChunkFilter * this_object = SYNC_CHUNK_FILTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SyncChunkFilter", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_includeNotes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeNotes", T_BOOL, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeNotes, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeNoteResources == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeNoteResources", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeNoteResources, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeNoteAttributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeNoteAttributes", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeNoteAttributes, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeNotebooks", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeNotebooks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeTags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeTags", T_BOOL, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeTags, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeSearches == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeSearches", T_BOOL, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeSearches, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeResources == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeResources", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeResources, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeLinkedNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeLinkedNotebooks", T_BOOL, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeLinkedNotebooks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeExpunged == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeExpunged", T_BOOL, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeExpunged, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeNoteApplicationDataFullMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeNoteApplicationDataFullMap", T_BOOL, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeNoteApplicationDataFullMap, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeResourceApplicationDataFullMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeResourceApplicationDataFullMap", T_BOOL, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeResourceApplicationDataFullMap, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeNoteResourceApplicationDataFullMap == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeNoteResourceApplicationDataFullMap", T_BOOL, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeNoteResourceApplicationDataFullMap, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeSharedNotes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeSharedNotes", T_BOOL, 17, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeSharedNotes, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_omitSharedNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "omitSharedNotebooks", T_BOOL, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->omitSharedNotebooks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_requireNoteContentClass == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "requireNoteContentClass", T_STRING, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->requireNoteContentClass, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notebookGuids == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuids", T_SET, 15, error)) < 0)
      return -1;
    xfer += ret;
    {
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;
      gchar * elem;
      gpointer value;
      THRIFT_UNUSED_VAR (value);

      if ((ret = thrift_protocol_write_set_begin (protocol, T_STRING, this_object->notebookGuids ? (gint32) g_hash_table_size ((GHashTable *) this_object->notebookGuids) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->notebookGuids)
        g_hash_table_foreach ((GHashTable *) this_object->notebookGuids, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        elem = keys[i];
        value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->notebookGuids), (gpointer) elem);

        if ((ret = thrift_protocol_write_string (protocol, elem, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sync_chunk_filter_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  SyncChunkFilter *self = SYNC_CHUNK_FILTER (object);

  switch (property_id)
  {
    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTES:
      self->includeNotes = g_value_get_boolean (value);
      self->__isset_includeNotes = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_RESOURCES:
      self->includeNoteResources = g_value_get_boolean (value);
      self->__isset_includeNoteResources = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_ATTRIBUTES:
      self->includeNoteAttributes = g_value_get_boolean (value);
      self->__isset_includeNoteAttributes = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTEBOOKS:
      self->includeNotebooks = g_value_get_boolean (value);
      self->__isset_includeNotebooks = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_TAGS:
      self->includeTags = g_value_get_boolean (value);
      self->__isset_includeTags = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_SEARCHES:
      self->includeSearches = g_value_get_boolean (value);
      self->__isset_includeSearches = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_RESOURCES:
      self->includeResources = g_value_get_boolean (value);
      self->__isset_includeResources = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_LINKED_NOTEBOOKS:
      self->includeLinkedNotebooks = g_value_get_boolean (value);
      self->__isset_includeLinkedNotebooks = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_EXPUNGED:
      self->includeExpunged = g_value_get_boolean (value);
      self->__isset_includeExpunged = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_APPLICATION_DATA_FULL_MAP:
      self->includeNoteApplicationDataFullMap = g_value_get_boolean (value);
      self->__isset_includeNoteApplicationDataFullMap = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_RESOURCE_APPLICATION_DATA_FULL_MAP:
      self->includeResourceApplicationDataFullMap = g_value_get_boolean (value);
      self->__isset_includeResourceApplicationDataFullMap = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_RESOURCE_APPLICATION_DATA_FULL_MAP:
      self->includeNoteResourceApplicationDataFullMap = g_value_get_boolean (value);
      self->__isset_includeNoteResourceApplicationDataFullMap = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_SHARED_NOTES:
      self->includeSharedNotes = g_value_get_boolean (value);
      self->__isset_includeSharedNotes = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_OMIT_SHARED_NOTEBOOKS:
      self->omitSharedNotebooks = g_value_get_boolean (value);
      self->__isset_omitSharedNotebooks = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_REQUIRE_NOTE_CONTENT_CLASS:
      if (self->requireNoteContentClass != NULL)
        g_free (self->requireNoteContentClass);
      self->requireNoteContentClass = g_value_dup_string (value);
      self->__isset_requireNoteContentClass = TRUE;
      break;

    case PROP_SYNC_CHUNK_FILTER_NOTEBOOK_GUIDS:
      if (self->notebookGuids != NULL)
        g_hash_table_unref (self->notebookGuids);
      self->notebookGuids = g_value_dup_boxed (value);
      self->__isset_notebookGuids = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sync_chunk_filter_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  SyncChunkFilter *self = SYNC_CHUNK_FILTER (object);

  switch (property_id)
  {
    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTES:
      g_value_set_boolean (value, self->includeNotes);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_RESOURCES:
      g_value_set_boolean (value, self->includeNoteResources);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_ATTRIBUTES:
      g_value_set_boolean (value, self->includeNoteAttributes);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTEBOOKS:
      g_value_set_boolean (value, self->includeNotebooks);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_TAGS:
      g_value_set_boolean (value, self->includeTags);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_SEARCHES:
      g_value_set_boolean (value, self->includeSearches);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_RESOURCES:
      g_value_set_boolean (value, self->includeResources);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_LINKED_NOTEBOOKS:
      g_value_set_boolean (value, self->includeLinkedNotebooks);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_EXPUNGED:
      g_value_set_boolean (value, self->includeExpunged);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_APPLICATION_DATA_FULL_MAP:
      g_value_set_boolean (value, self->includeNoteApplicationDataFullMap);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_RESOURCE_APPLICATION_DATA_FULL_MAP:
      g_value_set_boolean (value, self->includeResourceApplicationDataFullMap);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_RESOURCE_APPLICATION_DATA_FULL_MAP:
      g_value_set_boolean (value, self->includeNoteResourceApplicationDataFullMap);
      break;

    case PROP_SYNC_CHUNK_FILTER_INCLUDE_SHARED_NOTES:
      g_value_set_boolean (value, self->includeSharedNotes);
      break;

    case PROP_SYNC_CHUNK_FILTER_OMIT_SHARED_NOTEBOOKS:
      g_value_set_boolean (value, self->omitSharedNotebooks);
      break;

    case PROP_SYNC_CHUNK_FILTER_REQUIRE_NOTE_CONTENT_CLASS:
      g_value_set_string (value, self->requireNoteContentClass);
      break;

    case PROP_SYNC_CHUNK_FILTER_NOTEBOOK_GUIDS:
      g_value_set_boxed (value, self->notebookGuids);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sync_chunk_filter_instance_init (SyncChunkFilter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->includeNotes = 0;
  object->__isset_includeNotes = FALSE;
  object->includeNoteResources = 0;
  object->__isset_includeNoteResources = FALSE;
  object->includeNoteAttributes = 0;
  object->__isset_includeNoteAttributes = FALSE;
  object->includeNotebooks = 0;
  object->__isset_includeNotebooks = FALSE;
  object->includeTags = 0;
  object->__isset_includeTags = FALSE;
  object->includeSearches = 0;
  object->__isset_includeSearches = FALSE;
  object->includeResources = 0;
  object->__isset_includeResources = FALSE;
  object->includeLinkedNotebooks = 0;
  object->__isset_includeLinkedNotebooks = FALSE;
  object->includeExpunged = 0;
  object->__isset_includeExpunged = FALSE;
  object->includeNoteApplicationDataFullMap = 0;
  object->__isset_includeNoteApplicationDataFullMap = FALSE;
  object->includeResourceApplicationDataFullMap = 0;
  object->__isset_includeResourceApplicationDataFullMap = FALSE;
  object->includeNoteResourceApplicationDataFullMap = 0;
  object->__isset_includeNoteResourceApplicationDataFullMap = FALSE;
  object->includeSharedNotes = 0;
  object->__isset_includeSharedNotes = FALSE;
  object->omitSharedNotebooks = 0;
  object->__isset_omitSharedNotebooks = FALSE;
  object->requireNoteContentClass = NULL;
  object->__isset_requireNoteContentClass = FALSE;
  object->notebookGuids = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
  object->__isset_notebookGuids = FALSE;
}

static void 
sync_chunk_filter_finalize (GObject *object)
{
  SyncChunkFilter *tobject = SYNC_CHUNK_FILTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->requireNoteContentClass != NULL)
  {
    g_free(tobject->requireNoteContentClass);
    tobject->requireNoteContentClass = NULL;
  }
  if (tobject->notebookGuids != NULL)
  {
    g_hash_table_destroy (tobject->notebookGuids);
    tobject->notebookGuids = NULL;
  }
}

static void
sync_chunk_filter_class_init (SyncChunkFilterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sync_chunk_filter_read;
  struct_class->write = sync_chunk_filter_write;

  gobject_class->finalize = sync_chunk_filter_finalize;
  gobject_class->get_property = sync_chunk_filter_get_property;
  gobject_class->set_property = sync_chunk_filter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTES,
     g_param_spec_boolean ("includeNotes",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_RESOURCES,
     g_param_spec_boolean ("includeNoteResources",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_ATTRIBUTES,
     g_param_spec_boolean ("includeNoteAttributes",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTEBOOKS,
     g_param_spec_boolean ("includeNotebooks",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_TAGS,
     g_param_spec_boolean ("includeTags",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_SEARCHES,
     g_param_spec_boolean ("includeSearches",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_RESOURCES,
     g_param_spec_boolean ("includeResources",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_LINKED_NOTEBOOKS,
     g_param_spec_boolean ("includeLinkedNotebooks",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_EXPUNGED,
     g_param_spec_boolean ("includeExpunged",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_APPLICATION_DATA_FULL_MAP,
     g_param_spec_boolean ("includeNoteApplicationDataFullMap",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_RESOURCE_APPLICATION_DATA_FULL_MAP,
     g_param_spec_boolean ("includeResourceApplicationDataFullMap",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_NOTE_RESOURCE_APPLICATION_DATA_FULL_MAP,
     g_param_spec_boolean ("includeNoteResourceApplicationDataFullMap",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_INCLUDE_SHARED_NOTES,
     g_param_spec_boolean ("includeSharedNotes",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_OMIT_SHARED_NOTEBOOKS,
     g_param_spec_boolean ("omitSharedNotebooks",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_REQUIRE_NOTE_CONTENT_CLASS,
     g_param_spec_string ("requireNoteContentClass",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SYNC_CHUNK_FILTER_NOTEBOOK_GUIDS,
     g_param_spec_boxed ("notebookGuids",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
sync_chunk_filter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SyncChunkFilterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sync_chunk_filter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SyncChunkFilter),
      0, /* n_preallocs */
      (GInstanceInitFunc) sync_chunk_filter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SyncChunkFilterType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteFilterProperties
{
  PROP_NOTE_FILTER_0,
  PROP_NOTE_FILTER_ORDER,
  PROP_NOTE_FILTER_ASCENDING,
  PROP_NOTE_FILTER_WORDS,
  PROP_NOTE_FILTER_NOTEBOOK_GUID,
  PROP_NOTE_FILTER_TAG_GUIDS,
  PROP_NOTE_FILTER_TIME_ZONE,
  PROP_NOTE_FILTER_INACTIVE,
  PROP_NOTE_FILTER_EMPHASIZED,
  PROP_NOTE_FILTER_INCLUDE_ALL_READABLE_NOTEBOOKS,
  PROP_NOTE_FILTER_INCLUDE_ALL_READABLE_WORKSPACES,
  PROP_NOTE_FILTER_CONTEXT,
  PROP_NOTE_FILTER_RAW_WORDS,
  PROP_NOTE_FILTER_SEARCH_CONTEXT_BYTES
};

/* reads a note_filter object */
static gint32
note_filter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteFilter * this_object = NOTE_FILTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->order, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_order = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->ascending, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ascending = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->words != NULL)
          {
            g_free(this_object->words);
            this_object->words = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->words, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_words = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->notebookGuid != NULL)
          {
            g_free(this_object->notebookGuid);
            this_object->notebookGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->notebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_notebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem23 = NULL;
              if (_elem23 != NULL)
              {
                g_free(_elem23);
                _elem23 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem23, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->tagGuids, _elem23);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_tagGuids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->timeZone != NULL)
          {
            g_free(this_object->timeZone);
            this_object->timeZone = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timeZone, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timeZone = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->inactive, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_inactive = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->emphasized != NULL)
          {
            g_free(this_object->emphasized);
            this_object->emphasized = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->emphasized, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_emphasized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeAllReadableNotebooks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeAllReadableNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeAllReadableWorkspaces, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeAllReadableWorkspaces = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRING)
        {
          if (this_object->context != NULL)
          {
            g_free(this_object->context);
            this_object->context = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->context, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_context = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->rawWords != NULL)
          {
            g_free(this_object->rawWords);
            this_object->rawWords = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rawWords, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rawWords = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRING)
        {
          if (this_object->searchContextBytes != NULL)
          {
            g_free(this_object->searchContextBytes);
            this_object->searchContextBytes = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->searchContextBytes = g_byte_array_new();
          g_byte_array_append (this_object->searchContextBytes, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_searchContextBytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_filter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteFilter * this_object = NOTE_FILTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteFilter", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_order == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "order", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->order, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ascending == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ascending", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->ascending, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_words == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "words", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->words, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notebookGuid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->notebookGuid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_tagGuids == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tagGuids", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i24;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->tagGuids ? this_object->tagGuids->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i24 = 0; i24 < (this_object->tagGuids ? this_object->tagGuids->len : 0); i24++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->tagGuids, i24)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_timeZone == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "timeZone", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->timeZone, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_inactive == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "inactive", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->inactive, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_emphasized == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "emphasized", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->emphasized, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeAllReadableNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeAllReadableNotebooks", T_BOOL, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeAllReadableNotebooks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeAllReadableWorkspaces == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeAllReadableWorkspaces", T_BOOL, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeAllReadableWorkspaces, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_context == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "context", T_STRING, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->context, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_rawWords == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rawWords", T_STRING, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->rawWords, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_searchContextBytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "searchContextBytes", T_STRING, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->searchContextBytes ? ((GByteArray *) this_object->searchContextBytes)->data : NULL, this_object->searchContextBytes ? ((GByteArray *) this_object->searchContextBytes)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_filter_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  NoteFilter *self = NOTE_FILTER (object);

  switch (property_id)
  {
    case PROP_NOTE_FILTER_ORDER:
      self->order = g_value_get_int (value);
      self->__isset_order = TRUE;
      break;

    case PROP_NOTE_FILTER_ASCENDING:
      self->ascending = g_value_get_boolean (value);
      self->__isset_ascending = TRUE;
      break;

    case PROP_NOTE_FILTER_WORDS:
      if (self->words != NULL)
        g_free (self->words);
      self->words = g_value_dup_string (value);
      self->__isset_words = TRUE;
      break;

    case PROP_NOTE_FILTER_NOTEBOOK_GUID:
      if (self->notebookGuid != NULL)
        g_free (self->notebookGuid);
      self->notebookGuid = g_value_dup_string (value);
      self->__isset_notebookGuid = TRUE;
      break;

    case PROP_NOTE_FILTER_TAG_GUIDS:
      if (self->tagGuids != NULL)
        g_ptr_array_unref (self->tagGuids);
      self->tagGuids = g_value_dup_boxed (value);
      self->__isset_tagGuids = TRUE;
      break;

    case PROP_NOTE_FILTER_TIME_ZONE:
      if (self->timeZone != NULL)
        g_free (self->timeZone);
      self->timeZone = g_value_dup_string (value);
      self->__isset_timeZone = TRUE;
      break;

    case PROP_NOTE_FILTER_INACTIVE:
      self->inactive = g_value_get_boolean (value);
      self->__isset_inactive = TRUE;
      break;

    case PROP_NOTE_FILTER_EMPHASIZED:
      if (self->emphasized != NULL)
        g_free (self->emphasized);
      self->emphasized = g_value_dup_string (value);
      self->__isset_emphasized = TRUE;
      break;

    case PROP_NOTE_FILTER_INCLUDE_ALL_READABLE_NOTEBOOKS:
      self->includeAllReadableNotebooks = g_value_get_boolean (value);
      self->__isset_includeAllReadableNotebooks = TRUE;
      break;

    case PROP_NOTE_FILTER_INCLUDE_ALL_READABLE_WORKSPACES:
      self->includeAllReadableWorkspaces = g_value_get_boolean (value);
      self->__isset_includeAllReadableWorkspaces = TRUE;
      break;

    case PROP_NOTE_FILTER_CONTEXT:
      if (self->context != NULL)
        g_free (self->context);
      self->context = g_value_dup_string (value);
      self->__isset_context = TRUE;
      break;

    case PROP_NOTE_FILTER_RAW_WORDS:
      if (self->rawWords != NULL)
        g_free (self->rawWords);
      self->rawWords = g_value_dup_string (value);
      self->__isset_rawWords = TRUE;
      break;

    case PROP_NOTE_FILTER_SEARCH_CONTEXT_BYTES:
      if (self->searchContextBytes != NULL)
        g_byte_array_unref (self->searchContextBytes);
      self->searchContextBytes = g_value_dup_boxed (value);
      self->__isset_searchContextBytes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_filter_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  NoteFilter *self = NOTE_FILTER (object);

  switch (property_id)
  {
    case PROP_NOTE_FILTER_ORDER:
      g_value_set_int (value, self->order);
      break;

    case PROP_NOTE_FILTER_ASCENDING:
      g_value_set_boolean (value, self->ascending);
      break;

    case PROP_NOTE_FILTER_WORDS:
      g_value_set_string (value, self->words);
      break;

    case PROP_NOTE_FILTER_NOTEBOOK_GUID:
      g_value_set_string (value, self->notebookGuid);
      break;

    case PROP_NOTE_FILTER_TAG_GUIDS:
      g_value_set_boxed (value, self->tagGuids);
      break;

    case PROP_NOTE_FILTER_TIME_ZONE:
      g_value_set_string (value, self->timeZone);
      break;

    case PROP_NOTE_FILTER_INACTIVE:
      g_value_set_boolean (value, self->inactive);
      break;

    case PROP_NOTE_FILTER_EMPHASIZED:
      g_value_set_string (value, self->emphasized);
      break;

    case PROP_NOTE_FILTER_INCLUDE_ALL_READABLE_NOTEBOOKS:
      g_value_set_boolean (value, self->includeAllReadableNotebooks);
      break;

    case PROP_NOTE_FILTER_INCLUDE_ALL_READABLE_WORKSPACES:
      g_value_set_boolean (value, self->includeAllReadableWorkspaces);
      break;

    case PROP_NOTE_FILTER_CONTEXT:
      g_value_set_string (value, self->context);
      break;

    case PROP_NOTE_FILTER_RAW_WORDS:
      g_value_set_string (value, self->rawWords);
      break;

    case PROP_NOTE_FILTER_SEARCH_CONTEXT_BYTES:
      g_value_set_boxed (value, self->searchContextBytes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_filter_instance_init (NoteFilter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->order = 0;
  object->__isset_order = FALSE;
  object->ascending = 0;
  object->__isset_ascending = FALSE;
  object->words = NULL;
  object->__isset_words = FALSE;
  object->notebookGuid = NULL;
  object->__isset_notebookGuid = FALSE;
  object->tagGuids = g_ptr_array_new_with_free_func (g_free);
  object->__isset_tagGuids = FALSE;
  object->timeZone = NULL;
  object->__isset_timeZone = FALSE;
  object->inactive = 0;
  object->__isset_inactive = FALSE;
  object->emphasized = NULL;
  object->__isset_emphasized = FALSE;
  object->includeAllReadableNotebooks = 0;
  object->__isset_includeAllReadableNotebooks = FALSE;
  object->includeAllReadableWorkspaces = 0;
  object->__isset_includeAllReadableWorkspaces = FALSE;
  object->context = NULL;
  object->__isset_context = FALSE;
  object->rawWords = NULL;
  object->__isset_rawWords = FALSE;
  object->searchContextBytes = NULL;
  object->__isset_searchContextBytes = FALSE;
}

static void 
note_filter_finalize (GObject *object)
{
  NoteFilter *tobject = NOTE_FILTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->words != NULL)
  {
    g_free(tobject->words);
    tobject->words = NULL;
  }
  if (tobject->notebookGuid != NULL)
  {
    g_free(tobject->notebookGuid);
    tobject->notebookGuid = NULL;
  }
  if (tobject->tagGuids != NULL)
  {
    g_ptr_array_unref (tobject->tagGuids);
    tobject->tagGuids = NULL;
  }
  if (tobject->timeZone != NULL)
  {
    g_free(tobject->timeZone);
    tobject->timeZone = NULL;
  }
  if (tobject->emphasized != NULL)
  {
    g_free(tobject->emphasized);
    tobject->emphasized = NULL;
  }
  if (tobject->context != NULL)
  {
    g_free(tobject->context);
    tobject->context = NULL;
  }
  if (tobject->rawWords != NULL)
  {
    g_free(tobject->rawWords);
    tobject->rawWords = NULL;
  }
  if (tobject->searchContextBytes != NULL)
  {
    thrift_string_free(tobject->searchContextBytes);
    tobject->searchContextBytes = NULL;
  }
}

static void
note_filter_class_init (NoteFilterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_filter_read;
  struct_class->write = note_filter_write;

  gobject_class->finalize = note_filter_finalize;
  gobject_class->get_property = note_filter_get_property;
  gobject_class->set_property = note_filter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_ORDER,
     g_param_spec_int ("order",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_ASCENDING,
     g_param_spec_boolean ("ascending",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_WORDS,
     g_param_spec_string ("words",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_NOTEBOOK_GUID,
     g_param_spec_string ("notebookGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_TAG_GUIDS,
     g_param_spec_boxed ("tagGuids",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_TIME_ZONE,
     g_param_spec_string ("timeZone",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_INACTIVE,
     g_param_spec_boolean ("inactive",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_EMPHASIZED,
     g_param_spec_string ("emphasized",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_INCLUDE_ALL_READABLE_NOTEBOOKS,
     g_param_spec_boolean ("includeAllReadableNotebooks",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_INCLUDE_ALL_READABLE_WORKSPACES,
     g_param_spec_boolean ("includeAllReadableWorkspaces",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_CONTEXT,
     g_param_spec_string ("context",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_RAW_WORDS,
     g_param_spec_string ("rawWords",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_FILTER_SEARCH_CONTEXT_BYTES,
     g_param_spec_boxed ("searchContextBytes",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
note_filter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteFilterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_filter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteFilter),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_filter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteFilterType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteListProperties
{
  PROP_NOTE_LIST_0,
  PROP_NOTE_LIST_START_INDEX,
  PROP_NOTE_LIST_TOTAL_NOTES,
  PROP_NOTE_LIST_NOTES,
  PROP_NOTE_LIST_STOPPED_WORDS,
  PROP_NOTE_LIST_SEARCHED_WORDS,
  PROP_NOTE_LIST_UPDATE_COUNT,
  PROP_NOTE_LIST_SEARCH_CONTEXT_BYTES,
  PROP_NOTE_LIST_DEBUG_INFO
};

/* reads a note_list object */
static gint32
note_list_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteList * this_object = NOTE_LIST(object);
  gboolean isset_startIndex = FALSE;
  gboolean isset_totalNotes = FALSE;
  gboolean isset_notes = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startIndex, error)) < 0)
            return -1;
          xfer += ret;
          isset_startIndex = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->totalNotes, error)) < 0)
            return -1;
          xfer += ret;
          isset_totalNotes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Note * _elem25 = NULL;
              if ( _elem25 != NULL)
              {
                g_object_unref (_elem25);
              }
              _elem25 = g_object_new (TYPE_NOTE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem25), protocol, error)) < 0)
              {
                g_object_unref (_elem25);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->notes, _elem25);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_notes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem26 = NULL;
              if (_elem26 != NULL)
              {
                g_free(_elem26);
                _elem26 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem26, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->stoppedWords, _elem26);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_stoppedWords = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem27 = NULL;
              if (_elem27 != NULL)
              {
                g_free(_elem27);
                _elem27 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem27, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->searchedWords, _elem27);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_searchedWords = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->updateCount, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateCount = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->searchContextBytes != NULL)
          {
            g_free(this_object->searchContextBytes);
            this_object->searchContextBytes = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->searchContextBytes = g_byte_array_new();
          g_byte_array_append (this_object->searchContextBytes, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_searchContextBytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->debugInfo != NULL)
          {
            g_free(this_object->debugInfo);
            this_object->debugInfo = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->debugInfo, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_debugInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startIndex)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_totalNotes)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_notes)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
note_list_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteList * this_object = NOTE_LIST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteList", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startIndex", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startIndex, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "totalNotes", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->totalNotes, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "notes", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i28;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->notes ? this_object->notes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i28 = 0; i28 < (this_object->notes ? this_object->notes->len : 0); i28++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->notes, i28))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_stoppedWords == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "stoppedWords", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i29;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->stoppedWords ? this_object->stoppedWords->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i29 = 0; i29 < (this_object->stoppedWords ? this_object->stoppedWords->len : 0); i29++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->stoppedWords, i29)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_searchedWords == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "searchedWords", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i30;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->searchedWords ? this_object->searchedWords->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i30 = 0; i30 < (this_object->searchedWords ? this_object->searchedWords->len : 0); i30++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->searchedWords, i30)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateCount == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateCount", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->updateCount, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_searchContextBytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "searchContextBytes", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->searchContextBytes ? ((GByteArray *) this_object->searchContextBytes)->data : NULL, this_object->searchContextBytes ? ((GByteArray *) this_object->searchContextBytes)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_debugInfo == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "debugInfo", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->debugInfo, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_list_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  NoteList *self = NOTE_LIST (object);

  switch (property_id)
  {
    case PROP_NOTE_LIST_START_INDEX:
      self->startIndex = g_value_get_int (value);
      break;

    case PROP_NOTE_LIST_TOTAL_NOTES:
      self->totalNotes = g_value_get_int (value);
      break;

    case PROP_NOTE_LIST_NOTES:
      if (self->notes != NULL)
        g_ptr_array_unref (self->notes);
      self->notes = g_value_dup_boxed (value);
      break;

    case PROP_NOTE_LIST_STOPPED_WORDS:
      if (self->stoppedWords != NULL)
        g_ptr_array_unref (self->stoppedWords);
      self->stoppedWords = g_value_dup_boxed (value);
      self->__isset_stoppedWords = TRUE;
      break;

    case PROP_NOTE_LIST_SEARCHED_WORDS:
      if (self->searchedWords != NULL)
        g_ptr_array_unref (self->searchedWords);
      self->searchedWords = g_value_dup_boxed (value);
      self->__isset_searchedWords = TRUE;
      break;

    case PROP_NOTE_LIST_UPDATE_COUNT:
      self->updateCount = g_value_get_int (value);
      self->__isset_updateCount = TRUE;
      break;

    case PROP_NOTE_LIST_SEARCH_CONTEXT_BYTES:
      if (self->searchContextBytes != NULL)
        g_byte_array_unref (self->searchContextBytes);
      self->searchContextBytes = g_value_dup_boxed (value);
      self->__isset_searchContextBytes = TRUE;
      break;

    case PROP_NOTE_LIST_DEBUG_INFO:
      if (self->debugInfo != NULL)
        g_free (self->debugInfo);
      self->debugInfo = g_value_dup_string (value);
      self->__isset_debugInfo = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_list_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  NoteList *self = NOTE_LIST (object);

  switch (property_id)
  {
    case PROP_NOTE_LIST_START_INDEX:
      g_value_set_int (value, self->startIndex);
      break;

    case PROP_NOTE_LIST_TOTAL_NOTES:
      g_value_set_int (value, self->totalNotes);
      break;

    case PROP_NOTE_LIST_NOTES:
      g_value_set_boxed (value, self->notes);
      break;

    case PROP_NOTE_LIST_STOPPED_WORDS:
      g_value_set_boxed (value, self->stoppedWords);
      break;

    case PROP_NOTE_LIST_SEARCHED_WORDS:
      g_value_set_boxed (value, self->searchedWords);
      break;

    case PROP_NOTE_LIST_UPDATE_COUNT:
      g_value_set_int (value, self->updateCount);
      break;

    case PROP_NOTE_LIST_SEARCH_CONTEXT_BYTES:
      g_value_set_boxed (value, self->searchContextBytes);
      break;

    case PROP_NOTE_LIST_DEBUG_INFO:
      g_value_set_string (value, self->debugInfo);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_list_instance_init (NoteList * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->startIndex = 0;
  object->totalNotes = 0;
  object->notes = g_ptr_array_new_with_free_func (g_object_unref);
  object->stoppedWords = g_ptr_array_new_with_free_func (g_free);
  object->__isset_stoppedWords = FALSE;
  object->searchedWords = g_ptr_array_new_with_free_func (g_free);
  object->__isset_searchedWords = FALSE;
  object->updateCount = 0;
  object->__isset_updateCount = FALSE;
  object->searchContextBytes = NULL;
  object->__isset_searchContextBytes = FALSE;
  object->debugInfo = NULL;
  object->__isset_debugInfo = FALSE;
}

static void 
note_list_finalize (GObject *object)
{
  NoteList *tobject = NOTE_LIST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->notes != NULL)
  {
    g_ptr_array_unref (tobject->notes);
    tobject->notes = NULL;
  }
  if (tobject->stoppedWords != NULL)
  {
    g_ptr_array_unref (tobject->stoppedWords);
    tobject->stoppedWords = NULL;
  }
  if (tobject->searchedWords != NULL)
  {
    g_ptr_array_unref (tobject->searchedWords);
    tobject->searchedWords = NULL;
  }
  if (tobject->searchContextBytes != NULL)
  {
    thrift_string_free(tobject->searchContextBytes);
    tobject->searchContextBytes = NULL;
  }
  if (tobject->debugInfo != NULL)
  {
    g_free(tobject->debugInfo);
    tobject->debugInfo = NULL;
  }
}

static void
note_list_class_init (NoteListClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_list_read;
  struct_class->write = note_list_write;

  gobject_class->finalize = note_list_finalize;
  gobject_class->get_property = note_list_get_property;
  gobject_class->set_property = note_list_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_LIST_START_INDEX,
     g_param_spec_int ("startIndex",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_LIST_TOTAL_NOTES,
     g_param_spec_int ("totalNotes",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_LIST_NOTES,
     g_param_spec_boxed ("notes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_LIST_STOPPED_WORDS,
     g_param_spec_boxed ("stoppedWords",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_LIST_SEARCHED_WORDS,
     g_param_spec_boxed ("searchedWords",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_LIST_UPDATE_COUNT,
     g_param_spec_int ("updateCount",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_LIST_SEARCH_CONTEXT_BYTES,
     g_param_spec_boxed ("searchContextBytes",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_LIST_DEBUG_INFO,
     g_param_spec_string ("debugInfo",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_list_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteListClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_list_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteList),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_list_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteListType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteMetadataProperties
{
  PROP_NOTE_METADATA_0,
  PROP_NOTE_METADATA_GUID,
  PROP_NOTE_METADATA_TITLE,
  PROP_NOTE_METADATA_CONTENT_LENGTH,
  PROP_NOTE_METADATA_CREATED,
  PROP_NOTE_METADATA_UPDATED,
  PROP_NOTE_METADATA_DELETED,
  PROP_NOTE_METADATA_UPDATE_SEQUENCE_NUM,
  PROP_NOTE_METADATA_NOTEBOOK_GUID,
  PROP_NOTE_METADATA_TAG_GUIDS,
  PROP_NOTE_METADATA_ATTRIBUTES,
  PROP_NOTE_METADATA_LARGEST_RESOURCE_MIME,
  PROP_NOTE_METADATA_LARGEST_RESOURCE_SIZE
};

/* reads a note_metadata object */
static gint32
note_metadata_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteMetadata * this_object = NOTE_METADATA(object);
  gboolean isset_guid = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->title != NULL)
          {
            g_free(this_object->title);
            this_object->title = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->title, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_title = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->contentLength, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_contentLength = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->created, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_created = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updated, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updated = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->deleted, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deleted = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->updateSequenceNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateSequenceNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->notebookGuid != NULL)
          {
            g_free(this_object->notebookGuid);
            this_object->notebookGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->notebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_notebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem31 = NULL;
              if (_elem31 != NULL)
              {
                g_free(_elem31);
                _elem31 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem31, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->tagGuids, _elem31);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_tagGuids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->attributes), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 20:
        if (ftype == T_STRING)
        {
          if (this_object->largestResourceMime != NULL)
          {
            g_free(this_object->largestResourceMime);
            this_object->largestResourceMime = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->largestResourceMime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_largestResourceMime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 21:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->largestResourceSize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_largestResourceSize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_guid)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
note_metadata_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteMetadata * this_object = NOTE_METADATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteMetadata", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_title == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "title", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->title, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_contentLength == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "contentLength", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->contentLength, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_created == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "created", T_I64, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->created, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updated == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updated", T_I64, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->updated, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_deleted == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "deleted", T_I64, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->deleted, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateSequenceNum == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateSequenceNum", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->updateSequenceNum, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notebookGuid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->notebookGuid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_tagGuids == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tagGuids", T_LIST, 12, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i32;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->tagGuids ? this_object->tagGuids->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i32 = 0; i32 < (this_object->tagGuids ? this_object->tagGuids->len : 0); i32++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->tagGuids, i32)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_attributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_STRUCT, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->attributes), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_largestResourceMime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "largestResourceMime", T_STRING, 20, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->largestResourceMime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_largestResourceSize == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "largestResourceSize", T_I32, 21, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->largestResourceSize, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_metadata_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  NoteMetadata *self = NOTE_METADATA (object);

  switch (property_id)
  {
    case PROP_NOTE_METADATA_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      break;

    case PROP_NOTE_METADATA_TITLE:
      if (self->title != NULL)
        g_free (self->title);
      self->title = g_value_dup_string (value);
      self->__isset_title = TRUE;
      break;

    case PROP_NOTE_METADATA_CONTENT_LENGTH:
      self->contentLength = g_value_get_int (value);
      self->__isset_contentLength = TRUE;
      break;

    case PROP_NOTE_METADATA_CREATED:
      self->created = g_value_get_int64 (value);
      self->__isset_created = TRUE;
      break;

    case PROP_NOTE_METADATA_UPDATED:
      self->updated = g_value_get_int64 (value);
      self->__isset_updated = TRUE;
      break;

    case PROP_NOTE_METADATA_DELETED:
      self->deleted = g_value_get_int64 (value);
      self->__isset_deleted = TRUE;
      break;

    case PROP_NOTE_METADATA_UPDATE_SEQUENCE_NUM:
      self->updateSequenceNum = g_value_get_int (value);
      self->__isset_updateSequenceNum = TRUE;
      break;

    case PROP_NOTE_METADATA_NOTEBOOK_GUID:
      if (self->notebookGuid != NULL)
        g_free (self->notebookGuid);
      self->notebookGuid = g_value_dup_string (value);
      self->__isset_notebookGuid = TRUE;
      break;

    case PROP_NOTE_METADATA_TAG_GUIDS:
      if (self->tagGuids != NULL)
        g_ptr_array_unref (self->tagGuids);
      self->tagGuids = g_value_dup_boxed (value);
      self->__isset_tagGuids = TRUE;
      break;

    case PROP_NOTE_METADATA_ATTRIBUTES:
      if (self->attributes != NULL)
        g_object_unref (self->attributes);
      self->attributes = g_value_dup_object (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_NOTE_METADATA_LARGEST_RESOURCE_MIME:
      if (self->largestResourceMime != NULL)
        g_free (self->largestResourceMime);
      self->largestResourceMime = g_value_dup_string (value);
      self->__isset_largestResourceMime = TRUE;
      break;

    case PROP_NOTE_METADATA_LARGEST_RESOURCE_SIZE:
      self->largestResourceSize = g_value_get_int (value);
      self->__isset_largestResourceSize = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_metadata_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  NoteMetadata *self = NOTE_METADATA (object);

  switch (property_id)
  {
    case PROP_NOTE_METADATA_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_METADATA_TITLE:
      g_value_set_string (value, self->title);
      break;

    case PROP_NOTE_METADATA_CONTENT_LENGTH:
      g_value_set_int (value, self->contentLength);
      break;

    case PROP_NOTE_METADATA_CREATED:
      g_value_set_int64 (value, self->created);
      break;

    case PROP_NOTE_METADATA_UPDATED:
      g_value_set_int64 (value, self->updated);
      break;

    case PROP_NOTE_METADATA_DELETED:
      g_value_set_int64 (value, self->deleted);
      break;

    case PROP_NOTE_METADATA_UPDATE_SEQUENCE_NUM:
      g_value_set_int (value, self->updateSequenceNum);
      break;

    case PROP_NOTE_METADATA_NOTEBOOK_GUID:
      g_value_set_string (value, self->notebookGuid);
      break;

    case PROP_NOTE_METADATA_TAG_GUIDS:
      g_value_set_boxed (value, self->tagGuids);
      break;

    case PROP_NOTE_METADATA_ATTRIBUTES:
      g_value_set_object (value, self->attributes);
      break;

    case PROP_NOTE_METADATA_LARGEST_RESOURCE_MIME:
      g_value_set_string (value, self->largestResourceMime);
      break;

    case PROP_NOTE_METADATA_LARGEST_RESOURCE_SIZE:
      g_value_set_int (value, self->largestResourceSize);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_metadata_instance_init (NoteMetadata * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->guid = NULL;
  object->title = NULL;
  object->__isset_title = FALSE;
  object->contentLength = 0;
  object->__isset_contentLength = FALSE;
  object->created = 0;
  object->__isset_created = FALSE;
  object->updated = 0;
  object->__isset_updated = FALSE;
  object->deleted = 0;
  object->__isset_deleted = FALSE;
  object->updateSequenceNum = 0;
  object->__isset_updateSequenceNum = FALSE;
  object->notebookGuid = NULL;
  object->__isset_notebookGuid = FALSE;
  object->tagGuids = g_ptr_array_new_with_free_func (g_free);
  object->__isset_tagGuids = FALSE;
  object->attributes = g_object_new (TYPE_NOTE_ATTRIBUTES, NULL);
  object->__isset_attributes = FALSE;
  object->largestResourceMime = NULL;
  object->__isset_largestResourceMime = FALSE;
  object->largestResourceSize = 0;
  object->__isset_largestResourceSize = FALSE;
}

static void 
note_metadata_finalize (GObject *object)
{
  NoteMetadata *tobject = NOTE_METADATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->title != NULL)
  {
    g_free(tobject->title);
    tobject->title = NULL;
  }
  if (tobject->notebookGuid != NULL)
  {
    g_free(tobject->notebookGuid);
    tobject->notebookGuid = NULL;
  }
  if (tobject->tagGuids != NULL)
  {
    g_ptr_array_unref (tobject->tagGuids);
    tobject->tagGuids = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_object_unref(tobject->attributes);
    tobject->attributes = NULL;
  }
  if (tobject->largestResourceMime != NULL)
  {
    g_free(tobject->largestResourceMime);
    tobject->largestResourceMime = NULL;
  }
}

static void
note_metadata_class_init (NoteMetadataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_metadata_read;
  struct_class->write = note_metadata_write;

  gobject_class->finalize = note_metadata_finalize;
  gobject_class->get_property = note_metadata_get_property;
  gobject_class->set_property = note_metadata_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_TITLE,
     g_param_spec_string ("title",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_CONTENT_LENGTH,
     g_param_spec_int ("contentLength",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_CREATED,
     g_param_spec_int64 ("created",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_UPDATED,
     g_param_spec_int64 ("updated",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_DELETED,
     g_param_spec_int64 ("deleted",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_UPDATE_SEQUENCE_NUM,
     g_param_spec_int ("updateSequenceNum",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_NOTEBOOK_GUID,
     g_param_spec_string ("notebookGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_TAG_GUIDS,
     g_param_spec_boxed ("tagGuids",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_ATTRIBUTES,
     g_param_spec_object ("attributes",
                         NULL,
                         NULL,
                         TYPE_NOTE_ATTRIBUTES,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_LARGEST_RESOURCE_MIME,
     g_param_spec_string ("largestResourceMime",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_METADATA_LARGEST_RESOURCE_SIZE,
     g_param_spec_int ("largestResourceSize",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
note_metadata_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteMetadataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_metadata_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteMetadata),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_metadata_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteMetadataType",
                                   &type_info, 0);
  }

  return type;
}

enum _NotesMetadataListProperties
{
  PROP_NOTES_METADATA_LIST_0,
  PROP_NOTES_METADATA_LIST_START_INDEX,
  PROP_NOTES_METADATA_LIST_TOTAL_NOTES,
  PROP_NOTES_METADATA_LIST_NOTES,
  PROP_NOTES_METADATA_LIST_STOPPED_WORDS,
  PROP_NOTES_METADATA_LIST_SEARCHED_WORDS,
  PROP_NOTES_METADATA_LIST_UPDATE_COUNT,
  PROP_NOTES_METADATA_LIST_SEARCH_CONTEXT_BYTES,
  PROP_NOTES_METADATA_LIST_DEBUG_INFO
};

/* reads a notes_metadata_list object */
static gint32
notes_metadata_list_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NotesMetadataList * this_object = NOTES_METADATA_LIST(object);
  gboolean isset_startIndex = FALSE;
  gboolean isset_totalNotes = FALSE;
  gboolean isset_notes = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startIndex, error)) < 0)
            return -1;
          xfer += ret;
          isset_startIndex = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->totalNotes, error)) < 0)
            return -1;
          xfer += ret;
          isset_totalNotes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              NoteMetadata * _elem33 = NULL;
              if ( _elem33 != NULL)
              {
                g_object_unref (_elem33);
              }
              _elem33 = g_object_new (TYPE_NOTE_METADATA, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem33), protocol, error)) < 0)
              {
                g_object_unref (_elem33);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->notes, _elem33);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_notes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem34 = NULL;
              if (_elem34 != NULL)
              {
                g_free(_elem34);
                _elem34 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem34, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->stoppedWords, _elem34);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_stoppedWords = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem35 = NULL;
              if (_elem35 != NULL)
              {
                g_free(_elem35);
                _elem35 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem35, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->searchedWords, _elem35);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_searchedWords = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->updateCount, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateCount = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->searchContextBytes != NULL)
          {
            g_free(this_object->searchContextBytes);
            this_object->searchContextBytes = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->searchContextBytes = g_byte_array_new();
          g_byte_array_append (this_object->searchContextBytes, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_searchContextBytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->debugInfo != NULL)
          {
            g_free(this_object->debugInfo);
            this_object->debugInfo = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->debugInfo, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_debugInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startIndex)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_totalNotes)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_notes)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
notes_metadata_list_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NotesMetadataList * this_object = NOTES_METADATA_LIST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NotesMetadataList", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startIndex", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startIndex, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "totalNotes", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->totalNotes, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "notes", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i36;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->notes ? this_object->notes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i36 = 0; i36 < (this_object->notes ? this_object->notes->len : 0); i36++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->notes, i36))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_stoppedWords == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "stoppedWords", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i37;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->stoppedWords ? this_object->stoppedWords->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i37 = 0; i37 < (this_object->stoppedWords ? this_object->stoppedWords->len : 0); i37++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->stoppedWords, i37)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_searchedWords == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "searchedWords", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i38;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->searchedWords ? this_object->searchedWords->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i38 = 0; i38 < (this_object->searchedWords ? this_object->searchedWords->len : 0); i38++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->searchedWords, i38)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateCount == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateCount", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->updateCount, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_searchContextBytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "searchContextBytes", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->searchContextBytes ? ((GByteArray *) this_object->searchContextBytes)->data : NULL, this_object->searchContextBytes ? ((GByteArray *) this_object->searchContextBytes)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_debugInfo == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "debugInfo", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->debugInfo, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
notes_metadata_list_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  NotesMetadataList *self = NOTES_METADATA_LIST (object);

  switch (property_id)
  {
    case PROP_NOTES_METADATA_LIST_START_INDEX:
      self->startIndex = g_value_get_int (value);
      break;

    case PROP_NOTES_METADATA_LIST_TOTAL_NOTES:
      self->totalNotes = g_value_get_int (value);
      break;

    case PROP_NOTES_METADATA_LIST_NOTES:
      if (self->notes != NULL)
        g_ptr_array_unref (self->notes);
      self->notes = g_value_dup_boxed (value);
      break;

    case PROP_NOTES_METADATA_LIST_STOPPED_WORDS:
      if (self->stoppedWords != NULL)
        g_ptr_array_unref (self->stoppedWords);
      self->stoppedWords = g_value_dup_boxed (value);
      self->__isset_stoppedWords = TRUE;
      break;

    case PROP_NOTES_METADATA_LIST_SEARCHED_WORDS:
      if (self->searchedWords != NULL)
        g_ptr_array_unref (self->searchedWords);
      self->searchedWords = g_value_dup_boxed (value);
      self->__isset_searchedWords = TRUE;
      break;

    case PROP_NOTES_METADATA_LIST_UPDATE_COUNT:
      self->updateCount = g_value_get_int (value);
      self->__isset_updateCount = TRUE;
      break;

    case PROP_NOTES_METADATA_LIST_SEARCH_CONTEXT_BYTES:
      if (self->searchContextBytes != NULL)
        g_byte_array_unref (self->searchContextBytes);
      self->searchContextBytes = g_value_dup_boxed (value);
      self->__isset_searchContextBytes = TRUE;
      break;

    case PROP_NOTES_METADATA_LIST_DEBUG_INFO:
      if (self->debugInfo != NULL)
        g_free (self->debugInfo);
      self->debugInfo = g_value_dup_string (value);
      self->__isset_debugInfo = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
notes_metadata_list_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  NotesMetadataList *self = NOTES_METADATA_LIST (object);

  switch (property_id)
  {
    case PROP_NOTES_METADATA_LIST_START_INDEX:
      g_value_set_int (value, self->startIndex);
      break;

    case PROP_NOTES_METADATA_LIST_TOTAL_NOTES:
      g_value_set_int (value, self->totalNotes);
      break;

    case PROP_NOTES_METADATA_LIST_NOTES:
      g_value_set_boxed (value, self->notes);
      break;

    case PROP_NOTES_METADATA_LIST_STOPPED_WORDS:
      g_value_set_boxed (value, self->stoppedWords);
      break;

    case PROP_NOTES_METADATA_LIST_SEARCHED_WORDS:
      g_value_set_boxed (value, self->searchedWords);
      break;

    case PROP_NOTES_METADATA_LIST_UPDATE_COUNT:
      g_value_set_int (value, self->updateCount);
      break;

    case PROP_NOTES_METADATA_LIST_SEARCH_CONTEXT_BYTES:
      g_value_set_boxed (value, self->searchContextBytes);
      break;

    case PROP_NOTES_METADATA_LIST_DEBUG_INFO:
      g_value_set_string (value, self->debugInfo);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
notes_metadata_list_instance_init (NotesMetadataList * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->startIndex = 0;
  object->totalNotes = 0;
  object->notes = g_ptr_array_new_with_free_func (g_object_unref);
  object->stoppedWords = g_ptr_array_new_with_free_func (g_free);
  object->__isset_stoppedWords = FALSE;
  object->searchedWords = g_ptr_array_new_with_free_func (g_free);
  object->__isset_searchedWords = FALSE;
  object->updateCount = 0;
  object->__isset_updateCount = FALSE;
  object->searchContextBytes = NULL;
  object->__isset_searchContextBytes = FALSE;
  object->debugInfo = NULL;
  object->__isset_debugInfo = FALSE;
}

static void 
notes_metadata_list_finalize (GObject *object)
{
  NotesMetadataList *tobject = NOTES_METADATA_LIST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->notes != NULL)
  {
    g_ptr_array_unref (tobject->notes);
    tobject->notes = NULL;
  }
  if (tobject->stoppedWords != NULL)
  {
    g_ptr_array_unref (tobject->stoppedWords);
    tobject->stoppedWords = NULL;
  }
  if (tobject->searchedWords != NULL)
  {
    g_ptr_array_unref (tobject->searchedWords);
    tobject->searchedWords = NULL;
  }
  if (tobject->searchContextBytes != NULL)
  {
    thrift_string_free(tobject->searchContextBytes);
    tobject->searchContextBytes = NULL;
  }
  if (tobject->debugInfo != NULL)
  {
    g_free(tobject->debugInfo);
    tobject->debugInfo = NULL;
  }
}

static void
notes_metadata_list_class_init (NotesMetadataListClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = notes_metadata_list_read;
  struct_class->write = notes_metadata_list_write;

  gobject_class->finalize = notes_metadata_list_finalize;
  gobject_class->get_property = notes_metadata_list_get_property;
  gobject_class->set_property = notes_metadata_list_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_LIST_START_INDEX,
     g_param_spec_int ("startIndex",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_LIST_TOTAL_NOTES,
     g_param_spec_int ("totalNotes",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_LIST_NOTES,
     g_param_spec_boxed ("notes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_LIST_STOPPED_WORDS,
     g_param_spec_boxed ("stoppedWords",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_LIST_SEARCHED_WORDS,
     g_param_spec_boxed ("searchedWords",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_LIST_UPDATE_COUNT,
     g_param_spec_int ("updateCount",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_LIST_SEARCH_CONTEXT_BYTES,
     g_param_spec_boxed ("searchContextBytes",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_LIST_DEBUG_INFO,
     g_param_spec_string ("debugInfo",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
notes_metadata_list_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NotesMetadataListClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) notes_metadata_list_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NotesMetadataList),
      0, /* n_preallocs */
      (GInstanceInitFunc) notes_metadata_list_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NotesMetadataListType",
                                   &type_info, 0);
  }

  return type;
}

enum _NotesMetadataResultSpecProperties
{
  PROP_NOTES_METADATA_RESULT_SPEC_0,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_TITLE,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_CONTENT_LENGTH,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_CREATED,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_UPDATED,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_DELETED,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_UPDATE_SEQUENCE_NUM,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_NOTEBOOK_GUID,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_TAG_GUIDS,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_ATTRIBUTES,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_LARGEST_RESOURCE_MIME,
  PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_LARGEST_RESOURCE_SIZE
};

/* reads a notes_metadata_result_spec object */
static gint32
notes_metadata_result_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NotesMetadataResultSpec * this_object = NOTES_METADATA_RESULT_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeTitle, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeTitle = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeContentLength, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeContentLength = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeCreated, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeCreated = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeUpdated, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeUpdated = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeDeleted, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeDeleted = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeUpdateSequenceNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeUpdateSequenceNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeNotebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeNotebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeTagGuids, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeTagGuids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeAttributes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeAttributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 20:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeLargestResourceMime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeLargestResourceMime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 21:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeLargestResourceSize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeLargestResourceSize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
notes_metadata_result_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NotesMetadataResultSpec * this_object = NOTES_METADATA_RESULT_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NotesMetadataResultSpec", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_includeTitle == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeTitle", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeTitle, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeContentLength == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeContentLength", T_BOOL, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeContentLength, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeCreated == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeCreated", T_BOOL, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeCreated, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeUpdated == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeUpdated", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeUpdated, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeDeleted == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeDeleted", T_BOOL, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeDeleted, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeUpdateSequenceNum == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeUpdateSequenceNum", T_BOOL, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeUpdateSequenceNum, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeNotebookGuid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeNotebookGuid", T_BOOL, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeNotebookGuid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeTagGuids == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeTagGuids", T_BOOL, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeTagGuids, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeAttributes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeAttributes", T_BOOL, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeAttributes, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeLargestResourceMime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeLargestResourceMime", T_BOOL, 20, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeLargestResourceMime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeLargestResourceSize == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeLargestResourceSize", T_BOOL, 21, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeLargestResourceSize, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
notes_metadata_result_spec_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  NotesMetadataResultSpec *self = NOTES_METADATA_RESULT_SPEC (object);

  switch (property_id)
  {
    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_TITLE:
      self->includeTitle = g_value_get_boolean (value);
      self->__isset_includeTitle = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_CONTENT_LENGTH:
      self->includeContentLength = g_value_get_boolean (value);
      self->__isset_includeContentLength = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_CREATED:
      self->includeCreated = g_value_get_boolean (value);
      self->__isset_includeCreated = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_UPDATED:
      self->includeUpdated = g_value_get_boolean (value);
      self->__isset_includeUpdated = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_DELETED:
      self->includeDeleted = g_value_get_boolean (value);
      self->__isset_includeDeleted = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_UPDATE_SEQUENCE_NUM:
      self->includeUpdateSequenceNum = g_value_get_boolean (value);
      self->__isset_includeUpdateSequenceNum = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_NOTEBOOK_GUID:
      self->includeNotebookGuid = g_value_get_boolean (value);
      self->__isset_includeNotebookGuid = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_TAG_GUIDS:
      self->includeTagGuids = g_value_get_boolean (value);
      self->__isset_includeTagGuids = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_ATTRIBUTES:
      self->includeAttributes = g_value_get_boolean (value);
      self->__isset_includeAttributes = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_LARGEST_RESOURCE_MIME:
      self->includeLargestResourceMime = g_value_get_boolean (value);
      self->__isset_includeLargestResourceMime = TRUE;
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_LARGEST_RESOURCE_SIZE:
      self->includeLargestResourceSize = g_value_get_boolean (value);
      self->__isset_includeLargestResourceSize = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
notes_metadata_result_spec_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  NotesMetadataResultSpec *self = NOTES_METADATA_RESULT_SPEC (object);

  switch (property_id)
  {
    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_TITLE:
      g_value_set_boolean (value, self->includeTitle);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_CONTENT_LENGTH:
      g_value_set_boolean (value, self->includeContentLength);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_CREATED:
      g_value_set_boolean (value, self->includeCreated);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_UPDATED:
      g_value_set_boolean (value, self->includeUpdated);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_DELETED:
      g_value_set_boolean (value, self->includeDeleted);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_UPDATE_SEQUENCE_NUM:
      g_value_set_boolean (value, self->includeUpdateSequenceNum);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_NOTEBOOK_GUID:
      g_value_set_boolean (value, self->includeNotebookGuid);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_TAG_GUIDS:
      g_value_set_boolean (value, self->includeTagGuids);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_ATTRIBUTES:
      g_value_set_boolean (value, self->includeAttributes);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_LARGEST_RESOURCE_MIME:
      g_value_set_boolean (value, self->includeLargestResourceMime);
      break;

    case PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_LARGEST_RESOURCE_SIZE:
      g_value_set_boolean (value, self->includeLargestResourceSize);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
notes_metadata_result_spec_instance_init (NotesMetadataResultSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->includeTitle = 0;
  object->__isset_includeTitle = FALSE;
  object->includeContentLength = 0;
  object->__isset_includeContentLength = FALSE;
  object->includeCreated = 0;
  object->__isset_includeCreated = FALSE;
  object->includeUpdated = 0;
  object->__isset_includeUpdated = FALSE;
  object->includeDeleted = 0;
  object->__isset_includeDeleted = FALSE;
  object->includeUpdateSequenceNum = 0;
  object->__isset_includeUpdateSequenceNum = FALSE;
  object->includeNotebookGuid = 0;
  object->__isset_includeNotebookGuid = FALSE;
  object->includeTagGuids = 0;
  object->__isset_includeTagGuids = FALSE;
  object->includeAttributes = 0;
  object->__isset_includeAttributes = FALSE;
  object->includeLargestResourceMime = 0;
  object->__isset_includeLargestResourceMime = FALSE;
  object->includeLargestResourceSize = 0;
  object->__isset_includeLargestResourceSize = FALSE;
}

static void 
notes_metadata_result_spec_finalize (GObject *object)
{
  NotesMetadataResultSpec *tobject = NOTES_METADATA_RESULT_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
notes_metadata_result_spec_class_init (NotesMetadataResultSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = notes_metadata_result_spec_read;
  struct_class->write = notes_metadata_result_spec_write;

  gobject_class->finalize = notes_metadata_result_spec_finalize;
  gobject_class->get_property = notes_metadata_result_spec_get_property;
  gobject_class->set_property = notes_metadata_result_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_TITLE,
     g_param_spec_boolean ("includeTitle",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_CONTENT_LENGTH,
     g_param_spec_boolean ("includeContentLength",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_CREATED,
     g_param_spec_boolean ("includeCreated",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_UPDATED,
     g_param_spec_boolean ("includeUpdated",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_DELETED,
     g_param_spec_boolean ("includeDeleted",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_UPDATE_SEQUENCE_NUM,
     g_param_spec_boolean ("includeUpdateSequenceNum",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_NOTEBOOK_GUID,
     g_param_spec_boolean ("includeNotebookGuid",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_TAG_GUIDS,
     g_param_spec_boolean ("includeTagGuids",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_ATTRIBUTES,
     g_param_spec_boolean ("includeAttributes",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_LARGEST_RESOURCE_MIME,
     g_param_spec_boolean ("includeLargestResourceMime",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTES_METADATA_RESULT_SPEC_INCLUDE_LARGEST_RESOURCE_SIZE,
     g_param_spec_boolean ("includeLargestResourceSize",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
notes_metadata_result_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NotesMetadataResultSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) notes_metadata_result_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NotesMetadataResultSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) notes_metadata_result_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NotesMetadataResultSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteCollectionCountsProperties
{
  PROP_NOTE_COLLECTION_COUNTS_0,
  PROP_NOTE_COLLECTION_COUNTS_NOTEBOOK_COUNTS,
  PROP_NOTE_COLLECTION_COUNTS_TAG_COUNTS,
  PROP_NOTE_COLLECTION_COUNTS_TRASH_COUNT
};

/* reads a note_collection_counts object */
static gint32
note_collection_counts_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteCollectionCounts * this_object = NOTE_COLLECTION_COUNTS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Guid key39 = NULL;
              gint32* val40 = g_new (gint32, 1);
              if (key39 != NULL)
              {
                g_free(key39);
                key39 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key39, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val40, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->notebookCounts && key39)
                g_hash_table_insert ((GHashTable *)this_object->notebookCounts, (gpointer) key39, (gpointer) val40);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_notebookCounts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              Guid key41 = NULL;
              gint32* val42 = g_new (gint32, 1);
              if (key41 != NULL)
              {
                g_free(key41);
                key41 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key41, error)) < 0)
                return -1;
              xfer += ret;
              if ((ret = thrift_protocol_read_i32 (protocol, &*val42, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->tagCounts && key41)
                g_hash_table_insert ((GHashTable *)this_object->tagCounts, (gpointer) key41, (gpointer) val42);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_tagCounts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->trashCount, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_trashCount = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_collection_counts_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteCollectionCounts * this_object = NOTE_COLLECTION_COUNTS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteCollectionCounts", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_notebookCounts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookCounts", T_MAP, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      Guid key43 = NULL;
      gint32* val44 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Guid* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_I32, this_object->notebookCounts ? (gint32) g_hash_table_size ((GHashTable *) this_object->notebookCounts) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->notebookCounts)
        g_hash_table_foreach ((GHashTable *) this_object->notebookCounts, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Guid, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Guid) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key43 = keys[i];
        val44 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->notebookCounts), (gpointer) key43);

        if ((ret = thrift_protocol_write_string (protocol,  key43, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_i32 (protocol, * val44, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_tagCounts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tagCounts", T_MAP, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      Guid key45 = NULL;
      gint32* val46 = NULL;
      GList *key_list = NULL, *iter = NULL;
      Guid* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_I32, this_object->tagCounts ? (gint32) g_hash_table_size ((GHashTable *) this_object->tagCounts) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->tagCounts)
        g_hash_table_foreach ((GHashTable *) this_object->tagCounts, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (Guid, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (Guid) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key45 = keys[i];
        val46 = (gint32*) g_hash_table_lookup (((GHashTable *) this_object->tagCounts), (gpointer) key45);

        if ((ret = thrift_protocol_write_string (protocol,  key45, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_i32 (protocol, * val46, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_trashCount == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "trashCount", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->trashCount, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_collection_counts_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  NoteCollectionCounts *self = NOTE_COLLECTION_COUNTS (object);

  switch (property_id)
  {
    case PROP_NOTE_COLLECTION_COUNTS_NOTEBOOK_COUNTS:
      if (self->notebookCounts != NULL)
        g_hash_table_unref (self->notebookCounts);
      self->notebookCounts = g_value_dup_boxed (value);
      self->__isset_notebookCounts = TRUE;
      break;

    case PROP_NOTE_COLLECTION_COUNTS_TAG_COUNTS:
      if (self->tagCounts != NULL)
        g_hash_table_unref (self->tagCounts);
      self->tagCounts = g_value_dup_boxed (value);
      self->__isset_tagCounts = TRUE;
      break;

    case PROP_NOTE_COLLECTION_COUNTS_TRASH_COUNT:
      self->trashCount = g_value_get_int (value);
      self->__isset_trashCount = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_collection_counts_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  NoteCollectionCounts *self = NOTE_COLLECTION_COUNTS (object);

  switch (property_id)
  {
    case PROP_NOTE_COLLECTION_COUNTS_NOTEBOOK_COUNTS:
      g_value_set_boxed (value, self->notebookCounts);
      break;

    case PROP_NOTE_COLLECTION_COUNTS_TAG_COUNTS:
      g_value_set_boxed (value, self->tagCounts);
      break;

    case PROP_NOTE_COLLECTION_COUNTS_TRASH_COUNT:
      g_value_set_int (value, self->trashCount);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_collection_counts_instance_init (NoteCollectionCounts * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->notebookCounts = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_notebookCounts = FALSE;
  object->tagCounts = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_tagCounts = FALSE;
  object->trashCount = 0;
  object->__isset_trashCount = FALSE;
}

static void 
note_collection_counts_finalize (GObject *object)
{
  NoteCollectionCounts *tobject = NOTE_COLLECTION_COUNTS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->notebookCounts != NULL)
  {
    g_hash_table_destroy (tobject->notebookCounts);
    tobject->notebookCounts = NULL;
  }
  if (tobject->tagCounts != NULL)
  {
    g_hash_table_destroy (tobject->tagCounts);
    tobject->tagCounts = NULL;
  }
}

static void
note_collection_counts_class_init (NoteCollectionCountsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_collection_counts_read;
  struct_class->write = note_collection_counts_write;

  gobject_class->finalize = note_collection_counts_finalize;
  gobject_class->get_property = note_collection_counts_get_property;
  gobject_class->set_property = note_collection_counts_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_COLLECTION_COUNTS_NOTEBOOK_COUNTS,
     g_param_spec_boxed ("notebookCounts",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_COLLECTION_COUNTS_TAG_COUNTS,
     g_param_spec_boxed ("tagCounts",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_COLLECTION_COUNTS_TRASH_COUNT,
     g_param_spec_int ("trashCount",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
note_collection_counts_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteCollectionCountsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_collection_counts_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteCollectionCounts),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_collection_counts_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteCollectionCountsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteResultSpecProperties
{
  PROP_NOTE_RESULT_SPEC_0,
  PROP_NOTE_RESULT_SPEC_INCLUDE_CONTENT,
  PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_DATA,
  PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_RECOGNITION,
  PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_ALTERNATE_DATA,
  PROP_NOTE_RESULT_SPEC_INCLUDE_SHARED_NOTES,
  PROP_NOTE_RESULT_SPEC_INCLUDE_NOTE_APP_DATA_VALUES,
  PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCE_APP_DATA_VALUES,
  PROP_NOTE_RESULT_SPEC_INCLUDE_ACCOUNT_LIMITS
};

/* reads a note_result_spec object */
static gint32
note_result_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteResultSpec * this_object = NOTE_RESULT_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeContent, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeContent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeResourcesData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeResourcesData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeResourcesRecognition, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeResourcesRecognition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeResourcesAlternateData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeResourcesAlternateData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeSharedNotes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeSharedNotes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeNoteAppDataValues, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeNoteAppDataValues = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeResourceAppDataValues, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeResourceAppDataValues = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeAccountLimits, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeAccountLimits = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_result_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteResultSpec * this_object = NOTE_RESULT_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteResultSpec", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_includeContent == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeContent", T_BOOL, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeContent, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeResourcesData == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeResourcesData", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeResourcesData, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeResourcesRecognition == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeResourcesRecognition", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeResourcesRecognition, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeResourcesAlternateData == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeResourcesAlternateData", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeResourcesAlternateData, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeSharedNotes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeSharedNotes", T_BOOL, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeSharedNotes, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeNoteAppDataValues == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeNoteAppDataValues", T_BOOL, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeNoteAppDataValues, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeResourceAppDataValues == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeResourceAppDataValues", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeResourceAppDataValues, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeAccountLimits == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeAccountLimits", T_BOOL, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeAccountLimits, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_result_spec_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  NoteResultSpec *self = NOTE_RESULT_SPEC (object);

  switch (property_id)
  {
    case PROP_NOTE_RESULT_SPEC_INCLUDE_CONTENT:
      self->includeContent = g_value_get_boolean (value);
      self->__isset_includeContent = TRUE;
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_DATA:
      self->includeResourcesData = g_value_get_boolean (value);
      self->__isset_includeResourcesData = TRUE;
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_RECOGNITION:
      self->includeResourcesRecognition = g_value_get_boolean (value);
      self->__isset_includeResourcesRecognition = TRUE;
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_ALTERNATE_DATA:
      self->includeResourcesAlternateData = g_value_get_boolean (value);
      self->__isset_includeResourcesAlternateData = TRUE;
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_SHARED_NOTES:
      self->includeSharedNotes = g_value_get_boolean (value);
      self->__isset_includeSharedNotes = TRUE;
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_NOTE_APP_DATA_VALUES:
      self->includeNoteAppDataValues = g_value_get_boolean (value);
      self->__isset_includeNoteAppDataValues = TRUE;
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCE_APP_DATA_VALUES:
      self->includeResourceAppDataValues = g_value_get_boolean (value);
      self->__isset_includeResourceAppDataValues = TRUE;
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_ACCOUNT_LIMITS:
      self->includeAccountLimits = g_value_get_boolean (value);
      self->__isset_includeAccountLimits = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_result_spec_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  NoteResultSpec *self = NOTE_RESULT_SPEC (object);

  switch (property_id)
  {
    case PROP_NOTE_RESULT_SPEC_INCLUDE_CONTENT:
      g_value_set_boolean (value, self->includeContent);
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_DATA:
      g_value_set_boolean (value, self->includeResourcesData);
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_RECOGNITION:
      g_value_set_boolean (value, self->includeResourcesRecognition);
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_ALTERNATE_DATA:
      g_value_set_boolean (value, self->includeResourcesAlternateData);
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_SHARED_NOTES:
      g_value_set_boolean (value, self->includeSharedNotes);
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_NOTE_APP_DATA_VALUES:
      g_value_set_boolean (value, self->includeNoteAppDataValues);
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCE_APP_DATA_VALUES:
      g_value_set_boolean (value, self->includeResourceAppDataValues);
      break;

    case PROP_NOTE_RESULT_SPEC_INCLUDE_ACCOUNT_LIMITS:
      g_value_set_boolean (value, self->includeAccountLimits);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_result_spec_instance_init (NoteResultSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->includeContent = 0;
  object->__isset_includeContent = FALSE;
  object->includeResourcesData = 0;
  object->__isset_includeResourcesData = FALSE;
  object->includeResourcesRecognition = 0;
  object->__isset_includeResourcesRecognition = FALSE;
  object->includeResourcesAlternateData = 0;
  object->__isset_includeResourcesAlternateData = FALSE;
  object->includeSharedNotes = 0;
  object->__isset_includeSharedNotes = FALSE;
  object->includeNoteAppDataValues = 0;
  object->__isset_includeNoteAppDataValues = FALSE;
  object->includeResourceAppDataValues = 0;
  object->__isset_includeResourceAppDataValues = FALSE;
  object->includeAccountLimits = 0;
  object->__isset_includeAccountLimits = FALSE;
}

static void 
note_result_spec_finalize (GObject *object)
{
  NoteResultSpec *tobject = NOTE_RESULT_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
note_result_spec_class_init (NoteResultSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_result_spec_read;
  struct_class->write = note_result_spec_write;

  gobject_class->finalize = note_result_spec_finalize;
  gobject_class->get_property = note_result_spec_get_property;
  gobject_class->set_property = note_result_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_RESULT_SPEC_INCLUDE_CONTENT,
     g_param_spec_boolean ("includeContent",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_DATA,
     g_param_spec_boolean ("includeResourcesData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_RECOGNITION,
     g_param_spec_boolean ("includeResourcesRecognition",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCES_ALTERNATE_DATA,
     g_param_spec_boolean ("includeResourcesAlternateData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_RESULT_SPEC_INCLUDE_SHARED_NOTES,
     g_param_spec_boolean ("includeSharedNotes",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_RESULT_SPEC_INCLUDE_NOTE_APP_DATA_VALUES,
     g_param_spec_boolean ("includeNoteAppDataValues",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_RESULT_SPEC_INCLUDE_RESOURCE_APP_DATA_VALUES,
     g_param_spec_boolean ("includeResourceAppDataValues",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_RESULT_SPEC_INCLUDE_ACCOUNT_LIMITS,
     g_param_spec_boolean ("includeAccountLimits",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_result_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteResultSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_result_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteResultSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_result_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteResultSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteEmailParametersProperties
{
  PROP_NOTE_EMAIL_PARAMETERS_0,
  PROP_NOTE_EMAIL_PARAMETERS_GUID,
  PROP_NOTE_EMAIL_PARAMETERS_NOTE,
  PROP_NOTE_EMAIL_PARAMETERS_TO_ADDRESSES,
  PROP_NOTE_EMAIL_PARAMETERS_CC_ADDRESSES,
  PROP_NOTE_EMAIL_PARAMETERS_SUBJECT,
  PROP_NOTE_EMAIL_PARAMETERS_MESSAGE
};

/* reads a note_email_parameters object */
static gint32
note_email_parameters_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteEmailParameters * this_object = NOTE_EMAIL_PARAMETERS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_note = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem47 = NULL;
              if (_elem47 != NULL)
              {
                g_free(_elem47);
                _elem47 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem47, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->toAddresses, _elem47);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_toAddresses = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem48 = NULL;
              if (_elem48 != NULL)
              {
                g_free(_elem48);
                _elem48 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem48, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->ccAddresses, _elem48);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_ccAddresses = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->subject != NULL)
          {
            g_free(this_object->subject);
            this_object->subject = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->subject, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_subject = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_email_parameters_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteEmailParameters * this_object = NOTE_EMAIL_PARAMETERS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteEmailParameters", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_guid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_note == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "note", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_toAddresses == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "toAddresses", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i49;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->toAddresses ? this_object->toAddresses->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i49 = 0; i49 < (this_object->toAddresses ? this_object->toAddresses->len : 0); i49++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->toAddresses, i49)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ccAddresses == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ccAddresses", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i50;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->ccAddresses ? this_object->ccAddresses->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i50 = 0; i50 < (this_object->ccAddresses ? this_object->ccAddresses->len : 0); i50++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->ccAddresses, i50)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_subject == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "subject", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->subject, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_message == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_email_parameters_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  NoteEmailParameters *self = NOTE_EMAIL_PARAMETERS (object);

  switch (property_id)
  {
    case PROP_NOTE_EMAIL_PARAMETERS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_NOTE:
      if (self->note != NULL)
        g_object_unref (self->note);
      self->note = g_value_dup_object (value);
      self->__isset_note = TRUE;
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_TO_ADDRESSES:
      if (self->toAddresses != NULL)
        g_ptr_array_unref (self->toAddresses);
      self->toAddresses = g_value_dup_boxed (value);
      self->__isset_toAddresses = TRUE;
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_CC_ADDRESSES:
      if (self->ccAddresses != NULL)
        g_ptr_array_unref (self->ccAddresses);
      self->ccAddresses = g_value_dup_boxed (value);
      self->__isset_ccAddresses = TRUE;
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_SUBJECT:
      if (self->subject != NULL)
        g_free (self->subject);
      self->subject = g_value_dup_string (value);
      self->__isset_subject = TRUE;
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_email_parameters_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  NoteEmailParameters *self = NOTE_EMAIL_PARAMETERS (object);

  switch (property_id)
  {
    case PROP_NOTE_EMAIL_PARAMETERS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_NOTE:
      g_value_set_object (value, self->note);
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_TO_ADDRESSES:
      g_value_set_boxed (value, self->toAddresses);
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_CC_ADDRESSES:
      g_value_set_boxed (value, self->ccAddresses);
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_SUBJECT:
      g_value_set_string (value, self->subject);
      break;

    case PROP_NOTE_EMAIL_PARAMETERS_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_email_parameters_instance_init (NoteEmailParameters * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->note = g_object_new (TYPE_NOTE, NULL);
  object->__isset_note = FALSE;
  object->toAddresses = g_ptr_array_new_with_free_func (g_free);
  object->__isset_toAddresses = FALSE;
  object->ccAddresses = g_ptr_array_new_with_free_func (g_free);
  object->__isset_ccAddresses = FALSE;
  object->subject = NULL;
  object->__isset_subject = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
note_email_parameters_finalize (GObject *object)
{
  NoteEmailParameters *tobject = NOTE_EMAIL_PARAMETERS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->note != NULL)
  {
    g_object_unref(tobject->note);
    tobject->note = NULL;
  }
  if (tobject->toAddresses != NULL)
  {
    g_ptr_array_unref (tobject->toAddresses);
    tobject->toAddresses = NULL;
  }
  if (tobject->ccAddresses != NULL)
  {
    g_ptr_array_unref (tobject->ccAddresses);
    tobject->ccAddresses = NULL;
  }
  if (tobject->subject != NULL)
  {
    g_free(tobject->subject);
    tobject->subject = NULL;
  }
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
note_email_parameters_class_init (NoteEmailParametersClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_email_parameters_read;
  struct_class->write = note_email_parameters_write;

  gobject_class->finalize = note_email_parameters_finalize;
  gobject_class->get_property = note_email_parameters_get_property;
  gobject_class->set_property = note_email_parameters_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_EMAIL_PARAMETERS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_EMAIL_PARAMETERS_NOTE,
     g_param_spec_object ("note",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_EMAIL_PARAMETERS_TO_ADDRESSES,
     g_param_spec_boxed ("toAddresses",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_EMAIL_PARAMETERS_CC_ADDRESSES,
     g_param_spec_boxed ("ccAddresses",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_EMAIL_PARAMETERS_SUBJECT,
     g_param_spec_string ("subject",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_EMAIL_PARAMETERS_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_email_parameters_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteEmailParametersClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_email_parameters_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteEmailParameters),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_email_parameters_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteEmailParametersType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteVersionIdProperties
{
  PROP_NOTE_VERSION_ID_0,
  PROP_NOTE_VERSION_ID_UPDATE_SEQUENCE_NUM,
  PROP_NOTE_VERSION_ID_UPDATED,
  PROP_NOTE_VERSION_ID_SAVED,
  PROP_NOTE_VERSION_ID_TITLE,
  PROP_NOTE_VERSION_ID_LAST_EDITOR_ID
};

/* reads a note_version_id object */
static gint32
note_version_id_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteVersionId * this_object = NOTE_VERSION_ID(object);
  gboolean isset_updateSequenceNum = FALSE;
  gboolean isset_updated = FALSE;
  gboolean isset_saved = FALSE;
  gboolean isset_title = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->updateSequenceNum, error)) < 0)
            return -1;
          xfer += ret;
          isset_updateSequenceNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updated, error)) < 0)
            return -1;
          xfer += ret;
          isset_updated = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->saved, error)) < 0)
            return -1;
          xfer += ret;
          isset_saved = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->title != NULL)
          {
            g_free(this_object->title);
            this_object->title = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->title, error)) < 0)
            return -1;
          xfer += ret;
          isset_title = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->lastEditorId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_lastEditorId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_updateSequenceNum)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_updated)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_saved)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_title)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
note_version_id_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteVersionId * this_object = NOTE_VERSION_ID(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteVersionId", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updateSequenceNum", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->updateSequenceNum, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updated", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->updated, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "saved", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->saved, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "title", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->title, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_lastEditorId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "lastEditorId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->lastEditorId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_version_id_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  NoteVersionId *self = NOTE_VERSION_ID (object);

  switch (property_id)
  {
    case PROP_NOTE_VERSION_ID_UPDATE_SEQUENCE_NUM:
      self->updateSequenceNum = g_value_get_int (value);
      break;

    case PROP_NOTE_VERSION_ID_UPDATED:
      self->updated = g_value_get_int64 (value);
      break;

    case PROP_NOTE_VERSION_ID_SAVED:
      self->saved = g_value_get_int64 (value);
      break;

    case PROP_NOTE_VERSION_ID_TITLE:
      if (self->title != NULL)
        g_free (self->title);
      self->title = g_value_dup_string (value);
      break;

    case PROP_NOTE_VERSION_ID_LAST_EDITOR_ID:
      self->lastEditorId = g_value_get_int (value);
      self->__isset_lastEditorId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_version_id_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  NoteVersionId *self = NOTE_VERSION_ID (object);

  switch (property_id)
  {
    case PROP_NOTE_VERSION_ID_UPDATE_SEQUENCE_NUM:
      g_value_set_int (value, self->updateSequenceNum);
      break;

    case PROP_NOTE_VERSION_ID_UPDATED:
      g_value_set_int64 (value, self->updated);
      break;

    case PROP_NOTE_VERSION_ID_SAVED:
      g_value_set_int64 (value, self->saved);
      break;

    case PROP_NOTE_VERSION_ID_TITLE:
      g_value_set_string (value, self->title);
      break;

    case PROP_NOTE_VERSION_ID_LAST_EDITOR_ID:
      g_value_set_int (value, self->lastEditorId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_version_id_instance_init (NoteVersionId * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->updateSequenceNum = 0;
  object->updated = 0;
  object->saved = 0;
  object->title = NULL;
  object->lastEditorId = 0;
  object->__isset_lastEditorId = FALSE;
}

static void 
note_version_id_finalize (GObject *object)
{
  NoteVersionId *tobject = NOTE_VERSION_ID (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->title != NULL)
  {
    g_free(tobject->title);
    tobject->title = NULL;
  }
}

static void
note_version_id_class_init (NoteVersionIdClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_version_id_read;
  struct_class->write = note_version_id_write;

  gobject_class->finalize = note_version_id_finalize;
  gobject_class->get_property = note_version_id_get_property;
  gobject_class->set_property = note_version_id_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_VERSION_ID_UPDATE_SEQUENCE_NUM,
     g_param_spec_int ("updateSequenceNum",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_VERSION_ID_UPDATED,
     g_param_spec_int64 ("updated",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_VERSION_ID_SAVED,
     g_param_spec_int64 ("saved",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_VERSION_ID_TITLE,
     g_param_spec_string ("title",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_VERSION_ID_LAST_EDITOR_ID,
     g_param_spec_int ("lastEditorId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
note_version_id_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteVersionIdClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_version_id_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteVersionId),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_version_id_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteVersionIdType",
                                   &type_info, 0);
  }

  return type;
}

enum _RelatedQueryProperties
{
  PROP_RELATED_QUERY_0,
  PROP_RELATED_QUERY_NOTE_GUID,
  PROP_RELATED_QUERY_PLAIN_TEXT,
  PROP_RELATED_QUERY_FILTER,
  PROP_RELATED_QUERY_REFERENCE_URI,
  PROP_RELATED_QUERY_CONTEXT,
  PROP_RELATED_QUERY_CACHE_KEY
};

/* reads a related_query object */
static gint32
related_query_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RelatedQuery * this_object = RELATED_QUERY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->noteGuid != NULL)
          {
            g_free(this_object->noteGuid);
            this_object->noteGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->plainText != NULL)
          {
            g_free(this_object->plainText);
            this_object->plainText = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->plainText, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_plainText = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->referenceUri != NULL)
          {
            g_free(this_object->referenceUri);
            this_object->referenceUri = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->referenceUri, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_referenceUri = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->context != NULL)
          {
            g_free(this_object->context);
            this_object->context = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->context, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_context = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->cacheKey != NULL)
          {
            g_free(this_object->cacheKey);
            this_object->cacheKey = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cacheKey, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cacheKey = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
related_query_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RelatedQuery * this_object = RELATED_QUERY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RelatedQuery", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_noteGuid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->noteGuid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_plainText == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "plainText", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->plainText, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_filter == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_referenceUri == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "referenceUri", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->referenceUri, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_context == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "context", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->context, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cacheKey == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cacheKey", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->cacheKey, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
related_query_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  RelatedQuery *self = RELATED_QUERY (object);

  switch (property_id)
  {
    case PROP_RELATED_QUERY_NOTE_GUID:
      if (self->noteGuid != NULL)
        g_free (self->noteGuid);
      self->noteGuid = g_value_dup_string (value);
      self->__isset_noteGuid = TRUE;
      break;

    case PROP_RELATED_QUERY_PLAIN_TEXT:
      if (self->plainText != NULL)
        g_free (self->plainText);
      self->plainText = g_value_dup_string (value);
      self->__isset_plainText = TRUE;
      break;

    case PROP_RELATED_QUERY_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    case PROP_RELATED_QUERY_REFERENCE_URI:
      if (self->referenceUri != NULL)
        g_free (self->referenceUri);
      self->referenceUri = g_value_dup_string (value);
      self->__isset_referenceUri = TRUE;
      break;

    case PROP_RELATED_QUERY_CONTEXT:
      if (self->context != NULL)
        g_free (self->context);
      self->context = g_value_dup_string (value);
      self->__isset_context = TRUE;
      break;

    case PROP_RELATED_QUERY_CACHE_KEY:
      if (self->cacheKey != NULL)
        g_free (self->cacheKey);
      self->cacheKey = g_value_dup_string (value);
      self->__isset_cacheKey = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
related_query_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  RelatedQuery *self = RELATED_QUERY (object);

  switch (property_id)
  {
    case PROP_RELATED_QUERY_NOTE_GUID:
      g_value_set_string (value, self->noteGuid);
      break;

    case PROP_RELATED_QUERY_PLAIN_TEXT:
      g_value_set_string (value, self->plainText);
      break;

    case PROP_RELATED_QUERY_FILTER:
      g_value_set_object (value, self->filter);
      break;

    case PROP_RELATED_QUERY_REFERENCE_URI:
      g_value_set_string (value, self->referenceUri);
      break;

    case PROP_RELATED_QUERY_CONTEXT:
      g_value_set_string (value, self->context);
      break;

    case PROP_RELATED_QUERY_CACHE_KEY:
      g_value_set_string (value, self->cacheKey);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
related_query_instance_init (RelatedQuery * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->noteGuid = NULL;
  object->__isset_noteGuid = FALSE;
  object->plainText = NULL;
  object->__isset_plainText = FALSE;
  object->filter = g_object_new (TYPE_NOTE_FILTER, NULL);
  object->__isset_filter = FALSE;
  object->referenceUri = NULL;
  object->__isset_referenceUri = FALSE;
  object->context = NULL;
  object->__isset_context = FALSE;
  object->cacheKey = NULL;
  object->__isset_cacheKey = FALSE;
}

static void 
related_query_finalize (GObject *object)
{
  RelatedQuery *tobject = RELATED_QUERY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->noteGuid != NULL)
  {
    g_free(tobject->noteGuid);
    tobject->noteGuid = NULL;
  }
  if (tobject->plainText != NULL)
  {
    g_free(tobject->plainText);
    tobject->plainText = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
  if (tobject->referenceUri != NULL)
  {
    g_free(tobject->referenceUri);
    tobject->referenceUri = NULL;
  }
  if (tobject->context != NULL)
  {
    g_free(tobject->context);
    tobject->context = NULL;
  }
  if (tobject->cacheKey != NULL)
  {
    g_free(tobject->cacheKey);
    tobject->cacheKey = NULL;
  }
}

static void
related_query_class_init (RelatedQueryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = related_query_read;
  struct_class->write = related_query_write;

  gobject_class->finalize = related_query_finalize;
  gobject_class->get_property = related_query_get_property;
  gobject_class->set_property = related_query_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_QUERY_NOTE_GUID,
     g_param_spec_string ("noteGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_QUERY_PLAIN_TEXT,
     g_param_spec_string ("plainText",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_QUERY_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_NOTE_FILTER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_QUERY_REFERENCE_URI,
     g_param_spec_string ("referenceUri",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_QUERY_CONTEXT,
     g_param_spec_string ("context",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_QUERY_CACHE_KEY,
     g_param_spec_string ("cacheKey",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
related_query_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RelatedQueryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) related_query_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RelatedQuery),
      0, /* n_preallocs */
      (GInstanceInitFunc) related_query_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RelatedQueryType",
                                   &type_info, 0);
  }

  return type;
}

enum _RelatedResultProperties
{
  PROP_RELATED_RESULT_0,
  PROP_RELATED_RESULT_NOTES,
  PROP_RELATED_RESULT_NOTEBOOKS,
  PROP_RELATED_RESULT_TAGS,
  PROP_RELATED_RESULT_CONTAINING_NOTEBOOKS,
  PROP_RELATED_RESULT_DEBUG_INFO,
  PROP_RELATED_RESULT_EXPERTS,
  PROP_RELATED_RESULT_RELATED_CONTENT,
  PROP_RELATED_RESULT_CACHE_KEY,
  PROP_RELATED_RESULT_CACHE_EXPIRES
};

/* reads a related_result object */
static gint32
related_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RelatedResult * this_object = RELATED_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Note * _elem51 = NULL;
              if ( _elem51 != NULL)
              {
                g_object_unref (_elem51);
              }
              _elem51 = g_object_new (TYPE_NOTE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem51), protocol, error)) < 0)
              {
                g_object_unref (_elem51);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->notes, _elem51);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_notes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Notebook * _elem52 = NULL;
              if ( _elem52 != NULL)
              {
                g_object_unref (_elem52);
              }
              _elem52 = g_object_new (TYPE_NOTEBOOK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem52), protocol, error)) < 0)
              {
                g_object_unref (_elem52);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->notebooks, _elem52);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_notebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Tag * _elem53 = NULL;
              if ( _elem53 != NULL)
              {
                g_object_unref (_elem53);
              }
              _elem53 = g_object_new (TYPE_TAG, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem53), protocol, error)) < 0)
              {
                g_object_unref (_elem53);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->tags, _elem53);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_tags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              NotebookDescriptor * _elem54 = NULL;
              if ( _elem54 != NULL)
              {
                g_object_unref (_elem54);
              }
              _elem54 = g_object_new (TYPE_NOTEBOOK_DESCRIPTOR, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem54), protocol, error)) < 0)
              {
                g_object_unref (_elem54);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->containingNotebooks, _elem54);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_containingNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->debugInfo != NULL)
          {
            g_free(this_object->debugInfo);
            this_object->debugInfo = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->debugInfo, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_debugInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              UserProfile * _elem55 = NULL;
              if ( _elem55 != NULL)
              {
                g_object_unref (_elem55);
              }
              _elem55 = g_object_new (TYPE_USER_PROFILE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem55), protocol, error)) < 0)
              {
                g_object_unref (_elem55);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->experts, _elem55);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_experts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              RelatedContent * _elem56 = NULL;
              if ( _elem56 != NULL)
              {
                g_object_unref (_elem56);
              }
              _elem56 = g_object_new (TYPE_RELATED_CONTENT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem56), protocol, error)) < 0)
              {
                g_object_unref (_elem56);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->relatedContent, _elem56);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_relatedContent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->cacheKey != NULL)
          {
            g_free(this_object->cacheKey);
            this_object->cacheKey = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cacheKey, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cacheKey = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cacheExpires, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cacheExpires = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
related_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RelatedResult * this_object = RELATED_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RelatedResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_notes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notes", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i57;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->notes ? this_object->notes->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i57 = 0; i57 < (this_object->notes ? this_object->notes->len : 0); i57++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->notes, i57))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebooks", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i58;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->notebooks ? this_object->notebooks->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i58 = 0; i58 < (this_object->notebooks ? this_object->notebooks->len : 0); i58++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->notebooks, i58))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_tags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "tags", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i59;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->tags ? this_object->tags->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i59 = 0; i59 < (this_object->tags ? this_object->tags->len : 0); i59++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->tags, i59))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_containingNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "containingNotebooks", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i60;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->containingNotebooks ? this_object->containingNotebooks->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i60 = 0; i60 < (this_object->containingNotebooks ? this_object->containingNotebooks->len : 0); i60++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->containingNotebooks, i60))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_debugInfo == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "debugInfo", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->debugInfo, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_experts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "experts", T_LIST, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i61;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->experts ? this_object->experts->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i61 = 0; i61 < (this_object->experts ? this_object->experts->len : 0); i61++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->experts, i61))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_relatedContent == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "relatedContent", T_LIST, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i62;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->relatedContent ? this_object->relatedContent->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i62 = 0; i62 < (this_object->relatedContent ? this_object->relatedContent->len : 0); i62++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->relatedContent, i62))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cacheKey == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cacheKey", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->cacheKey, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cacheExpires == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cacheExpires", T_I32, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->cacheExpires, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
related_result_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  RelatedResult *self = RELATED_RESULT (object);

  switch (property_id)
  {
    case PROP_RELATED_RESULT_NOTES:
      if (self->notes != NULL)
        g_ptr_array_unref (self->notes);
      self->notes = g_value_dup_boxed (value);
      self->__isset_notes = TRUE;
      break;

    case PROP_RELATED_RESULT_NOTEBOOKS:
      if (self->notebooks != NULL)
        g_ptr_array_unref (self->notebooks);
      self->notebooks = g_value_dup_boxed (value);
      self->__isset_notebooks = TRUE;
      break;

    case PROP_RELATED_RESULT_TAGS:
      if (self->tags != NULL)
        g_ptr_array_unref (self->tags);
      self->tags = g_value_dup_boxed (value);
      self->__isset_tags = TRUE;
      break;

    case PROP_RELATED_RESULT_CONTAINING_NOTEBOOKS:
      if (self->containingNotebooks != NULL)
        g_ptr_array_unref (self->containingNotebooks);
      self->containingNotebooks = g_value_dup_boxed (value);
      self->__isset_containingNotebooks = TRUE;
      break;

    case PROP_RELATED_RESULT_DEBUG_INFO:
      if (self->debugInfo != NULL)
        g_free (self->debugInfo);
      self->debugInfo = g_value_dup_string (value);
      self->__isset_debugInfo = TRUE;
      break;

    case PROP_RELATED_RESULT_EXPERTS:
      if (self->experts != NULL)
        g_ptr_array_unref (self->experts);
      self->experts = g_value_dup_boxed (value);
      self->__isset_experts = TRUE;
      break;

    case PROP_RELATED_RESULT_RELATED_CONTENT:
      if (self->relatedContent != NULL)
        g_ptr_array_unref (self->relatedContent);
      self->relatedContent = g_value_dup_boxed (value);
      self->__isset_relatedContent = TRUE;
      break;

    case PROP_RELATED_RESULT_CACHE_KEY:
      if (self->cacheKey != NULL)
        g_free (self->cacheKey);
      self->cacheKey = g_value_dup_string (value);
      self->__isset_cacheKey = TRUE;
      break;

    case PROP_RELATED_RESULT_CACHE_EXPIRES:
      self->cacheExpires = g_value_get_int (value);
      self->__isset_cacheExpires = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
related_result_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  RelatedResult *self = RELATED_RESULT (object);

  switch (property_id)
  {
    case PROP_RELATED_RESULT_NOTES:
      g_value_set_boxed (value, self->notes);
      break;

    case PROP_RELATED_RESULT_NOTEBOOKS:
      g_value_set_boxed (value, self->notebooks);
      break;

    case PROP_RELATED_RESULT_TAGS:
      g_value_set_boxed (value, self->tags);
      break;

    case PROP_RELATED_RESULT_CONTAINING_NOTEBOOKS:
      g_value_set_boxed (value, self->containingNotebooks);
      break;

    case PROP_RELATED_RESULT_DEBUG_INFO:
      g_value_set_string (value, self->debugInfo);
      break;

    case PROP_RELATED_RESULT_EXPERTS:
      g_value_set_boxed (value, self->experts);
      break;

    case PROP_RELATED_RESULT_RELATED_CONTENT:
      g_value_set_boxed (value, self->relatedContent);
      break;

    case PROP_RELATED_RESULT_CACHE_KEY:
      g_value_set_string (value, self->cacheKey);
      break;

    case PROP_RELATED_RESULT_CACHE_EXPIRES:
      g_value_set_int (value, self->cacheExpires);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
related_result_instance_init (RelatedResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->notes = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_notes = FALSE;
  object->notebooks = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_notebooks = FALSE;
  object->tags = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_tags = FALSE;
  object->containingNotebooks = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_containingNotebooks = FALSE;
  object->debugInfo = NULL;
  object->__isset_debugInfo = FALSE;
  object->experts = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_experts = FALSE;
  object->relatedContent = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_relatedContent = FALSE;
  object->cacheKey = NULL;
  object->__isset_cacheKey = FALSE;
  object->cacheExpires = 0;
  object->__isset_cacheExpires = FALSE;
}

static void 
related_result_finalize (GObject *object)
{
  RelatedResult *tobject = RELATED_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->notes != NULL)
  {
    g_ptr_array_unref (tobject->notes);
    tobject->notes = NULL;
  }
  if (tobject->notebooks != NULL)
  {
    g_ptr_array_unref (tobject->notebooks);
    tobject->notebooks = NULL;
  }
  if (tobject->tags != NULL)
  {
    g_ptr_array_unref (tobject->tags);
    tobject->tags = NULL;
  }
  if (tobject->containingNotebooks != NULL)
  {
    g_ptr_array_unref (tobject->containingNotebooks);
    tobject->containingNotebooks = NULL;
  }
  if (tobject->debugInfo != NULL)
  {
    g_free(tobject->debugInfo);
    tobject->debugInfo = NULL;
  }
  if (tobject->experts != NULL)
  {
    g_ptr_array_unref (tobject->experts);
    tobject->experts = NULL;
  }
  if (tobject->relatedContent != NULL)
  {
    g_ptr_array_unref (tobject->relatedContent);
    tobject->relatedContent = NULL;
  }
  if (tobject->cacheKey != NULL)
  {
    g_free(tobject->cacheKey);
    tobject->cacheKey = NULL;
  }
}

static void
related_result_class_init (RelatedResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = related_result_read;
  struct_class->write = related_result_write;

  gobject_class->finalize = related_result_finalize;
  gobject_class->get_property = related_result_get_property;
  gobject_class->set_property = related_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_NOTES,
     g_param_spec_boxed ("notes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_NOTEBOOKS,
     g_param_spec_boxed ("notebooks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_TAGS,
     g_param_spec_boxed ("tags",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_CONTAINING_NOTEBOOKS,
     g_param_spec_boxed ("containingNotebooks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_DEBUG_INFO,
     g_param_spec_string ("debugInfo",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_EXPERTS,
     g_param_spec_boxed ("experts",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_RELATED_CONTENT,
     g_param_spec_boxed ("relatedContent",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_CACHE_KEY,
     g_param_spec_string ("cacheKey",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_CACHE_EXPIRES,
     g_param_spec_int ("cacheExpires",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
related_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RelatedResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) related_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RelatedResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) related_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RelatedResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _RelatedResultSpecProperties
{
  PROP_RELATED_RESULT_SPEC_0,
  PROP_RELATED_RESULT_SPEC_MAX_NOTES,
  PROP_RELATED_RESULT_SPEC_MAX_NOTEBOOKS,
  PROP_RELATED_RESULT_SPEC_MAX_TAGS,
  PROP_RELATED_RESULT_SPEC_WRITABLE_NOTEBOOKS_ONLY,
  PROP_RELATED_RESULT_SPEC_INCLUDE_CONTAINING_NOTEBOOKS,
  PROP_RELATED_RESULT_SPEC_INCLUDE_DEBUG_INFO,
  PROP_RELATED_RESULT_SPEC_MAX_EXPERTS,
  PROP_RELATED_RESULT_SPEC_MAX_RELATED_CONTENT,
  PROP_RELATED_RESULT_SPEC_RELATED_CONTENT_TYPES
};

/* reads a related_result_spec object */
static gint32
related_result_spec_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RelatedResultSpec * this_object = RELATED_RESULT_SPEC(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxNotes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxNotes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxNotebooks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxTags, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxTags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->writableNotebooksOnly, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_writableNotebooksOnly = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeContainingNotebooks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeContainingNotebooks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->includeDebugInfo, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_includeDebugInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxExperts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxExperts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxRelatedContent, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxRelatedContent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_SET)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_set_begin (protocol, &element_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through the set elements */
            for (i = 0; i < size; ++i)
            {
              RelatedContentType _elem63;
              gint32 ecast64;
              if ((ret = thrift_protocol_read_i32 (protocol, &ecast64, error)) < 0)
                return -1;
              xfer += ret;
              _elem63 = (RelatedContentType)ecast64;
              if (this_object->relatedContentTypes && _elem63)
                g_hash_table_insert ((GHashTable *) this_object->relatedContentTypes, (gpointer) _elem63, (gpointer) _elem63);
            }
            if ((ret = thrift_protocol_read_set_end (protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          this_object->__isset_relatedContentTypes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
related_result_spec_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RelatedResultSpec * this_object = RELATED_RESULT_SPEC(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RelatedResultSpec", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_maxNotes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxNotes", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxNotes, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxNotebooks", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxNotebooks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxTags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxTags", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxTags, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_writableNotebooksOnly == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "writableNotebooksOnly", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->writableNotebooksOnly, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeContainingNotebooks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeContainingNotebooks", T_BOOL, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeContainingNotebooks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_includeDebugInfo == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "includeDebugInfo", T_BOOL, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->includeDebugInfo, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxExperts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxExperts", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxExperts, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_maxRelatedContent == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxRelatedContent", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxRelatedContent, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_relatedContentTypes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "relatedContentTypes", T_SET, 9, error)) < 0)
      return -1;
    xfer += ret;
    {
      GList *key_list = NULL, *iter = NULL;
      RelatedContentType* keys;
      int i = 0, key_count;
      RelatedContentType elem;
      gpointer value;
      THRIFT_UNUSED_VAR (value);

      if ((ret = thrift_protocol_write_set_begin (protocol, T_I32, this_object->relatedContentTypes ? (gint32) g_hash_table_size ((GHashTable *) this_object->relatedContentTypes) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->relatedContentTypes)
        g_hash_table_foreach ((GHashTable *) this_object->relatedContentTypes, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (RelatedContentType, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (RelatedContentType) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        elem = keys[i];
        value = (gpointer) g_hash_table_lookup (((GHashTable *) this_object->relatedContentTypes), (gpointer) elem);

        if ((ret = thrift_protocol_write_i32 (protocol, (gint32) elem, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_set_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
related_result_spec_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  RelatedResultSpec *self = RELATED_RESULT_SPEC (object);

  switch (property_id)
  {
    case PROP_RELATED_RESULT_SPEC_MAX_NOTES:
      self->maxNotes = g_value_get_int (value);
      self->__isset_maxNotes = TRUE;
      break;

    case PROP_RELATED_RESULT_SPEC_MAX_NOTEBOOKS:
      self->maxNotebooks = g_value_get_int (value);
      self->__isset_maxNotebooks = TRUE;
      break;

    case PROP_RELATED_RESULT_SPEC_MAX_TAGS:
      self->maxTags = g_value_get_int (value);
      self->__isset_maxTags = TRUE;
      break;

    case PROP_RELATED_RESULT_SPEC_WRITABLE_NOTEBOOKS_ONLY:
      self->writableNotebooksOnly = g_value_get_boolean (value);
      self->__isset_writableNotebooksOnly = TRUE;
      break;

    case PROP_RELATED_RESULT_SPEC_INCLUDE_CONTAINING_NOTEBOOKS:
      self->includeContainingNotebooks = g_value_get_boolean (value);
      self->__isset_includeContainingNotebooks = TRUE;
      break;

    case PROP_RELATED_RESULT_SPEC_INCLUDE_DEBUG_INFO:
      self->includeDebugInfo = g_value_get_boolean (value);
      self->__isset_includeDebugInfo = TRUE;
      break;

    case PROP_RELATED_RESULT_SPEC_MAX_EXPERTS:
      self->maxExperts = g_value_get_int (value);
      self->__isset_maxExperts = TRUE;
      break;

    case PROP_RELATED_RESULT_SPEC_MAX_RELATED_CONTENT:
      self->maxRelatedContent = g_value_get_int (value);
      self->__isset_maxRelatedContent = TRUE;
      break;

    case PROP_RELATED_RESULT_SPEC_RELATED_CONTENT_TYPES:
      if (self->relatedContentTypes != NULL)
        g_hash_table_unref (self->relatedContentTypes);
      self->relatedContentTypes = g_value_dup_boxed (value);
      self->__isset_relatedContentTypes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
related_result_spec_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  RelatedResultSpec *self = RELATED_RESULT_SPEC (object);

  switch (property_id)
  {
    case PROP_RELATED_RESULT_SPEC_MAX_NOTES:
      g_value_set_int (value, self->maxNotes);
      break;

    case PROP_RELATED_RESULT_SPEC_MAX_NOTEBOOKS:
      g_value_set_int (value, self->maxNotebooks);
      break;

    case PROP_RELATED_RESULT_SPEC_MAX_TAGS:
      g_value_set_int (value, self->maxTags);
      break;

    case PROP_RELATED_RESULT_SPEC_WRITABLE_NOTEBOOKS_ONLY:
      g_value_set_boolean (value, self->writableNotebooksOnly);
      break;

    case PROP_RELATED_RESULT_SPEC_INCLUDE_CONTAINING_NOTEBOOKS:
      g_value_set_boolean (value, self->includeContainingNotebooks);
      break;

    case PROP_RELATED_RESULT_SPEC_INCLUDE_DEBUG_INFO:
      g_value_set_boolean (value, self->includeDebugInfo);
      break;

    case PROP_RELATED_RESULT_SPEC_MAX_EXPERTS:
      g_value_set_int (value, self->maxExperts);
      break;

    case PROP_RELATED_RESULT_SPEC_MAX_RELATED_CONTENT:
      g_value_set_int (value, self->maxRelatedContent);
      break;

    case PROP_RELATED_RESULT_SPEC_RELATED_CONTENT_TYPES:
      g_value_set_boxed (value, self->relatedContentTypes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
related_result_spec_instance_init (RelatedResultSpec * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->maxNotes = 0;
  object->__isset_maxNotes = FALSE;
  object->maxNotebooks = 0;
  object->__isset_maxNotebooks = FALSE;
  object->maxTags = 0;
  object->__isset_maxTags = FALSE;
  object->writableNotebooksOnly = 0;
  object->__isset_writableNotebooksOnly = FALSE;
  object->includeContainingNotebooks = 0;
  object->__isset_includeContainingNotebooks = FALSE;
  object->includeDebugInfo = 0;
  object->__isset_includeDebugInfo = FALSE;
  object->maxExperts = 0;
  object->__isset_maxExperts = FALSE;
  object->maxRelatedContent = 0;
  object->__isset_maxRelatedContent = FALSE;
  object->relatedContentTypes = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, NULL);
  object->__isset_relatedContentTypes = FALSE;
}

static void 
related_result_spec_finalize (GObject *object)
{
  RelatedResultSpec *tobject = RELATED_RESULT_SPEC (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->relatedContentTypes != NULL)
  {
    g_hash_table_destroy (tobject->relatedContentTypes);
    tobject->relatedContentTypes = NULL;
  }
}

static void
related_result_spec_class_init (RelatedResultSpecClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = related_result_spec_read;
  struct_class->write = related_result_spec_write;

  gobject_class->finalize = related_result_spec_finalize;
  gobject_class->get_property = related_result_spec_get_property;
  gobject_class->set_property = related_result_spec_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_MAX_NOTES,
     g_param_spec_int ("maxNotes",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_MAX_NOTEBOOKS,
     g_param_spec_int ("maxNotebooks",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_MAX_TAGS,
     g_param_spec_int ("maxTags",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_WRITABLE_NOTEBOOKS_ONLY,
     g_param_spec_boolean ("writableNotebooksOnly",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_INCLUDE_CONTAINING_NOTEBOOKS,
     g_param_spec_boolean ("includeContainingNotebooks",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_INCLUDE_DEBUG_INFO,
     g_param_spec_boolean ("includeDebugInfo",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_MAX_EXPERTS,
     g_param_spec_int ("maxExperts",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_MAX_RELATED_CONTENT,
     g_param_spec_int ("maxRelatedContent",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RELATED_RESULT_SPEC_RELATED_CONTENT_TYPES,
     g_param_spec_boxed ("relatedContentTypes",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));
}

GType
related_result_spec_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RelatedResultSpecClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) related_result_spec_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RelatedResultSpec),
      0, /* n_preallocs */
      (GInstanceInitFunc) related_result_spec_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RelatedResultSpecType",
                                   &type_info, 0);
  }

  return type;
}

enum _UpdateNoteIfUsnMatchesResultProperties
{
  PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_0,
  PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_NOTE,
  PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_UPDATED
};

/* reads a update_note_if_usn_matches_result object */
static gint32
update_note_if_usn_matches_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UpdateNoteIfUsnMatchesResult * this_object = UPDATE_NOTE_IF_USN_MATCHES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_note = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->updated, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updated = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
update_note_if_usn_matches_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UpdateNoteIfUsnMatchesResult * this_object = UPDATE_NOTE_IF_USN_MATCHES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UpdateNoteIfUsnMatchesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_note == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "note", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updated == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updated", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->updated, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
update_note_if_usn_matches_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  UpdateNoteIfUsnMatchesResult *self = UPDATE_NOTE_IF_USN_MATCHES_RESULT (object);

  switch (property_id)
  {
    case PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_NOTE:
      if (self->note != NULL)
        g_object_unref (self->note);
      self->note = g_value_dup_object (value);
      self->__isset_note = TRUE;
      break;

    case PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_UPDATED:
      self->updated = g_value_get_boolean (value);
      self->__isset_updated = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
update_note_if_usn_matches_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  UpdateNoteIfUsnMatchesResult *self = UPDATE_NOTE_IF_USN_MATCHES_RESULT (object);

  switch (property_id)
  {
    case PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_NOTE:
      g_value_set_object (value, self->note);
      break;

    case PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_UPDATED:
      g_value_set_boolean (value, self->updated);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
update_note_if_usn_matches_result_instance_init (UpdateNoteIfUsnMatchesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->note = g_object_new (TYPE_NOTE, NULL);
  object->__isset_note = FALSE;
  object->updated = 0;
  object->__isset_updated = FALSE;
}

static void 
update_note_if_usn_matches_result_finalize (GObject *object)
{
  UpdateNoteIfUsnMatchesResult *tobject = UPDATE_NOTE_IF_USN_MATCHES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->note != NULL)
  {
    g_object_unref(tobject->note);
    tobject->note = NULL;
  }
}

static void
update_note_if_usn_matches_result_class_init (UpdateNoteIfUsnMatchesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = update_note_if_usn_matches_result_read;
  struct_class->write = update_note_if_usn_matches_result_write;

  gobject_class->finalize = update_note_if_usn_matches_result_finalize;
  gobject_class->get_property = update_note_if_usn_matches_result_get_property;
  gobject_class->set_property = update_note_if_usn_matches_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_NOTE,
     g_param_spec_object ("note",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_NOTE_IF_USN_MATCHES_RESULT_UPDATED,
     g_param_spec_boolean ("updated",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
update_note_if_usn_matches_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UpdateNoteIfUsnMatchesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) update_note_if_usn_matches_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UpdateNoteIfUsnMatchesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) update_note_if_usn_matches_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UpdateNoteIfUsnMatchesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ShareRelationshipRestrictionsProperties
{
  PROP_SHARE_RELATIONSHIP_RESTRICTIONS_0,
  PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_ONLY,
  PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_PLUS_ACTIVITY,
  PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_MODIFY,
  PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_FULL_ACCESS
};

/* reads a share_relationship_restrictions object */
static gint32
share_relationship_restrictions_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ShareRelationshipRestrictions * this_object = SHARE_RELATIONSHIP_RESTRICTIONS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->noSetReadOnly, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noSetReadOnly = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->noSetReadPlusActivity, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noSetReadPlusActivity = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->noSetModify, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noSetModify = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->noSetFullAccess, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noSetFullAccess = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
share_relationship_restrictions_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ShareRelationshipRestrictions * this_object = SHARE_RELATIONSHIP_RESTRICTIONS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ShareRelationshipRestrictions", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_noSetReadOnly == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noSetReadOnly", T_BOOL, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->noSetReadOnly, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noSetReadPlusActivity == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noSetReadPlusActivity", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->noSetReadPlusActivity, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noSetModify == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noSetModify", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->noSetModify, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noSetFullAccess == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noSetFullAccess", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->noSetFullAccess, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
share_relationship_restrictions_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  ShareRelationshipRestrictions *self = SHARE_RELATIONSHIP_RESTRICTIONS (object);

  switch (property_id)
  {
    case PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_ONLY:
      self->noSetReadOnly = g_value_get_boolean (value);
      self->__isset_noSetReadOnly = TRUE;
      break;

    case PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_PLUS_ACTIVITY:
      self->noSetReadPlusActivity = g_value_get_boolean (value);
      self->__isset_noSetReadPlusActivity = TRUE;
      break;

    case PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_MODIFY:
      self->noSetModify = g_value_get_boolean (value);
      self->__isset_noSetModify = TRUE;
      break;

    case PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_FULL_ACCESS:
      self->noSetFullAccess = g_value_get_boolean (value);
      self->__isset_noSetFullAccess = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
share_relationship_restrictions_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  ShareRelationshipRestrictions *self = SHARE_RELATIONSHIP_RESTRICTIONS (object);

  switch (property_id)
  {
    case PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_ONLY:
      g_value_set_boolean (value, self->noSetReadOnly);
      break;

    case PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_PLUS_ACTIVITY:
      g_value_set_boolean (value, self->noSetReadPlusActivity);
      break;

    case PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_MODIFY:
      g_value_set_boolean (value, self->noSetModify);
      break;

    case PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_FULL_ACCESS:
      g_value_set_boolean (value, self->noSetFullAccess);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
share_relationship_restrictions_instance_init (ShareRelationshipRestrictions * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->noSetReadOnly = 0;
  object->__isset_noSetReadOnly = FALSE;
  object->noSetReadPlusActivity = 0;
  object->__isset_noSetReadPlusActivity = FALSE;
  object->noSetModify = 0;
  object->__isset_noSetModify = FALSE;
  object->noSetFullAccess = 0;
  object->__isset_noSetFullAccess = FALSE;
}

static void 
share_relationship_restrictions_finalize (GObject *object)
{
  ShareRelationshipRestrictions *tobject = SHARE_RELATIONSHIP_RESTRICTIONS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
share_relationship_restrictions_class_init (ShareRelationshipRestrictionsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = share_relationship_restrictions_read;
  struct_class->write = share_relationship_restrictions_write;

  gobject_class->finalize = share_relationship_restrictions_finalize;
  gobject_class->get_property = share_relationship_restrictions_get_property;
  gobject_class->set_property = share_relationship_restrictions_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_ONLY,
     g_param_spec_boolean ("noSetReadOnly",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_PLUS_ACTIVITY,
     g_param_spec_boolean ("noSetReadPlusActivity",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_MODIFY,
     g_param_spec_boolean ("noSetModify",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_FULL_ACCESS,
     g_param_spec_boolean ("noSetFullAccess",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
share_relationship_restrictions_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ShareRelationshipRestrictionsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) share_relationship_restrictions_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ShareRelationshipRestrictions),
      0, /* n_preallocs */
      (GInstanceInitFunc) share_relationship_restrictions_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ShareRelationshipRestrictionsType",
                                   &type_info, 0);
  }

  return type;
}

enum _InvitationShareRelationshipProperties
{
  PROP_INVITATION_SHARE_RELATIONSHIP_0,
  PROP_INVITATION_SHARE_RELATIONSHIP_DISPLAY_NAME,
  PROP_INVITATION_SHARE_RELATIONSHIP_RECIPIENT_USER_IDENTITY,
  PROP_INVITATION_SHARE_RELATIONSHIP_PRIVILEGE,
  PROP_INVITATION_SHARE_RELATIONSHIP_SHARER_USER_ID
};

/* reads a invitation_share_relationship object */
static gint32
invitation_share_relationship_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  InvitationShareRelationship * this_object = INVITATION_SHARE_RELATIONSHIP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->displayName != NULL)
          {
            g_free(this_object->displayName);
            this_object->displayName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->displayName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_displayName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->recipientUserIdentity), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_recipientUserIdentity = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast65;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast65, error)) < 0)
            return -1;
          xfer += ret;
          this_object->privilege = (ShareRelationshipPrivilegeLevel)ecast65;
          this_object->__isset_privilege = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->sharerUserId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sharerUserId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
invitation_share_relationship_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  InvitationShareRelationship * this_object = INVITATION_SHARE_RELATIONSHIP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InvitationShareRelationship", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_displayName == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "displayName", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->displayName, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_recipientUserIdentity == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientUserIdentity", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->recipientUserIdentity), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_privilege == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "privilege", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->privilege, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_sharerUserId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sharerUserId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->sharerUserId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
invitation_share_relationship_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  InvitationShareRelationship *self = INVITATION_SHARE_RELATIONSHIP (object);

  switch (property_id)
  {
    case PROP_INVITATION_SHARE_RELATIONSHIP_DISPLAY_NAME:
      if (self->displayName != NULL)
        g_free (self->displayName);
      self->displayName = g_value_dup_string (value);
      self->__isset_displayName = TRUE;
      break;

    case PROP_INVITATION_SHARE_RELATIONSHIP_RECIPIENT_USER_IDENTITY:
      if (self->recipientUserIdentity != NULL)
        g_object_unref (self->recipientUserIdentity);
      self->recipientUserIdentity = g_value_dup_object (value);
      self->__isset_recipientUserIdentity = TRUE;
      break;

    case PROP_INVITATION_SHARE_RELATIONSHIP_PRIVILEGE:
      self->privilege = g_value_get_int (value);
      self->__isset_privilege = TRUE;
      break;

    case PROP_INVITATION_SHARE_RELATIONSHIP_SHARER_USER_ID:
      self->sharerUserId = g_value_get_int (value);
      self->__isset_sharerUserId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
invitation_share_relationship_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  InvitationShareRelationship *self = INVITATION_SHARE_RELATIONSHIP (object);

  switch (property_id)
  {
    case PROP_INVITATION_SHARE_RELATIONSHIP_DISPLAY_NAME:
      g_value_set_string (value, self->displayName);
      break;

    case PROP_INVITATION_SHARE_RELATIONSHIP_RECIPIENT_USER_IDENTITY:
      g_value_set_object (value, self->recipientUserIdentity);
      break;

    case PROP_INVITATION_SHARE_RELATIONSHIP_PRIVILEGE:
      g_value_set_int (value, self->privilege);
      break;

    case PROP_INVITATION_SHARE_RELATIONSHIP_SHARER_USER_ID:
      g_value_set_int (value, self->sharerUserId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
invitation_share_relationship_instance_init (InvitationShareRelationship * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->displayName = NULL;
  object->__isset_displayName = FALSE;
  object->recipientUserIdentity = g_object_new (TYPE_USER_IDENTITY, NULL);
  object->__isset_recipientUserIdentity = FALSE;
  object->__isset_privilege = FALSE;
  object->sharerUserId = 0;
  object->__isset_sharerUserId = FALSE;
}

static void 
invitation_share_relationship_finalize (GObject *object)
{
  InvitationShareRelationship *tobject = INVITATION_SHARE_RELATIONSHIP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->displayName != NULL)
  {
    g_free(tobject->displayName);
    tobject->displayName = NULL;
  }
  if (tobject->recipientUserIdentity != NULL)
  {
    g_object_unref(tobject->recipientUserIdentity);
    tobject->recipientUserIdentity = NULL;
  }
}

static void
invitation_share_relationship_class_init (InvitationShareRelationshipClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = invitation_share_relationship_read;
  struct_class->write = invitation_share_relationship_write;

  gobject_class->finalize = invitation_share_relationship_finalize;
  gobject_class->get_property = invitation_share_relationship_get_property;
  gobject_class->set_property = invitation_share_relationship_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_INVITATION_SHARE_RELATIONSHIP_DISPLAY_NAME,
     g_param_spec_string ("displayName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_INVITATION_SHARE_RELATIONSHIP_RECIPIENT_USER_IDENTITY,
     g_param_spec_object ("recipientUserIdentity",
                         NULL,
                         NULL,
                         TYPE_USER_IDENTITY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_INVITATION_SHARE_RELATIONSHIP_PRIVILEGE,
     g_param_spec_int ("privilege",
                       NULL,
                       NULL,
                       0,
                       30,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_INVITATION_SHARE_RELATIONSHIP_SHARER_USER_ID,
     g_param_spec_int ("sharerUserId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
invitation_share_relationship_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (InvitationShareRelationshipClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) invitation_share_relationship_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (InvitationShareRelationship),
      0, /* n_preallocs */
      (GInstanceInitFunc) invitation_share_relationship_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "InvitationShareRelationshipType",
                                   &type_info, 0);
  }

  return type;
}

enum _MemberShareRelationshipProperties
{
  PROP_MEMBER_SHARE_RELATIONSHIP_0,
  PROP_MEMBER_SHARE_RELATIONSHIP_DISPLAY_NAME,
  PROP_MEMBER_SHARE_RELATIONSHIP_RECIPIENT_USER_ID,
  PROP_MEMBER_SHARE_RELATIONSHIP_BEST_PRIVILEGE,
  PROP_MEMBER_SHARE_RELATIONSHIP_INDIVIDUAL_PRIVILEGE,
  PROP_MEMBER_SHARE_RELATIONSHIP_RESTRICTIONS,
  PROP_MEMBER_SHARE_RELATIONSHIP_SHARER_USER_ID
};

/* reads a member_share_relationship object */
static gint32
member_share_relationship_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MemberShareRelationship * this_object = MEMBER_SHARE_RELATIONSHIP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->displayName != NULL)
          {
            g_free(this_object->displayName);
            this_object->displayName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->displayName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_displayName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->recipientUserId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_recipientUserId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast66;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast66, error)) < 0)
            return -1;
          xfer += ret;
          this_object->bestPrivilege = (ShareRelationshipPrivilegeLevel)ecast66;
          this_object->__isset_bestPrivilege = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast67;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast67, error)) < 0)
            return -1;
          xfer += ret;
          this_object->individualPrivilege = (ShareRelationshipPrivilegeLevel)ecast67;
          this_object->__isset_individualPrivilege = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->restrictions), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_restrictions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->sharerUserId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sharerUserId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
member_share_relationship_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MemberShareRelationship * this_object = MEMBER_SHARE_RELATIONSHIP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MemberShareRelationship", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_displayName == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "displayName", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->displayName, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_recipientUserId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientUserId", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->recipientUserId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bestPrivilege == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bestPrivilege", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->bestPrivilege, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_individualPrivilege == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "individualPrivilege", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->individualPrivilege, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_restrictions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "restrictions", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->restrictions), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_sharerUserId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sharerUserId", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->sharerUserId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
member_share_relationship_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  MemberShareRelationship *self = MEMBER_SHARE_RELATIONSHIP (object);

  switch (property_id)
  {
    case PROP_MEMBER_SHARE_RELATIONSHIP_DISPLAY_NAME:
      if (self->displayName != NULL)
        g_free (self->displayName);
      self->displayName = g_value_dup_string (value);
      self->__isset_displayName = TRUE;
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_RECIPIENT_USER_ID:
      self->recipientUserId = g_value_get_int (value);
      self->__isset_recipientUserId = TRUE;
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_BEST_PRIVILEGE:
      self->bestPrivilege = g_value_get_int (value);
      self->__isset_bestPrivilege = TRUE;
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_INDIVIDUAL_PRIVILEGE:
      self->individualPrivilege = g_value_get_int (value);
      self->__isset_individualPrivilege = TRUE;
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_RESTRICTIONS:
      if (self->restrictions != NULL)
        g_object_unref (self->restrictions);
      self->restrictions = g_value_dup_object (value);
      self->__isset_restrictions = TRUE;
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_SHARER_USER_ID:
      self->sharerUserId = g_value_get_int (value);
      self->__isset_sharerUserId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
member_share_relationship_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  MemberShareRelationship *self = MEMBER_SHARE_RELATIONSHIP (object);

  switch (property_id)
  {
    case PROP_MEMBER_SHARE_RELATIONSHIP_DISPLAY_NAME:
      g_value_set_string (value, self->displayName);
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_RECIPIENT_USER_ID:
      g_value_set_int (value, self->recipientUserId);
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_BEST_PRIVILEGE:
      g_value_set_int (value, self->bestPrivilege);
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_INDIVIDUAL_PRIVILEGE:
      g_value_set_int (value, self->individualPrivilege);
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_RESTRICTIONS:
      g_value_set_object (value, self->restrictions);
      break;

    case PROP_MEMBER_SHARE_RELATIONSHIP_SHARER_USER_ID:
      g_value_set_int (value, self->sharerUserId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
member_share_relationship_instance_init (MemberShareRelationship * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->displayName = NULL;
  object->__isset_displayName = FALSE;
  object->recipientUserId = 0;
  object->__isset_recipientUserId = FALSE;
  object->__isset_bestPrivilege = FALSE;
  object->__isset_individualPrivilege = FALSE;
  object->restrictions = g_object_new (TYPE_SHARE_RELATIONSHIP_RESTRICTIONS, NULL);
  object->__isset_restrictions = FALSE;
  object->sharerUserId = 0;
  object->__isset_sharerUserId = FALSE;
}

static void 
member_share_relationship_finalize (GObject *object)
{
  MemberShareRelationship *tobject = MEMBER_SHARE_RELATIONSHIP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->displayName != NULL)
  {
    g_free(tobject->displayName);
    tobject->displayName = NULL;
  }
  if (tobject->restrictions != NULL)
  {
    g_object_unref(tobject->restrictions);
    tobject->restrictions = NULL;
  }
}

static void
member_share_relationship_class_init (MemberShareRelationshipClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = member_share_relationship_read;
  struct_class->write = member_share_relationship_write;

  gobject_class->finalize = member_share_relationship_finalize;
  gobject_class->get_property = member_share_relationship_get_property;
  gobject_class->set_property = member_share_relationship_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MEMBER_SHARE_RELATIONSHIP_DISPLAY_NAME,
     g_param_spec_string ("displayName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MEMBER_SHARE_RELATIONSHIP_RECIPIENT_USER_ID,
     g_param_spec_int ("recipientUserId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MEMBER_SHARE_RELATIONSHIP_BEST_PRIVILEGE,
     g_param_spec_int ("bestPrivilege",
                       NULL,
                       NULL,
                       0,
                       30,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MEMBER_SHARE_RELATIONSHIP_INDIVIDUAL_PRIVILEGE,
     g_param_spec_int ("individualPrivilege",
                       NULL,
                       NULL,
                       0,
                       30,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MEMBER_SHARE_RELATIONSHIP_RESTRICTIONS,
     g_param_spec_object ("restrictions",
                         NULL,
                         NULL,
                         TYPE_SHARE_RELATIONSHIP_RESTRICTIONS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MEMBER_SHARE_RELATIONSHIP_SHARER_USER_ID,
     g_param_spec_int ("sharerUserId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
member_share_relationship_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MemberShareRelationshipClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) member_share_relationship_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (MemberShareRelationship),
      0, /* n_preallocs */
      (GInstanceInitFunc) member_share_relationship_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MemberShareRelationshipType",
                                   &type_info, 0);
  }

  return type;
}

enum _ShareRelationshipsProperties
{
  PROP_SHARE_RELATIONSHIPS_0,
  PROP_SHARE_RELATIONSHIPS_INVITATIONS,
  PROP_SHARE_RELATIONSHIPS_MEMBERSHIPS,
  PROP_SHARE_RELATIONSHIPS_INVITATION_RESTRICTIONS
};

/* reads a share_relationships object */
static gint32
share_relationships_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ShareRelationships * this_object = SHARE_RELATIONSHIPS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              InvitationShareRelationship * _elem68 = NULL;
              if ( _elem68 != NULL)
              {
                g_object_unref (_elem68);
              }
              _elem68 = g_object_new (TYPE_INVITATION_SHARE_RELATIONSHIP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem68), protocol, error)) < 0)
              {
                g_object_unref (_elem68);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->invitations, _elem68);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_invitations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              MemberShareRelationship * _elem69 = NULL;
              if ( _elem69 != NULL)
              {
                g_object_unref (_elem69);
              }
              _elem69 = g_object_new (TYPE_MEMBER_SHARE_RELATIONSHIP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem69), protocol, error)) < 0)
              {
                g_object_unref (_elem69);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->memberships, _elem69);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_memberships = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->invitationRestrictions), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_invitationRestrictions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
share_relationships_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ShareRelationships * this_object = SHARE_RELATIONSHIPS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ShareRelationships", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_invitations == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "invitations", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i70;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->invitations ? this_object->invitations->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i70 = 0; i70 < (this_object->invitations ? this_object->invitations->len : 0); i70++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->invitations, i70))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_memberships == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "memberships", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i71;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->memberships ? this_object->memberships->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i71 = 0; i71 < (this_object->memberships ? this_object->memberships->len : 0); i71++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->memberships, i71))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_invitationRestrictions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "invitationRestrictions", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->invitationRestrictions), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
share_relationships_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ShareRelationships *self = SHARE_RELATIONSHIPS (object);

  switch (property_id)
  {
    case PROP_SHARE_RELATIONSHIPS_INVITATIONS:
      if (self->invitations != NULL)
        g_ptr_array_unref (self->invitations);
      self->invitations = g_value_dup_boxed (value);
      self->__isset_invitations = TRUE;
      break;

    case PROP_SHARE_RELATIONSHIPS_MEMBERSHIPS:
      if (self->memberships != NULL)
        g_ptr_array_unref (self->memberships);
      self->memberships = g_value_dup_boxed (value);
      self->__isset_memberships = TRUE;
      break;

    case PROP_SHARE_RELATIONSHIPS_INVITATION_RESTRICTIONS:
      if (self->invitationRestrictions != NULL)
        g_object_unref (self->invitationRestrictions);
      self->invitationRestrictions = g_value_dup_object (value);
      self->__isset_invitationRestrictions = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
share_relationships_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ShareRelationships *self = SHARE_RELATIONSHIPS (object);

  switch (property_id)
  {
    case PROP_SHARE_RELATIONSHIPS_INVITATIONS:
      g_value_set_boxed (value, self->invitations);
      break;

    case PROP_SHARE_RELATIONSHIPS_MEMBERSHIPS:
      g_value_set_boxed (value, self->memberships);
      break;

    case PROP_SHARE_RELATIONSHIPS_INVITATION_RESTRICTIONS:
      g_value_set_object (value, self->invitationRestrictions);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
share_relationships_instance_init (ShareRelationships * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->invitations = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_invitations = FALSE;
  object->memberships = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_memberships = FALSE;
  object->invitationRestrictions = g_object_new (TYPE_SHARE_RELATIONSHIP_RESTRICTIONS, NULL);
  object->__isset_invitationRestrictions = FALSE;
}

static void 
share_relationships_finalize (GObject *object)
{
  ShareRelationships *tobject = SHARE_RELATIONSHIPS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->invitations != NULL)
  {
    g_ptr_array_unref (tobject->invitations);
    tobject->invitations = NULL;
  }
  if (tobject->memberships != NULL)
  {
    g_ptr_array_unref (tobject->memberships);
    tobject->memberships = NULL;
  }
  if (tobject->invitationRestrictions != NULL)
  {
    g_object_unref(tobject->invitationRestrictions);
    tobject->invitationRestrictions = NULL;
  }
}

static void
share_relationships_class_init (ShareRelationshipsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = share_relationships_read;
  struct_class->write = share_relationships_write;

  gobject_class->finalize = share_relationships_finalize;
  gobject_class->get_property = share_relationships_get_property;
  gobject_class->set_property = share_relationships_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SHARE_RELATIONSHIPS_INVITATIONS,
     g_param_spec_boxed ("invitations",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SHARE_RELATIONSHIPS_MEMBERSHIPS,
     g_param_spec_boxed ("memberships",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SHARE_RELATIONSHIPS_INVITATION_RESTRICTIONS,
     g_param_spec_object ("invitationRestrictions",
                         NULL,
                         NULL,
                         TYPE_SHARE_RELATIONSHIP_RESTRICTIONS,
                         G_PARAM_READWRITE));
}

GType
share_relationships_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ShareRelationshipsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) share_relationships_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ShareRelationships),
      0, /* n_preallocs */
      (GInstanceInitFunc) share_relationships_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ShareRelationshipsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ManageNotebookSharesParametersProperties
{
  PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_0,
  PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_NOTEBOOK_GUID,
  PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_INVITE_MESSAGE,
  PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_MEMBERSHIPS_TO_UPDATE,
  PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_INVITATIONS_TO_CREATE_OR_UPDATE,
  PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_UNSHARES
};

/* reads a manage_notebook_shares_parameters object */
static gint32
manage_notebook_shares_parameters_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ManageNotebookSharesParameters * this_object = MANAGE_NOTEBOOK_SHARES_PARAMETERS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->notebookGuid != NULL)
          {
            g_free(this_object->notebookGuid);
            this_object->notebookGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->notebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_notebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->inviteMessage != NULL)
          {
            g_free(this_object->inviteMessage);
            this_object->inviteMessage = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->inviteMessage, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_inviteMessage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              MemberShareRelationship * _elem72 = NULL;
              if ( _elem72 != NULL)
              {
                g_object_unref (_elem72);
              }
              _elem72 = g_object_new (TYPE_MEMBER_SHARE_RELATIONSHIP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem72), protocol, error)) < 0)
              {
                g_object_unref (_elem72);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->membershipsToUpdate, _elem72);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_membershipsToUpdate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              InvitationShareRelationship * _elem73 = NULL;
              if ( _elem73 != NULL)
              {
                g_object_unref (_elem73);
              }
              _elem73 = g_object_new (TYPE_INVITATION_SHARE_RELATIONSHIP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem73), protocol, error)) < 0)
              {
                g_object_unref (_elem73);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->invitationsToCreateOrUpdate, _elem73);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_invitationsToCreateOrUpdate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              UserIdentity * _elem74 = NULL;
              if ( _elem74 != NULL)
              {
                g_object_unref (_elem74);
              }
              _elem74 = g_object_new (TYPE_USER_IDENTITY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem74), protocol, error)) < 0)
              {
                g_object_unref (_elem74);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->unshares, _elem74);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_unshares = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
manage_notebook_shares_parameters_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ManageNotebookSharesParameters * this_object = MANAGE_NOTEBOOK_SHARES_PARAMETERS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ManageNotebookSharesParameters", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_notebookGuid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->notebookGuid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_inviteMessage == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "inviteMessage", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->inviteMessage, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_membershipsToUpdate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "membershipsToUpdate", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i75;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->membershipsToUpdate ? this_object->membershipsToUpdate->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i75 = 0; i75 < (this_object->membershipsToUpdate ? this_object->membershipsToUpdate->len : 0); i75++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->membershipsToUpdate, i75))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_invitationsToCreateOrUpdate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "invitationsToCreateOrUpdate", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i76;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->invitationsToCreateOrUpdate ? this_object->invitationsToCreateOrUpdate->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i76 = 0; i76 < (this_object->invitationsToCreateOrUpdate ? this_object->invitationsToCreateOrUpdate->len : 0); i76++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->invitationsToCreateOrUpdate, i76))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_unshares == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "unshares", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i77;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->unshares ? this_object->unshares->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i77 = 0; i77 < (this_object->unshares ? this_object->unshares->len : 0); i77++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->unshares, i77))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
manage_notebook_shares_parameters_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  ManageNotebookSharesParameters *self = MANAGE_NOTEBOOK_SHARES_PARAMETERS (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_NOTEBOOK_GUID:
      if (self->notebookGuid != NULL)
        g_free (self->notebookGuid);
      self->notebookGuid = g_value_dup_string (value);
      self->__isset_notebookGuid = TRUE;
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_INVITE_MESSAGE:
      if (self->inviteMessage != NULL)
        g_free (self->inviteMessage);
      self->inviteMessage = g_value_dup_string (value);
      self->__isset_inviteMessage = TRUE;
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_MEMBERSHIPS_TO_UPDATE:
      if (self->membershipsToUpdate != NULL)
        g_ptr_array_unref (self->membershipsToUpdate);
      self->membershipsToUpdate = g_value_dup_boxed (value);
      self->__isset_membershipsToUpdate = TRUE;
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_INVITATIONS_TO_CREATE_OR_UPDATE:
      if (self->invitationsToCreateOrUpdate != NULL)
        g_ptr_array_unref (self->invitationsToCreateOrUpdate);
      self->invitationsToCreateOrUpdate = g_value_dup_boxed (value);
      self->__isset_invitationsToCreateOrUpdate = TRUE;
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_UNSHARES:
      if (self->unshares != NULL)
        g_ptr_array_unref (self->unshares);
      self->unshares = g_value_dup_boxed (value);
      self->__isset_unshares = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
manage_notebook_shares_parameters_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  ManageNotebookSharesParameters *self = MANAGE_NOTEBOOK_SHARES_PARAMETERS (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_NOTEBOOK_GUID:
      g_value_set_string (value, self->notebookGuid);
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_INVITE_MESSAGE:
      g_value_set_string (value, self->inviteMessage);
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_MEMBERSHIPS_TO_UPDATE:
      g_value_set_boxed (value, self->membershipsToUpdate);
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_INVITATIONS_TO_CREATE_OR_UPDATE:
      g_value_set_boxed (value, self->invitationsToCreateOrUpdate);
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_UNSHARES:
      g_value_set_boxed (value, self->unshares);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
manage_notebook_shares_parameters_instance_init (ManageNotebookSharesParameters * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->notebookGuid = NULL;
  object->__isset_notebookGuid = FALSE;
  object->inviteMessage = NULL;
  object->__isset_inviteMessage = FALSE;
  object->membershipsToUpdate = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_membershipsToUpdate = FALSE;
  object->invitationsToCreateOrUpdate = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_invitationsToCreateOrUpdate = FALSE;
  object->unshares = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_unshares = FALSE;
}

static void 
manage_notebook_shares_parameters_finalize (GObject *object)
{
  ManageNotebookSharesParameters *tobject = MANAGE_NOTEBOOK_SHARES_PARAMETERS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->notebookGuid != NULL)
  {
    g_free(tobject->notebookGuid);
    tobject->notebookGuid = NULL;
  }
  if (tobject->inviteMessage != NULL)
  {
    g_free(tobject->inviteMessage);
    tobject->inviteMessage = NULL;
  }
  if (tobject->membershipsToUpdate != NULL)
  {
    g_ptr_array_unref (tobject->membershipsToUpdate);
    tobject->membershipsToUpdate = NULL;
  }
  if (tobject->invitationsToCreateOrUpdate != NULL)
  {
    g_ptr_array_unref (tobject->invitationsToCreateOrUpdate);
    tobject->invitationsToCreateOrUpdate = NULL;
  }
  if (tobject->unshares != NULL)
  {
    g_ptr_array_unref (tobject->unshares);
    tobject->unshares = NULL;
  }
}

static void
manage_notebook_shares_parameters_class_init (ManageNotebookSharesParametersClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = manage_notebook_shares_parameters_read;
  struct_class->write = manage_notebook_shares_parameters_write;

  gobject_class->finalize = manage_notebook_shares_parameters_finalize;
  gobject_class->get_property = manage_notebook_shares_parameters_get_property;
  gobject_class->set_property = manage_notebook_shares_parameters_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_NOTEBOOK_GUID,
     g_param_spec_string ("notebookGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_INVITE_MESSAGE,
     g_param_spec_string ("inviteMessage",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_MEMBERSHIPS_TO_UPDATE,
     g_param_spec_boxed ("membershipsToUpdate",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_INVITATIONS_TO_CREATE_OR_UPDATE,
     g_param_spec_boxed ("invitationsToCreateOrUpdate",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_PARAMETERS_UNSHARES,
     g_param_spec_boxed ("unshares",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
manage_notebook_shares_parameters_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ManageNotebookSharesParametersClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) manage_notebook_shares_parameters_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ManageNotebookSharesParameters),
      0, /* n_preallocs */
      (GInstanceInitFunc) manage_notebook_shares_parameters_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ManageNotebookSharesParametersType",
                                   &type_info, 0);
  }

  return type;
}

enum _ManageNotebookSharesErrorProperties
{
  PROP_MANAGE_NOTEBOOK_SHARES_ERROR_0,
  PROP_MANAGE_NOTEBOOK_SHARES_ERROR_USER_IDENTITY,
  PROP_MANAGE_NOTEBOOK_SHARES_ERROR_USER_EXCEPTION,
  PROP_MANAGE_NOTEBOOK_SHARES_ERROR_NOT_FOUND_EXCEPTION
};

/* reads a manage_notebook_shares_error object */
static gint32
manage_notebook_shares_error_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ManageNotebookSharesError * this_object = MANAGE_NOTEBOOK_SHARES_ERROR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userIdentity), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_userIdentity = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
manage_notebook_shares_error_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ManageNotebookSharesError * this_object = MANAGE_NOTEBOOK_SHARES_ERROR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ManageNotebookSharesError", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_userIdentity == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userIdentity", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userIdentity), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
manage_notebook_shares_error_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  ManageNotebookSharesError *self = MANAGE_NOTEBOOK_SHARES_ERROR (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTEBOOK_SHARES_ERROR_USER_IDENTITY:
      if (self->userIdentity != NULL)
        g_object_unref (self->userIdentity);
      self->userIdentity = g_value_dup_object (value);
      self->__isset_userIdentity = TRUE;
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_ERROR_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_ERROR_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
manage_notebook_shares_error_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  ManageNotebookSharesError *self = MANAGE_NOTEBOOK_SHARES_ERROR (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTEBOOK_SHARES_ERROR_USER_IDENTITY:
      g_value_set_object (value, self->userIdentity);
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_ERROR_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_MANAGE_NOTEBOOK_SHARES_ERROR_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
manage_notebook_shares_error_instance_init (ManageNotebookSharesError * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userIdentity = g_object_new (TYPE_USER_IDENTITY, NULL);
  object->__isset_userIdentity = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
manage_notebook_shares_error_finalize (GObject *object)
{
  ManageNotebookSharesError *tobject = MANAGE_NOTEBOOK_SHARES_ERROR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userIdentity != NULL)
  {
    g_object_unref(tobject->userIdentity);
    tobject->userIdentity = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
manage_notebook_shares_error_class_init (ManageNotebookSharesErrorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = manage_notebook_shares_error_read;
  struct_class->write = manage_notebook_shares_error_write;

  gobject_class->finalize = manage_notebook_shares_error_finalize;
  gobject_class->get_property = manage_notebook_shares_error_get_property;
  gobject_class->set_property = manage_notebook_shares_error_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_ERROR_USER_IDENTITY,
     g_param_spec_object ("userIdentity",
                         NULL,
                         NULL,
                         TYPE_USER_IDENTITY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_ERROR_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_ERROR_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
manage_notebook_shares_error_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ManageNotebookSharesErrorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) manage_notebook_shares_error_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ManageNotebookSharesError),
      0, /* n_preallocs */
      (GInstanceInitFunc) manage_notebook_shares_error_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ManageNotebookSharesErrorType",
                                   &type_info, 0);
  }

  return type;
}

enum _ManageNotebookSharesResultProperties
{
  PROP_MANAGE_NOTEBOOK_SHARES_RESULT_0,
  PROP_MANAGE_NOTEBOOK_SHARES_RESULT_ERRORS
};

/* reads a manage_notebook_shares_result object */
static gint32
manage_notebook_shares_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ManageNotebookSharesResult * this_object = MANAGE_NOTEBOOK_SHARES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ManageNotebookSharesError * _elem78 = NULL;
              if ( _elem78 != NULL)
              {
                g_object_unref (_elem78);
              }
              _elem78 = g_object_new (TYPE_MANAGE_NOTEBOOK_SHARES_ERROR, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem78), protocol, error)) < 0)
              {
                g_object_unref (_elem78);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->errors, _elem78);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_errors = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
manage_notebook_shares_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ManageNotebookSharesResult * this_object = MANAGE_NOTEBOOK_SHARES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ManageNotebookSharesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_errors == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "errors", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i79;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->errors ? this_object->errors->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i79 = 0; i79 < (this_object->errors ? this_object->errors->len : 0); i79++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->errors, i79))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
manage_notebook_shares_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  ManageNotebookSharesResult *self = MANAGE_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTEBOOK_SHARES_RESULT_ERRORS:
      if (self->errors != NULL)
        g_ptr_array_unref (self->errors);
      self->errors = g_value_dup_boxed (value);
      self->__isset_errors = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
manage_notebook_shares_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  ManageNotebookSharesResult *self = MANAGE_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTEBOOK_SHARES_RESULT_ERRORS:
      g_value_set_boxed (value, self->errors);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
manage_notebook_shares_result_instance_init (ManageNotebookSharesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errors = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_errors = FALSE;
}

static void 
manage_notebook_shares_result_finalize (GObject *object)
{
  ManageNotebookSharesResult *tobject = MANAGE_NOTEBOOK_SHARES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->errors != NULL)
  {
    g_ptr_array_unref (tobject->errors);
    tobject->errors = NULL;
  }
}

static void
manage_notebook_shares_result_class_init (ManageNotebookSharesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = manage_notebook_shares_result_read;
  struct_class->write = manage_notebook_shares_result_write;

  gobject_class->finalize = manage_notebook_shares_result_finalize;
  gobject_class->get_property = manage_notebook_shares_result_get_property;
  gobject_class->set_property = manage_notebook_shares_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTEBOOK_SHARES_RESULT_ERRORS,
     g_param_spec_boxed ("errors",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
manage_notebook_shares_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ManageNotebookSharesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) manage_notebook_shares_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ManageNotebookSharesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) manage_notebook_shares_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ManageNotebookSharesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _SharedNoteTemplateProperties
{
  PROP_SHARED_NOTE_TEMPLATE_0,
  PROP_SHARED_NOTE_TEMPLATE_NOTE_GUID,
  PROP_SHARED_NOTE_TEMPLATE_RECIPIENT_THREAD_ID,
  PROP_SHARED_NOTE_TEMPLATE_RECIPIENT_CONTACTS,
  PROP_SHARED_NOTE_TEMPLATE_PRIVILEGE
};

/* reads a shared_note_template object */
static gint32
shared_note_template_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SharedNoteTemplate * this_object = SHARED_NOTE_TEMPLATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->noteGuid != NULL)
          {
            g_free(this_object->noteGuid);
            this_object->noteGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->recipientThreadId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_recipientThreadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Contact * _elem80 = NULL;
              if ( _elem80 != NULL)
              {
                g_object_unref (_elem80);
              }
              _elem80 = g_object_new (TYPE_CONTACT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem80), protocol, error)) < 0)
              {
                g_object_unref (_elem80);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->recipientContacts, _elem80);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_recipientContacts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast81;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast81, error)) < 0)
            return -1;
          xfer += ret;
          this_object->privilege = (SharedNotePrivilegeLevel)ecast81;
          this_object->__isset_privilege = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
shared_note_template_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SharedNoteTemplate * this_object = SHARED_NOTE_TEMPLATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SharedNoteTemplate", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_noteGuid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->noteGuid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_recipientThreadId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientThreadId", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->recipientThreadId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_recipientContacts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientContacts", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i82;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->recipientContacts ? this_object->recipientContacts->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i82 = 0; i82 < (this_object->recipientContacts ? this_object->recipientContacts->len : 0); i82++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->recipientContacts, i82))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_privilege == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "privilege", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->privilege, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
shared_note_template_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  SharedNoteTemplate *self = SHARED_NOTE_TEMPLATE (object);

  switch (property_id)
  {
    case PROP_SHARED_NOTE_TEMPLATE_NOTE_GUID:
      if (self->noteGuid != NULL)
        g_free (self->noteGuid);
      self->noteGuid = g_value_dup_string (value);
      self->__isset_noteGuid = TRUE;
      break;

    case PROP_SHARED_NOTE_TEMPLATE_RECIPIENT_THREAD_ID:
      self->recipientThreadId = g_value_get_int64 (value);
      self->__isset_recipientThreadId = TRUE;
      break;

    case PROP_SHARED_NOTE_TEMPLATE_RECIPIENT_CONTACTS:
      if (self->recipientContacts != NULL)
        g_ptr_array_unref (self->recipientContacts);
      self->recipientContacts = g_value_dup_boxed (value);
      self->__isset_recipientContacts = TRUE;
      break;

    case PROP_SHARED_NOTE_TEMPLATE_PRIVILEGE:
      self->privilege = g_value_get_int (value);
      self->__isset_privilege = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
shared_note_template_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  SharedNoteTemplate *self = SHARED_NOTE_TEMPLATE (object);

  switch (property_id)
  {
    case PROP_SHARED_NOTE_TEMPLATE_NOTE_GUID:
      g_value_set_string (value, self->noteGuid);
      break;

    case PROP_SHARED_NOTE_TEMPLATE_RECIPIENT_THREAD_ID:
      g_value_set_int64 (value, self->recipientThreadId);
      break;

    case PROP_SHARED_NOTE_TEMPLATE_RECIPIENT_CONTACTS:
      g_value_set_boxed (value, self->recipientContacts);
      break;

    case PROP_SHARED_NOTE_TEMPLATE_PRIVILEGE:
      g_value_set_int (value, self->privilege);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
shared_note_template_instance_init (SharedNoteTemplate * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->noteGuid = NULL;
  object->__isset_noteGuid = FALSE;
  object->recipientThreadId = 0;
  object->__isset_recipientThreadId = FALSE;
  object->recipientContacts = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_recipientContacts = FALSE;
  object->__isset_privilege = FALSE;
}

static void 
shared_note_template_finalize (GObject *object)
{
  SharedNoteTemplate *tobject = SHARED_NOTE_TEMPLATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->noteGuid != NULL)
  {
    g_free(tobject->noteGuid);
    tobject->noteGuid = NULL;
  }
  if (tobject->recipientContacts != NULL)
  {
    g_ptr_array_unref (tobject->recipientContacts);
    tobject->recipientContacts = NULL;
  }
}

static void
shared_note_template_class_init (SharedNoteTemplateClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = shared_note_template_read;
  struct_class->write = shared_note_template_write;

  gobject_class->finalize = shared_note_template_finalize;
  gobject_class->get_property = shared_note_template_get_property;
  gobject_class->set_property = shared_note_template_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SHARED_NOTE_TEMPLATE_NOTE_GUID,
     g_param_spec_string ("noteGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SHARED_NOTE_TEMPLATE_RECIPIENT_THREAD_ID,
     g_param_spec_int64 ("recipientThreadId",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SHARED_NOTE_TEMPLATE_RECIPIENT_CONTACTS,
     g_param_spec_boxed ("recipientContacts",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SHARED_NOTE_TEMPLATE_PRIVILEGE,
     g_param_spec_int ("privilege",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));
}

GType
shared_note_template_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SharedNoteTemplateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) shared_note_template_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SharedNoteTemplate),
      0, /* n_preallocs */
      (GInstanceInitFunc) shared_note_template_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SharedNoteTemplateType",
                                   &type_info, 0);
  }

  return type;
}

enum _NotebookShareTemplateProperties
{
  PROP_NOTEBOOK_SHARE_TEMPLATE_0,
  PROP_NOTEBOOK_SHARE_TEMPLATE_NOTEBOOK_GUID,
  PROP_NOTEBOOK_SHARE_TEMPLATE_RECIPIENT_THREAD_ID,
  PROP_NOTEBOOK_SHARE_TEMPLATE_RECIPIENT_CONTACTS,
  PROP_NOTEBOOK_SHARE_TEMPLATE_PRIVILEGE
};

/* reads a notebook_share_template object */
static gint32
notebook_share_template_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NotebookShareTemplate * this_object = NOTEBOOK_SHARE_TEMPLATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->notebookGuid != NULL)
          {
            g_free(this_object->notebookGuid);
            this_object->notebookGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->notebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_notebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->recipientThreadId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_recipientThreadId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Contact * _elem83 = NULL;
              if ( _elem83 != NULL)
              {
                g_object_unref (_elem83);
              }
              _elem83 = g_object_new (TYPE_CONTACT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem83), protocol, error)) < 0)
              {
                g_object_unref (_elem83);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->recipientContacts, _elem83);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_recipientContacts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast84;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast84, error)) < 0)
            return -1;
          xfer += ret;
          this_object->privilege = (SharedNotebookPrivilegeLevel)ecast84;
          this_object->__isset_privilege = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
notebook_share_template_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NotebookShareTemplate * this_object = NOTEBOOK_SHARE_TEMPLATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NotebookShareTemplate", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_notebookGuid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->notebookGuid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_recipientThreadId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientThreadId", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->recipientThreadId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_recipientContacts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientContacts", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i85;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->recipientContacts ? this_object->recipientContacts->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i85 = 0; i85 < (this_object->recipientContacts ? this_object->recipientContacts->len : 0); i85++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->recipientContacts, i85))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_privilege == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "privilege", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->privilege, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
notebook_share_template_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  NotebookShareTemplate *self = NOTEBOOK_SHARE_TEMPLATE (object);

  switch (property_id)
  {
    case PROP_NOTEBOOK_SHARE_TEMPLATE_NOTEBOOK_GUID:
      if (self->notebookGuid != NULL)
        g_free (self->notebookGuid);
      self->notebookGuid = g_value_dup_string (value);
      self->__isset_notebookGuid = TRUE;
      break;

    case PROP_NOTEBOOK_SHARE_TEMPLATE_RECIPIENT_THREAD_ID:
      self->recipientThreadId = g_value_get_int64 (value);
      self->__isset_recipientThreadId = TRUE;
      break;

    case PROP_NOTEBOOK_SHARE_TEMPLATE_RECIPIENT_CONTACTS:
      if (self->recipientContacts != NULL)
        g_ptr_array_unref (self->recipientContacts);
      self->recipientContacts = g_value_dup_boxed (value);
      self->__isset_recipientContacts = TRUE;
      break;

    case PROP_NOTEBOOK_SHARE_TEMPLATE_PRIVILEGE:
      self->privilege = g_value_get_int (value);
      self->__isset_privilege = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
notebook_share_template_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  NotebookShareTemplate *self = NOTEBOOK_SHARE_TEMPLATE (object);

  switch (property_id)
  {
    case PROP_NOTEBOOK_SHARE_TEMPLATE_NOTEBOOK_GUID:
      g_value_set_string (value, self->notebookGuid);
      break;

    case PROP_NOTEBOOK_SHARE_TEMPLATE_RECIPIENT_THREAD_ID:
      g_value_set_int64 (value, self->recipientThreadId);
      break;

    case PROP_NOTEBOOK_SHARE_TEMPLATE_RECIPIENT_CONTACTS:
      g_value_set_boxed (value, self->recipientContacts);
      break;

    case PROP_NOTEBOOK_SHARE_TEMPLATE_PRIVILEGE:
      g_value_set_int (value, self->privilege);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
notebook_share_template_instance_init (NotebookShareTemplate * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->notebookGuid = NULL;
  object->__isset_notebookGuid = FALSE;
  object->recipientThreadId = 0;
  object->__isset_recipientThreadId = FALSE;
  object->recipientContacts = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_recipientContacts = FALSE;
  object->__isset_privilege = FALSE;
}

static void 
notebook_share_template_finalize (GObject *object)
{
  NotebookShareTemplate *tobject = NOTEBOOK_SHARE_TEMPLATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->notebookGuid != NULL)
  {
    g_free(tobject->notebookGuid);
    tobject->notebookGuid = NULL;
  }
  if (tobject->recipientContacts != NULL)
  {
    g_ptr_array_unref (tobject->recipientContacts);
    tobject->recipientContacts = NULL;
  }
}

static void
notebook_share_template_class_init (NotebookShareTemplateClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = notebook_share_template_read;
  struct_class->write = notebook_share_template_write;

  gobject_class->finalize = notebook_share_template_finalize;
  gobject_class->get_property = notebook_share_template_get_property;
  gobject_class->set_property = notebook_share_template_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTEBOOK_SHARE_TEMPLATE_NOTEBOOK_GUID,
     g_param_spec_string ("notebookGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTEBOOK_SHARE_TEMPLATE_RECIPIENT_THREAD_ID,
     g_param_spec_int64 ("recipientThreadId",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTEBOOK_SHARE_TEMPLATE_RECIPIENT_CONTACTS,
     g_param_spec_boxed ("recipientContacts",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTEBOOK_SHARE_TEMPLATE_PRIVILEGE,
     g_param_spec_int ("privilege",
                       NULL,
                       NULL,
                       0,
                       5,
                       0,
                       G_PARAM_READWRITE));
}

GType
notebook_share_template_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NotebookShareTemplateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) notebook_share_template_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NotebookShareTemplate),
      0, /* n_preallocs */
      (GInstanceInitFunc) notebook_share_template_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NotebookShareTemplateType",
                                   &type_info, 0);
  }

  return type;
}

enum _CreateOrUpdateNotebookSharesResultProperties
{
  PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_0,
  PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_UPDATE_SEQUENCE_NUM,
  PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_MATCHING_SHARES
};

/* reads a create_or_update_notebook_shares_result object */
static gint32
create_or_update_notebook_shares_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CreateOrUpdateNotebookSharesResult * this_object = CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->updateSequenceNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateSequenceNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              SharedNotebook * _elem86 = NULL;
              if ( _elem86 != NULL)
              {
                g_object_unref (_elem86);
              }
              _elem86 = g_object_new (TYPE_SHARED_NOTEBOOK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem86), protocol, error)) < 0)
              {
                g_object_unref (_elem86);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->matchingShares, _elem86);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_matchingShares = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
create_or_update_notebook_shares_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CreateOrUpdateNotebookSharesResult * this_object = CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CreateOrUpdateNotebookSharesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_updateSequenceNum == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateSequenceNum", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->updateSequenceNum, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_matchingShares == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "matchingShares", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i87;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->matchingShares ? this_object->matchingShares->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i87 = 0; i87 < (this_object->matchingShares ? this_object->matchingShares->len : 0); i87++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->matchingShares, i87))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
create_or_update_notebook_shares_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  CreateOrUpdateNotebookSharesResult *self = CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_UPDATE_SEQUENCE_NUM:
      self->updateSequenceNum = g_value_get_int (value);
      self->__isset_updateSequenceNum = TRUE;
      break;

    case PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_MATCHING_SHARES:
      if (self->matchingShares != NULL)
        g_ptr_array_unref (self->matchingShares);
      self->matchingShares = g_value_dup_boxed (value);
      self->__isset_matchingShares = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
create_or_update_notebook_shares_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  CreateOrUpdateNotebookSharesResult *self = CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_UPDATE_SEQUENCE_NUM:
      g_value_set_int (value, self->updateSequenceNum);
      break;

    case PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_MATCHING_SHARES:
      g_value_set_boxed (value, self->matchingShares);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
create_or_update_notebook_shares_result_instance_init (CreateOrUpdateNotebookSharesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->updateSequenceNum = 0;
  object->__isset_updateSequenceNum = FALSE;
  object->matchingShares = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_matchingShares = FALSE;
}

static void 
create_or_update_notebook_shares_result_finalize (GObject *object)
{
  CreateOrUpdateNotebookSharesResult *tobject = CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->matchingShares != NULL)
  {
    g_ptr_array_unref (tobject->matchingShares);
    tobject->matchingShares = NULL;
  }
}

static void
create_or_update_notebook_shares_result_class_init (CreateOrUpdateNotebookSharesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = create_or_update_notebook_shares_result_read;
  struct_class->write = create_or_update_notebook_shares_result_write;

  gobject_class->finalize = create_or_update_notebook_shares_result_finalize;
  gobject_class->get_property = create_or_update_notebook_shares_result_get_property;
  gobject_class->set_property = create_or_update_notebook_shares_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_UPDATE_SEQUENCE_NUM,
     g_param_spec_int ("updateSequenceNum",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_MATCHING_SHARES,
     g_param_spec_boxed ("matchingShares",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
create_or_update_notebook_shares_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CreateOrUpdateNotebookSharesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) create_or_update_notebook_shares_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CreateOrUpdateNotebookSharesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) create_or_update_notebook_shares_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CreateOrUpdateNotebookSharesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteShareRelationshipRestrictionsProperties
{
  PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_0,
  PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_NOTE,
  PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_MODIFY_NOTE,
  PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_FULL_ACCESS
};

/* reads a note_share_relationship_restrictions object */
static gint32
note_share_relationship_restrictions_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteShareRelationshipRestrictions * this_object = NOTE_SHARE_RELATIONSHIP_RESTRICTIONS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->noSetReadNote, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noSetReadNote = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->noSetModifyNote, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noSetModifyNote = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->noSetFullAccess, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noSetFullAccess = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_share_relationship_restrictions_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteShareRelationshipRestrictions * this_object = NOTE_SHARE_RELATIONSHIP_RESTRICTIONS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteShareRelationshipRestrictions", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_noSetReadNote == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noSetReadNote", T_BOOL, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->noSetReadNote, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noSetModifyNote == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noSetModifyNote", T_BOOL, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->noSetModifyNote, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noSetFullAccess == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noSetFullAccess", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->noSetFullAccess, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_share_relationship_restrictions_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  NoteShareRelationshipRestrictions *self = NOTE_SHARE_RELATIONSHIP_RESTRICTIONS (object);

  switch (property_id)
  {
    case PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_NOTE:
      self->noSetReadNote = g_value_get_boolean (value);
      self->__isset_noSetReadNote = TRUE;
      break;

    case PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_MODIFY_NOTE:
      self->noSetModifyNote = g_value_get_boolean (value);
      self->__isset_noSetModifyNote = TRUE;
      break;

    case PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_FULL_ACCESS:
      self->noSetFullAccess = g_value_get_boolean (value);
      self->__isset_noSetFullAccess = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_share_relationship_restrictions_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  NoteShareRelationshipRestrictions *self = NOTE_SHARE_RELATIONSHIP_RESTRICTIONS (object);

  switch (property_id)
  {
    case PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_NOTE:
      g_value_set_boolean (value, self->noSetReadNote);
      break;

    case PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_MODIFY_NOTE:
      g_value_set_boolean (value, self->noSetModifyNote);
      break;

    case PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_FULL_ACCESS:
      g_value_set_boolean (value, self->noSetFullAccess);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_share_relationship_restrictions_instance_init (NoteShareRelationshipRestrictions * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->noSetReadNote = 0;
  object->__isset_noSetReadNote = FALSE;
  object->noSetModifyNote = 0;
  object->__isset_noSetModifyNote = FALSE;
  object->noSetFullAccess = 0;
  object->__isset_noSetFullAccess = FALSE;
}

static void 
note_share_relationship_restrictions_finalize (GObject *object)
{
  NoteShareRelationshipRestrictions *tobject = NOTE_SHARE_RELATIONSHIP_RESTRICTIONS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
note_share_relationship_restrictions_class_init (NoteShareRelationshipRestrictionsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_share_relationship_restrictions_read;
  struct_class->write = note_share_relationship_restrictions_write;

  gobject_class->finalize = note_share_relationship_restrictions_finalize;
  gobject_class->get_property = note_share_relationship_restrictions_get_property;
  gobject_class->set_property = note_share_relationship_restrictions_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_READ_NOTE,
     g_param_spec_boolean ("noSetReadNote",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_MODIFY_NOTE,
     g_param_spec_boolean ("noSetModifyNote",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS_NO_SET_FULL_ACCESS,
     g_param_spec_boolean ("noSetFullAccess",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_share_relationship_restrictions_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteShareRelationshipRestrictionsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_share_relationship_restrictions_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteShareRelationshipRestrictions),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_share_relationship_restrictions_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteShareRelationshipRestrictionsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteMemberShareRelationshipProperties
{
  PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_0,
  PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_DISPLAY_NAME,
  PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_RECIPIENT_USER_ID,
  PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_PRIVILEGE,
  PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_RESTRICTIONS,
  PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_SHARER_USER_ID
};

/* reads a note_member_share_relationship object */
static gint32
note_member_share_relationship_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteMemberShareRelationship * this_object = NOTE_MEMBER_SHARE_RELATIONSHIP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->displayName != NULL)
          {
            g_free(this_object->displayName);
            this_object->displayName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->displayName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_displayName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->recipientUserId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_recipientUserId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast88;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast88, error)) < 0)
            return -1;
          xfer += ret;
          this_object->privilege = (SharedNotePrivilegeLevel)ecast88;
          this_object->__isset_privilege = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->restrictions), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_restrictions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->sharerUserId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sharerUserId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_member_share_relationship_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteMemberShareRelationship * this_object = NOTE_MEMBER_SHARE_RELATIONSHIP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteMemberShareRelationship", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_displayName == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "displayName", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->displayName, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_recipientUserId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientUserId", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->recipientUserId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_privilege == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "privilege", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->privilege, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_restrictions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "restrictions", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->restrictions), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_sharerUserId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sharerUserId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->sharerUserId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_member_share_relationship_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteMemberShareRelationship *self = NOTE_MEMBER_SHARE_RELATIONSHIP (object);

  switch (property_id)
  {
    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_DISPLAY_NAME:
      if (self->displayName != NULL)
        g_free (self->displayName);
      self->displayName = g_value_dup_string (value);
      self->__isset_displayName = TRUE;
      break;

    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_RECIPIENT_USER_ID:
      self->recipientUserId = g_value_get_int (value);
      self->__isset_recipientUserId = TRUE;
      break;

    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_PRIVILEGE:
      self->privilege = g_value_get_int (value);
      self->__isset_privilege = TRUE;
      break;

    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_RESTRICTIONS:
      if (self->restrictions != NULL)
        g_object_unref (self->restrictions);
      self->restrictions = g_value_dup_object (value);
      self->__isset_restrictions = TRUE;
      break;

    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_SHARER_USER_ID:
      self->sharerUserId = g_value_get_int (value);
      self->__isset_sharerUserId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_member_share_relationship_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteMemberShareRelationship *self = NOTE_MEMBER_SHARE_RELATIONSHIP (object);

  switch (property_id)
  {
    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_DISPLAY_NAME:
      g_value_set_string (value, self->displayName);
      break;

    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_RECIPIENT_USER_ID:
      g_value_set_int (value, self->recipientUserId);
      break;

    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_PRIVILEGE:
      g_value_set_int (value, self->privilege);
      break;

    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_RESTRICTIONS:
      g_value_set_object (value, self->restrictions);
      break;

    case PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_SHARER_USER_ID:
      g_value_set_int (value, self->sharerUserId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_member_share_relationship_instance_init (NoteMemberShareRelationship * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->displayName = NULL;
  object->__isset_displayName = FALSE;
  object->recipientUserId = 0;
  object->__isset_recipientUserId = FALSE;
  object->__isset_privilege = FALSE;
  object->restrictions = g_object_new (TYPE_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS, NULL);
  object->__isset_restrictions = FALSE;
  object->sharerUserId = 0;
  object->__isset_sharerUserId = FALSE;
}

static void 
note_member_share_relationship_finalize (GObject *object)
{
  NoteMemberShareRelationship *tobject = NOTE_MEMBER_SHARE_RELATIONSHIP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->displayName != NULL)
  {
    g_free(tobject->displayName);
    tobject->displayName = NULL;
  }
  if (tobject->restrictions != NULL)
  {
    g_object_unref(tobject->restrictions);
    tobject->restrictions = NULL;
  }
}

static void
note_member_share_relationship_class_init (NoteMemberShareRelationshipClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_member_share_relationship_read;
  struct_class->write = note_member_share_relationship_write;

  gobject_class->finalize = note_member_share_relationship_finalize;
  gobject_class->get_property = note_member_share_relationship_get_property;
  gobject_class->set_property = note_member_share_relationship_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_DISPLAY_NAME,
     g_param_spec_string ("displayName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_RECIPIENT_USER_ID,
     g_param_spec_int ("recipientUserId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_PRIVILEGE,
     g_param_spec_int ("privilege",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_RESTRICTIONS,
     g_param_spec_object ("restrictions",
                         NULL,
                         NULL,
                         TYPE_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_MEMBER_SHARE_RELATIONSHIP_SHARER_USER_ID,
     g_param_spec_int ("sharerUserId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
note_member_share_relationship_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteMemberShareRelationshipClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_member_share_relationship_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteMemberShareRelationship),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_member_share_relationship_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteMemberShareRelationshipType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteInvitationShareRelationshipProperties
{
  PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_0,
  PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_DISPLAY_NAME,
  PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_RECIPIENT_IDENTITY_ID,
  PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_PRIVILEGE,
  PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_SHARER_USER_ID
};

/* reads a note_invitation_share_relationship object */
static gint32
note_invitation_share_relationship_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteInvitationShareRelationship * this_object = NOTE_INVITATION_SHARE_RELATIONSHIP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->displayName != NULL)
          {
            g_free(this_object->displayName);
            this_object->displayName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->displayName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_displayName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->recipientIdentityId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_recipientIdentityId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast89;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast89, error)) < 0)
            return -1;
          xfer += ret;
          this_object->privilege = (SharedNotePrivilegeLevel)ecast89;
          this_object->__isset_privilege = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->sharerUserId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sharerUserId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_invitation_share_relationship_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteInvitationShareRelationship * this_object = NOTE_INVITATION_SHARE_RELATIONSHIP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteInvitationShareRelationship", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_displayName == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "displayName", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->displayName, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_recipientIdentityId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientIdentityId", T_I64, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->recipientIdentityId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_privilege == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "privilege", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->privilege, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_sharerUserId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sharerUserId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->sharerUserId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_invitation_share_relationship_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  NoteInvitationShareRelationship *self = NOTE_INVITATION_SHARE_RELATIONSHIP (object);

  switch (property_id)
  {
    case PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_DISPLAY_NAME:
      if (self->displayName != NULL)
        g_free (self->displayName);
      self->displayName = g_value_dup_string (value);
      self->__isset_displayName = TRUE;
      break;

    case PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_RECIPIENT_IDENTITY_ID:
      self->recipientIdentityId = g_value_get_int64 (value);
      self->__isset_recipientIdentityId = TRUE;
      break;

    case PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_PRIVILEGE:
      self->privilege = g_value_get_int (value);
      self->__isset_privilege = TRUE;
      break;

    case PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_SHARER_USER_ID:
      self->sharerUserId = g_value_get_int (value);
      self->__isset_sharerUserId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_invitation_share_relationship_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  NoteInvitationShareRelationship *self = NOTE_INVITATION_SHARE_RELATIONSHIP (object);

  switch (property_id)
  {
    case PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_DISPLAY_NAME:
      g_value_set_string (value, self->displayName);
      break;

    case PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_RECIPIENT_IDENTITY_ID:
      g_value_set_int64 (value, self->recipientIdentityId);
      break;

    case PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_PRIVILEGE:
      g_value_set_int (value, self->privilege);
      break;

    case PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_SHARER_USER_ID:
      g_value_set_int (value, self->sharerUserId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_invitation_share_relationship_instance_init (NoteInvitationShareRelationship * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->displayName = NULL;
  object->__isset_displayName = FALSE;
  object->recipientIdentityId = 0;
  object->__isset_recipientIdentityId = FALSE;
  object->__isset_privilege = FALSE;
  object->sharerUserId = 0;
  object->__isset_sharerUserId = FALSE;
}

static void 
note_invitation_share_relationship_finalize (GObject *object)
{
  NoteInvitationShareRelationship *tobject = NOTE_INVITATION_SHARE_RELATIONSHIP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->displayName != NULL)
  {
    g_free(tobject->displayName);
    tobject->displayName = NULL;
  }
}

static void
note_invitation_share_relationship_class_init (NoteInvitationShareRelationshipClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_invitation_share_relationship_read;
  struct_class->write = note_invitation_share_relationship_write;

  gobject_class->finalize = note_invitation_share_relationship_finalize;
  gobject_class->get_property = note_invitation_share_relationship_get_property;
  gobject_class->set_property = note_invitation_share_relationship_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_DISPLAY_NAME,
     g_param_spec_string ("displayName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_RECIPIENT_IDENTITY_ID,
     g_param_spec_int64 ("recipientIdentityId",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_PRIVILEGE,
     g_param_spec_int ("privilege",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_INVITATION_SHARE_RELATIONSHIP_SHARER_USER_ID,
     g_param_spec_int ("sharerUserId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
note_invitation_share_relationship_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteInvitationShareRelationshipClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_invitation_share_relationship_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteInvitationShareRelationship),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_invitation_share_relationship_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteInvitationShareRelationshipType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteShareRelationshipsProperties
{
  PROP_NOTE_SHARE_RELATIONSHIPS_0,
  PROP_NOTE_SHARE_RELATIONSHIPS_INVITATIONS,
  PROP_NOTE_SHARE_RELATIONSHIPS_MEMBERSHIPS,
  PROP_NOTE_SHARE_RELATIONSHIPS_INVITATION_RESTRICTIONS
};

/* reads a note_share_relationships object */
static gint32
note_share_relationships_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteShareRelationships * this_object = NOTE_SHARE_RELATIONSHIPS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              NoteInvitationShareRelationship * _elem90 = NULL;
              if ( _elem90 != NULL)
              {
                g_object_unref (_elem90);
              }
              _elem90 = g_object_new (TYPE_NOTE_INVITATION_SHARE_RELATIONSHIP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem90), protocol, error)) < 0)
              {
                g_object_unref (_elem90);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->invitations, _elem90);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_invitations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              NoteMemberShareRelationship * _elem91 = NULL;
              if ( _elem91 != NULL)
              {
                g_object_unref (_elem91);
              }
              _elem91 = g_object_new (TYPE_NOTE_MEMBER_SHARE_RELATIONSHIP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem91), protocol, error)) < 0)
              {
                g_object_unref (_elem91);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->memberships, _elem91);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_memberships = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->invitationRestrictions), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_invitationRestrictions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_share_relationships_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteShareRelationships * this_object = NOTE_SHARE_RELATIONSHIPS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteShareRelationships", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_invitations == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "invitations", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i92;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->invitations ? this_object->invitations->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i92 = 0; i92 < (this_object->invitations ? this_object->invitations->len : 0); i92++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->invitations, i92))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_memberships == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "memberships", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i93;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->memberships ? this_object->memberships->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i93 = 0; i93 < (this_object->memberships ? this_object->memberships->len : 0); i93++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->memberships, i93))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_invitationRestrictions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "invitationRestrictions", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->invitationRestrictions), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_share_relationships_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  NoteShareRelationships *self = NOTE_SHARE_RELATIONSHIPS (object);

  switch (property_id)
  {
    case PROP_NOTE_SHARE_RELATIONSHIPS_INVITATIONS:
      if (self->invitations != NULL)
        g_ptr_array_unref (self->invitations);
      self->invitations = g_value_dup_boxed (value);
      self->__isset_invitations = TRUE;
      break;

    case PROP_NOTE_SHARE_RELATIONSHIPS_MEMBERSHIPS:
      if (self->memberships != NULL)
        g_ptr_array_unref (self->memberships);
      self->memberships = g_value_dup_boxed (value);
      self->__isset_memberships = TRUE;
      break;

    case PROP_NOTE_SHARE_RELATIONSHIPS_INVITATION_RESTRICTIONS:
      if (self->invitationRestrictions != NULL)
        g_object_unref (self->invitationRestrictions);
      self->invitationRestrictions = g_value_dup_object (value);
      self->__isset_invitationRestrictions = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_share_relationships_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  NoteShareRelationships *self = NOTE_SHARE_RELATIONSHIPS (object);

  switch (property_id)
  {
    case PROP_NOTE_SHARE_RELATIONSHIPS_INVITATIONS:
      g_value_set_boxed (value, self->invitations);
      break;

    case PROP_NOTE_SHARE_RELATIONSHIPS_MEMBERSHIPS:
      g_value_set_boxed (value, self->memberships);
      break;

    case PROP_NOTE_SHARE_RELATIONSHIPS_INVITATION_RESTRICTIONS:
      g_value_set_object (value, self->invitationRestrictions);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_share_relationships_instance_init (NoteShareRelationships * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->invitations = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_invitations = FALSE;
  object->memberships = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_memberships = FALSE;
  object->invitationRestrictions = g_object_new (TYPE_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS, NULL);
  object->__isset_invitationRestrictions = FALSE;
}

static void 
note_share_relationships_finalize (GObject *object)
{
  NoteShareRelationships *tobject = NOTE_SHARE_RELATIONSHIPS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->invitations != NULL)
  {
    g_ptr_array_unref (tobject->invitations);
    tobject->invitations = NULL;
  }
  if (tobject->memberships != NULL)
  {
    g_ptr_array_unref (tobject->memberships);
    tobject->memberships = NULL;
  }
  if (tobject->invitationRestrictions != NULL)
  {
    g_object_unref(tobject->invitationRestrictions);
    tobject->invitationRestrictions = NULL;
  }
}

static void
note_share_relationships_class_init (NoteShareRelationshipsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_share_relationships_read;
  struct_class->write = note_share_relationships_write;

  gobject_class->finalize = note_share_relationships_finalize;
  gobject_class->get_property = note_share_relationships_get_property;
  gobject_class->set_property = note_share_relationships_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_SHARE_RELATIONSHIPS_INVITATIONS,
     g_param_spec_boxed ("invitations",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_SHARE_RELATIONSHIPS_MEMBERSHIPS,
     g_param_spec_boxed ("memberships",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_SHARE_RELATIONSHIPS_INVITATION_RESTRICTIONS,
     g_param_spec_object ("invitationRestrictions",
                         NULL,
                         NULL,
                         TYPE_NOTE_SHARE_RELATIONSHIP_RESTRICTIONS,
                         G_PARAM_READWRITE));
}

GType
note_share_relationships_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteShareRelationshipsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_share_relationships_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteShareRelationships),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_share_relationships_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteShareRelationshipsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ManageNoteSharesParametersProperties
{
  PROP_MANAGE_NOTE_SHARES_PARAMETERS_0,
  PROP_MANAGE_NOTE_SHARES_PARAMETERS_NOTE_GUID,
  PROP_MANAGE_NOTE_SHARES_PARAMETERS_MEMBERSHIPS_TO_UPDATE,
  PROP_MANAGE_NOTE_SHARES_PARAMETERS_INVITATIONS_TO_UPDATE,
  PROP_MANAGE_NOTE_SHARES_PARAMETERS_MEMBERSHIPS_TO_UNSHARE,
  PROP_MANAGE_NOTE_SHARES_PARAMETERS_INVITATIONS_TO_UNSHARE
};

/* reads a manage_note_shares_parameters object */
static gint32
manage_note_shares_parameters_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ManageNoteSharesParameters * this_object = MANAGE_NOTE_SHARES_PARAMETERS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->noteGuid != NULL)
          {
            g_free(this_object->noteGuid);
            this_object->noteGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              NoteMemberShareRelationship * _elem94 = NULL;
              if ( _elem94 != NULL)
              {
                g_object_unref (_elem94);
              }
              _elem94 = g_object_new (TYPE_NOTE_MEMBER_SHARE_RELATIONSHIP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem94), protocol, error)) < 0)
              {
                g_object_unref (_elem94);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->membershipsToUpdate, _elem94);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_membershipsToUpdate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              NoteInvitationShareRelationship * _elem95 = NULL;
              if ( _elem95 != NULL)
              {
                g_object_unref (_elem95);
              }
              _elem95 = g_object_new (TYPE_NOTE_INVITATION_SHARE_RELATIONSHIP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem95), protocol, error)) < 0)
              {
                g_object_unref (_elem95);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->invitationsToUpdate, _elem95);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_invitationsToUpdate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem96 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem96, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->membershipsToUnshare, _elem96, 1);
              g_free (_elem96);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_membershipsToUnshare = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem97 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem97, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->invitationsToUnshare, _elem97, 1);
              g_free (_elem97);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_invitationsToUnshare = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
manage_note_shares_parameters_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ManageNoteSharesParameters * this_object = MANAGE_NOTE_SHARES_PARAMETERS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ManageNoteSharesParameters", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_noteGuid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->noteGuid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_membershipsToUpdate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "membershipsToUpdate", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i98;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->membershipsToUpdate ? this_object->membershipsToUpdate->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i98 = 0; i98 < (this_object->membershipsToUpdate ? this_object->membershipsToUpdate->len : 0); i98++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->membershipsToUpdate, i98))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_invitationsToUpdate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "invitationsToUpdate", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i99;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->invitationsToUpdate ? this_object->invitationsToUpdate->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i99 = 0; i99 < (this_object->invitationsToUpdate ? this_object->invitationsToUpdate->len : 0); i99++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->invitationsToUpdate, i99))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_membershipsToUnshare == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "membershipsToUnshare", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i100;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->membershipsToUnshare ? this_object->membershipsToUnshare->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i100 = 0; i100 < (this_object->membershipsToUnshare ? this_object->membershipsToUnshare->len : 0); i100++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->membershipsToUnshare, gint32, i100)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_invitationsToUnshare == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "invitationsToUnshare", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i101;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->invitationsToUnshare ? this_object->invitationsToUnshare->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i101 = 0; i101 < (this_object->invitationsToUnshare ? this_object->invitationsToUnshare->len : 0); i101++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->invitationsToUnshare, gint64, i101)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
manage_note_shares_parameters_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  ManageNoteSharesParameters *self = MANAGE_NOTE_SHARES_PARAMETERS (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_NOTE_GUID:
      if (self->noteGuid != NULL)
        g_free (self->noteGuid);
      self->noteGuid = g_value_dup_string (value);
      self->__isset_noteGuid = TRUE;
      break;

    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_MEMBERSHIPS_TO_UPDATE:
      if (self->membershipsToUpdate != NULL)
        g_ptr_array_unref (self->membershipsToUpdate);
      self->membershipsToUpdate = g_value_dup_boxed (value);
      self->__isset_membershipsToUpdate = TRUE;
      break;

    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_INVITATIONS_TO_UPDATE:
      if (self->invitationsToUpdate != NULL)
        g_ptr_array_unref (self->invitationsToUpdate);
      self->invitationsToUpdate = g_value_dup_boxed (value);
      self->__isset_invitationsToUpdate = TRUE;
      break;

    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_MEMBERSHIPS_TO_UNSHARE:
      if (self->membershipsToUnshare != NULL)
        g_ptr_array_unref (self->membershipsToUnshare);
      self->membershipsToUnshare = g_value_dup_boxed (value);
      self->__isset_membershipsToUnshare = TRUE;
      break;

    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_INVITATIONS_TO_UNSHARE:
      if (self->invitationsToUnshare != NULL)
        g_ptr_array_unref (self->invitationsToUnshare);
      self->invitationsToUnshare = g_value_dup_boxed (value);
      self->__isset_invitationsToUnshare = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
manage_note_shares_parameters_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  ManageNoteSharesParameters *self = MANAGE_NOTE_SHARES_PARAMETERS (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_NOTE_GUID:
      g_value_set_string (value, self->noteGuid);
      break;

    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_MEMBERSHIPS_TO_UPDATE:
      g_value_set_boxed (value, self->membershipsToUpdate);
      break;

    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_INVITATIONS_TO_UPDATE:
      g_value_set_boxed (value, self->invitationsToUpdate);
      break;

    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_MEMBERSHIPS_TO_UNSHARE:
      g_value_set_boxed (value, self->membershipsToUnshare);
      break;

    case PROP_MANAGE_NOTE_SHARES_PARAMETERS_INVITATIONS_TO_UNSHARE:
      g_value_set_boxed (value, self->invitationsToUnshare);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
manage_note_shares_parameters_instance_init (ManageNoteSharesParameters * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->noteGuid = NULL;
  object->__isset_noteGuid = FALSE;
  object->membershipsToUpdate = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_membershipsToUpdate = FALSE;
  object->invitationsToUpdate = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_invitationsToUpdate = FALSE;
  object->membershipsToUnshare = g_ptr_array_new_with_free_func (g_free);
  object->__isset_membershipsToUnshare = FALSE;
  object->invitationsToUnshare = g_ptr_array_new_with_free_func (g_free);
  object->__isset_invitationsToUnshare = FALSE;
}

static void 
manage_note_shares_parameters_finalize (GObject *object)
{
  ManageNoteSharesParameters *tobject = MANAGE_NOTE_SHARES_PARAMETERS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->noteGuid != NULL)
  {
    g_free(tobject->noteGuid);
    tobject->noteGuid = NULL;
  }
  if (tobject->membershipsToUpdate != NULL)
  {
    g_ptr_array_unref (tobject->membershipsToUpdate);
    tobject->membershipsToUpdate = NULL;
  }
  if (tobject->invitationsToUpdate != NULL)
  {
    g_ptr_array_unref (tobject->invitationsToUpdate);
    tobject->invitationsToUpdate = NULL;
  }
  if (tobject->membershipsToUnshare != NULL)
  {
    g_ptr_array_unref (tobject->membershipsToUnshare);
    tobject->membershipsToUnshare = NULL;
  }
  if (tobject->invitationsToUnshare != NULL)
  {
    g_ptr_array_unref (tobject->invitationsToUnshare);
    tobject->invitationsToUnshare = NULL;
  }
}

static void
manage_note_shares_parameters_class_init (ManageNoteSharesParametersClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = manage_note_shares_parameters_read;
  struct_class->write = manage_note_shares_parameters_write;

  gobject_class->finalize = manage_note_shares_parameters_finalize;
  gobject_class->get_property = manage_note_shares_parameters_get_property;
  gobject_class->set_property = manage_note_shares_parameters_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_PARAMETERS_NOTE_GUID,
     g_param_spec_string ("noteGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_PARAMETERS_MEMBERSHIPS_TO_UPDATE,
     g_param_spec_boxed ("membershipsToUpdate",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_PARAMETERS_INVITATIONS_TO_UPDATE,
     g_param_spec_boxed ("invitationsToUpdate",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_PARAMETERS_MEMBERSHIPS_TO_UNSHARE,
     g_param_spec_boxed ("membershipsToUnshare",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_PARAMETERS_INVITATIONS_TO_UNSHARE,
     g_param_spec_boxed ("invitationsToUnshare",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
manage_note_shares_parameters_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ManageNoteSharesParametersClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) manage_note_shares_parameters_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ManageNoteSharesParameters),
      0, /* n_preallocs */
      (GInstanceInitFunc) manage_note_shares_parameters_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ManageNoteSharesParametersType",
                                   &type_info, 0);
  }

  return type;
}

enum _ManageNoteSharesErrorProperties
{
  PROP_MANAGE_NOTE_SHARES_ERROR_0,
  PROP_MANAGE_NOTE_SHARES_ERROR_IDENTITY_I_D,
  PROP_MANAGE_NOTE_SHARES_ERROR_USER_I_D,
  PROP_MANAGE_NOTE_SHARES_ERROR_USER_EXCEPTION,
  PROP_MANAGE_NOTE_SHARES_ERROR_NOT_FOUND_EXCEPTION
};

/* reads a manage_note_shares_error object */
static gint32
manage_note_shares_error_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ManageNoteSharesError * this_object = MANAGE_NOTE_SHARES_ERROR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->identityID, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_identityID = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->userID, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_userID = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
manage_note_shares_error_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ManageNoteSharesError * this_object = MANAGE_NOTE_SHARES_ERROR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ManageNoteSharesError", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_identityID == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "identityID", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->identityID, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userID == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userID", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->userID, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
manage_note_shares_error_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  ManageNoteSharesError *self = MANAGE_NOTE_SHARES_ERROR (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTE_SHARES_ERROR_IDENTITY_I_D:
      self->identityID = g_value_get_int64 (value);
      self->__isset_identityID = TRUE;
      break;

    case PROP_MANAGE_NOTE_SHARES_ERROR_USER_I_D:
      self->userID = g_value_get_int (value);
      self->__isset_userID = TRUE;
      break;

    case PROP_MANAGE_NOTE_SHARES_ERROR_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_MANAGE_NOTE_SHARES_ERROR_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
manage_note_shares_error_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  ManageNoteSharesError *self = MANAGE_NOTE_SHARES_ERROR (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTE_SHARES_ERROR_IDENTITY_I_D:
      g_value_set_int64 (value, self->identityID);
      break;

    case PROP_MANAGE_NOTE_SHARES_ERROR_USER_I_D:
      g_value_set_int (value, self->userID);
      break;

    case PROP_MANAGE_NOTE_SHARES_ERROR_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_MANAGE_NOTE_SHARES_ERROR_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
manage_note_shares_error_instance_init (ManageNoteSharesError * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->identityID = 0;
  object->__isset_identityID = FALSE;
  object->userID = 0;
  object->__isset_userID = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
manage_note_shares_error_finalize (GObject *object)
{
  ManageNoteSharesError *tobject = MANAGE_NOTE_SHARES_ERROR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
manage_note_shares_error_class_init (ManageNoteSharesErrorClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = manage_note_shares_error_read;
  struct_class->write = manage_note_shares_error_write;

  gobject_class->finalize = manage_note_shares_error_finalize;
  gobject_class->get_property = manage_note_shares_error_get_property;
  gobject_class->set_property = manage_note_shares_error_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_ERROR_IDENTITY_I_D,
     g_param_spec_int64 ("identityID",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_ERROR_USER_I_D,
     g_param_spec_int ("userID",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_ERROR_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_ERROR_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
manage_note_shares_error_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ManageNoteSharesErrorClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) manage_note_shares_error_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ManageNoteSharesError),
      0, /* n_preallocs */
      (GInstanceInitFunc) manage_note_shares_error_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ManageNoteSharesErrorType",
                                   &type_info, 0);
  }

  return type;
}

enum _ManageNoteSharesResultProperties
{
  PROP_MANAGE_NOTE_SHARES_RESULT_0,
  PROP_MANAGE_NOTE_SHARES_RESULT_ERRORS
};

/* reads a manage_note_shares_result object */
static gint32
manage_note_shares_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ManageNoteSharesResult * this_object = MANAGE_NOTE_SHARES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ManageNoteSharesError * _elem102 = NULL;
              if ( _elem102 != NULL)
              {
                g_object_unref (_elem102);
              }
              _elem102 = g_object_new (TYPE_MANAGE_NOTE_SHARES_ERROR, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem102), protocol, error)) < 0)
              {
                g_object_unref (_elem102);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->errors, _elem102);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_errors = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
manage_note_shares_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ManageNoteSharesResult * this_object = MANAGE_NOTE_SHARES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ManageNoteSharesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_errors == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "errors", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i103;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->errors ? this_object->errors->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i103 = 0; i103 < (this_object->errors ? this_object->errors->len : 0); i103++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->errors, i103))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
manage_note_shares_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ManageNoteSharesResult *self = MANAGE_NOTE_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTE_SHARES_RESULT_ERRORS:
      if (self->errors != NULL)
        g_ptr_array_unref (self->errors);
      self->errors = g_value_dup_boxed (value);
      self->__isset_errors = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
manage_note_shares_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ManageNoteSharesResult *self = MANAGE_NOTE_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_MANAGE_NOTE_SHARES_RESULT_ERRORS:
      g_value_set_boxed (value, self->errors);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
manage_note_shares_result_instance_init (ManageNoteSharesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errors = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_errors = FALSE;
}

static void 
manage_note_shares_result_finalize (GObject *object)
{
  ManageNoteSharesResult *tobject = MANAGE_NOTE_SHARES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->errors != NULL)
  {
    g_ptr_array_unref (tobject->errors);
    tobject->errors = NULL;
  }
}

static void
manage_note_shares_result_class_init (ManageNoteSharesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = manage_note_shares_result_read;
  struct_class->write = manage_note_shares_result_write;

  gobject_class->finalize = manage_note_shares_result_finalize;
  gobject_class->get_property = manage_note_shares_result_get_property;
  gobject_class->set_property = manage_note_shares_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_MANAGE_NOTE_SHARES_RESULT_ERRORS,
     g_param_spec_boxed ("errors",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
manage_note_shares_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ManageNoteSharesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) manage_note_shares_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ManageNoteSharesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) manage_note_shares_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ManageNoteSharesResultType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _NoteStoreGetSyncStateArgsProperties
{
  PROP_NOTE_STORE_GET_SYNC_STATE_ARGS_0,
  PROP_NOTE_STORE_GET_SYNC_STATE_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_get_sync_state_args object */
static gint32
note_store_get_sync_state_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetSyncStateArgs * this_object = NOTE_STORE_GET_SYNC_STATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_sync_state_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetSyncStateArgs * this_object = NOTE_STORE_GET_SYNC_STATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetSyncStateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_sync_state_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreGetSyncStateArgs *self = NOTE_STORE_GET_SYNC_STATE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SYNC_STATE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_sync_state_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreGetSyncStateArgs *self = NOTE_STORE_GET_SYNC_STATE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SYNC_STATE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_sync_state_args_instance_init (NoteStoreGetSyncStateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_get_sync_state_args_finalize (GObject *object)
{
  NoteStoreGetSyncStateArgs *tobject = NOTE_STORE_GET_SYNC_STATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_get_sync_state_args_class_init (NoteStoreGetSyncStateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_sync_state_args_read;
  struct_class->write = note_store_get_sync_state_args_write;

  gobject_class->finalize = note_store_get_sync_state_args_finalize;
  gobject_class->get_property = note_store_get_sync_state_args_get_property;
  gobject_class->set_property = note_store_get_sync_state_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SYNC_STATE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_sync_state_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetSyncStateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_sync_state_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetSyncStateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_sync_state_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetSyncStateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetSyncStateResultProperties
{
  PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_0,
  PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_get_sync_state_result object */
static gint32
note_store_get_sync_state_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetSyncStateResult * this_object = NOTE_STORE_GET_SYNC_STATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_sync_state_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetSyncStateResult * this_object = NOTE_STORE_GET_SYNC_STATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetSyncStateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_sync_state_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreGetSyncStateResult *self = NOTE_STORE_GET_SYNC_STATE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_sync_state_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreGetSyncStateResult *self = NOTE_STORE_GET_SYNC_STATE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_sync_state_result_instance_init (NoteStoreGetSyncStateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SYNC_STATE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_get_sync_state_result_finalize (GObject *object)
{
  NoteStoreGetSyncStateResult *tobject = NOTE_STORE_GET_SYNC_STATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_get_sync_state_result_class_init (NoteStoreGetSyncStateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_sync_state_result_read;
  struct_class->write = note_store_get_sync_state_result_write;

  gobject_class->finalize = note_store_get_sync_state_result_finalize;
  gobject_class->get_property = note_store_get_sync_state_result_get_property;
  gobject_class->set_property = note_store_get_sync_state_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SYNC_STATE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SYNC_STATE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_sync_state_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetSyncStateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_sync_state_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetSyncStateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_sync_state_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetSyncStateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetFilteredSyncChunkArgsProperties
{
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_0,
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_AFTER_U_S_N,
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_MAX_ENTRIES,
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_FILTER
};

/* reads a note_store_get_filtered_sync_chunk_args object */
static gint32
note_store_get_filtered_sync_chunk_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetFilteredSyncChunkArgs * this_object = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->afterUSN, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_afterUSN = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxEntries, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxEntries = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_filtered_sync_chunk_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetFilteredSyncChunkArgs * this_object = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetFilteredSyncChunkArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "afterUSN", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->afterUSN, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxEntries", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxEntries, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_filtered_sync_chunk_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreGetFilteredSyncChunkArgs *self = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_AFTER_U_S_N:
      self->afterUSN = g_value_get_int (value);
      self->__isset_afterUSN = TRUE;
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_MAX_ENTRIES:
      self->maxEntries = g_value_get_int (value);
      self->__isset_maxEntries = TRUE;
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_filtered_sync_chunk_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreGetFilteredSyncChunkArgs *self = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_AFTER_U_S_N:
      g_value_set_int (value, self->afterUSN);
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_MAX_ENTRIES:
      g_value_set_int (value, self->maxEntries);
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_FILTER:
      g_value_set_object (value, self->filter);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_filtered_sync_chunk_args_instance_init (NoteStoreGetFilteredSyncChunkArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->afterUSN = 0;
  object->__isset_afterUSN = FALSE;
  object->maxEntries = 0;
  object->__isset_maxEntries = FALSE;
  object->filter = g_object_new (TYPE_SYNC_CHUNK_FILTER, NULL);
  object->__isset_filter = FALSE;
}

static void 
note_store_get_filtered_sync_chunk_args_finalize (GObject *object)
{
  NoteStoreGetFilteredSyncChunkArgs *tobject = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
}

static void
note_store_get_filtered_sync_chunk_args_class_init (NoteStoreGetFilteredSyncChunkArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_filtered_sync_chunk_args_read;
  struct_class->write = note_store_get_filtered_sync_chunk_args_write;

  gobject_class->finalize = note_store_get_filtered_sync_chunk_args_finalize;
  gobject_class->get_property = note_store_get_filtered_sync_chunk_args_get_property;
  gobject_class->set_property = note_store_get_filtered_sync_chunk_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_AFTER_U_S_N,
     g_param_spec_int ("afterUSN",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_MAX_ENTRIES,
     g_param_spec_int ("maxEntries",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_SYNC_CHUNK_FILTER,
                         G_PARAM_READWRITE));
}

GType
note_store_get_filtered_sync_chunk_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetFilteredSyncChunkArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_filtered_sync_chunk_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetFilteredSyncChunkArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_filtered_sync_chunk_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetFilteredSyncChunkArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetFilteredSyncChunkResultProperties
{
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_0,
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_get_filtered_sync_chunk_result object */
static gint32
note_store_get_filtered_sync_chunk_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetFilteredSyncChunkResult * this_object = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_filtered_sync_chunk_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetFilteredSyncChunkResult * this_object = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetFilteredSyncChunkResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_filtered_sync_chunk_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreGetFilteredSyncChunkResult *self = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_filtered_sync_chunk_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreGetFilteredSyncChunkResult *self = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_filtered_sync_chunk_result_instance_init (NoteStoreGetFilteredSyncChunkResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SYNC_CHUNK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_get_filtered_sync_chunk_result_finalize (GObject *object)
{
  NoteStoreGetFilteredSyncChunkResult *tobject = NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_get_filtered_sync_chunk_result_class_init (NoteStoreGetFilteredSyncChunkResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_filtered_sync_chunk_result_read;
  struct_class->write = note_store_get_filtered_sync_chunk_result_write;

  gobject_class->finalize = note_store_get_filtered_sync_chunk_result_finalize;
  gobject_class->get_property = note_store_get_filtered_sync_chunk_result_get_property;
  gobject_class->set_property = note_store_get_filtered_sync_chunk_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SYNC_CHUNK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_filtered_sync_chunk_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetFilteredSyncChunkResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_filtered_sync_chunk_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetFilteredSyncChunkResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_filtered_sync_chunk_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetFilteredSyncChunkResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetLinkedNotebookSyncStateArgsProperties
{
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_0,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_LINKED_NOTEBOOK
};

/* reads a note_store_get_linked_notebook_sync_state_args object */
static gint32
note_store_get_linked_notebook_sync_state_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetLinkedNotebookSyncStateArgs * this_object = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->linkedNotebook), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_linkedNotebook = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_linked_notebook_sync_state_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetLinkedNotebookSyncStateArgs * this_object = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetLinkedNotebookSyncStateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebook", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->linkedNotebook), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_linked_notebook_sync_state_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  NoteStoreGetLinkedNotebookSyncStateArgs *self = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_LINKED_NOTEBOOK:
      if (self->linkedNotebook != NULL)
        g_object_unref (self->linkedNotebook);
      self->linkedNotebook = g_value_dup_object (value);
      self->__isset_linkedNotebook = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_linked_notebook_sync_state_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  NoteStoreGetLinkedNotebookSyncStateArgs *self = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_LINKED_NOTEBOOK:
      g_value_set_object (value, self->linkedNotebook);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_linked_notebook_sync_state_args_instance_init (NoteStoreGetLinkedNotebookSyncStateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->linkedNotebook = g_object_new (TYPE_LINKED_NOTEBOOK, NULL);
  object->__isset_linkedNotebook = FALSE;
}

static void 
note_store_get_linked_notebook_sync_state_args_finalize (GObject *object)
{
  NoteStoreGetLinkedNotebookSyncStateArgs *tobject = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->linkedNotebook != NULL)
  {
    g_object_unref(tobject->linkedNotebook);
    tobject->linkedNotebook = NULL;
  }
}

static void
note_store_get_linked_notebook_sync_state_args_class_init (NoteStoreGetLinkedNotebookSyncStateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_linked_notebook_sync_state_args_read;
  struct_class->write = note_store_get_linked_notebook_sync_state_args_write;

  gobject_class->finalize = note_store_get_linked_notebook_sync_state_args_finalize;
  gobject_class->get_property = note_store_get_linked_notebook_sync_state_args_get_property;
  gobject_class->set_property = note_store_get_linked_notebook_sync_state_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS_LINKED_NOTEBOOK,
     g_param_spec_object ("linkedNotebook",
                         NULL,
                         NULL,
                         TYPE_LINKED_NOTEBOOK,
                         G_PARAM_READWRITE));
}

GType
note_store_get_linked_notebook_sync_state_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetLinkedNotebookSyncStateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_linked_notebook_sync_state_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetLinkedNotebookSyncStateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_linked_notebook_sync_state_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetLinkedNotebookSyncStateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetLinkedNotebookSyncStateResultProperties
{
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_0,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_linked_notebook_sync_state_result object */
static gint32
note_store_get_linked_notebook_sync_state_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetLinkedNotebookSyncStateResult * this_object = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_linked_notebook_sync_state_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetLinkedNotebookSyncStateResult * this_object = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetLinkedNotebookSyncStateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_linked_notebook_sync_state_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  NoteStoreGetLinkedNotebookSyncStateResult *self = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_linked_notebook_sync_state_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  NoteStoreGetLinkedNotebookSyncStateResult *self = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_linked_notebook_sync_state_result_instance_init (NoteStoreGetLinkedNotebookSyncStateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SYNC_STATE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_linked_notebook_sync_state_result_finalize (GObject *object)
{
  NoteStoreGetLinkedNotebookSyncStateResult *tobject = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_linked_notebook_sync_state_result_class_init (NoteStoreGetLinkedNotebookSyncStateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_linked_notebook_sync_state_result_read;
  struct_class->write = note_store_get_linked_notebook_sync_state_result_write;

  gobject_class->finalize = note_store_get_linked_notebook_sync_state_result_finalize;
  gobject_class->get_property = note_store_get_linked_notebook_sync_state_result_get_property;
  gobject_class->set_property = note_store_get_linked_notebook_sync_state_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SYNC_STATE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_linked_notebook_sync_state_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetLinkedNotebookSyncStateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_linked_notebook_sync_state_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetLinkedNotebookSyncStateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_linked_notebook_sync_state_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetLinkedNotebookSyncStateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetLinkedNotebookSyncChunkArgsProperties
{
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_0,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_LINKED_NOTEBOOK,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_AFTER_U_S_N,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_MAX_ENTRIES,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_FULL_SYNC_ONLY
};

/* reads a note_store_get_linked_notebook_sync_chunk_args object */
static gint32
note_store_get_linked_notebook_sync_chunk_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetLinkedNotebookSyncChunkArgs * this_object = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->linkedNotebook), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_linkedNotebook = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->afterUSN, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_afterUSN = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxEntries, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxEntries = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->fullSyncOnly, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_fullSyncOnly = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_linked_notebook_sync_chunk_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetLinkedNotebookSyncChunkArgs * this_object = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetLinkedNotebookSyncChunkArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebook", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->linkedNotebook), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "afterUSN", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->afterUSN, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxEntries", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxEntries, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fullSyncOnly", T_BOOL, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->fullSyncOnly, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_linked_notebook_sync_chunk_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  NoteStoreGetLinkedNotebookSyncChunkArgs *self = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_LINKED_NOTEBOOK:
      if (self->linkedNotebook != NULL)
        g_object_unref (self->linkedNotebook);
      self->linkedNotebook = g_value_dup_object (value);
      self->__isset_linkedNotebook = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_AFTER_U_S_N:
      self->afterUSN = g_value_get_int (value);
      self->__isset_afterUSN = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_MAX_ENTRIES:
      self->maxEntries = g_value_get_int (value);
      self->__isset_maxEntries = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_FULL_SYNC_ONLY:
      self->fullSyncOnly = g_value_get_boolean (value);
      self->__isset_fullSyncOnly = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_linked_notebook_sync_chunk_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  NoteStoreGetLinkedNotebookSyncChunkArgs *self = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_LINKED_NOTEBOOK:
      g_value_set_object (value, self->linkedNotebook);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_AFTER_U_S_N:
      g_value_set_int (value, self->afterUSN);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_MAX_ENTRIES:
      g_value_set_int (value, self->maxEntries);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_FULL_SYNC_ONLY:
      g_value_set_boolean (value, self->fullSyncOnly);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_linked_notebook_sync_chunk_args_instance_init (NoteStoreGetLinkedNotebookSyncChunkArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->linkedNotebook = g_object_new (TYPE_LINKED_NOTEBOOK, NULL);
  object->__isset_linkedNotebook = FALSE;
  object->afterUSN = 0;
  object->__isset_afterUSN = FALSE;
  object->maxEntries = 0;
  object->__isset_maxEntries = FALSE;
  object->fullSyncOnly = 0;
  object->__isset_fullSyncOnly = FALSE;
}

static void 
note_store_get_linked_notebook_sync_chunk_args_finalize (GObject *object)
{
  NoteStoreGetLinkedNotebookSyncChunkArgs *tobject = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->linkedNotebook != NULL)
  {
    g_object_unref(tobject->linkedNotebook);
    tobject->linkedNotebook = NULL;
  }
}

static void
note_store_get_linked_notebook_sync_chunk_args_class_init (NoteStoreGetLinkedNotebookSyncChunkArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_linked_notebook_sync_chunk_args_read;
  struct_class->write = note_store_get_linked_notebook_sync_chunk_args_write;

  gobject_class->finalize = note_store_get_linked_notebook_sync_chunk_args_finalize;
  gobject_class->get_property = note_store_get_linked_notebook_sync_chunk_args_get_property;
  gobject_class->set_property = note_store_get_linked_notebook_sync_chunk_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_LINKED_NOTEBOOK,
     g_param_spec_object ("linkedNotebook",
                         NULL,
                         NULL,
                         TYPE_LINKED_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_AFTER_U_S_N,
     g_param_spec_int ("afterUSN",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_MAX_ENTRIES,
     g_param_spec_int ("maxEntries",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS_FULL_SYNC_ONLY,
     g_param_spec_boolean ("fullSyncOnly",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_store_get_linked_notebook_sync_chunk_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetLinkedNotebookSyncChunkArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_linked_notebook_sync_chunk_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetLinkedNotebookSyncChunkArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_linked_notebook_sync_chunk_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetLinkedNotebookSyncChunkArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetLinkedNotebookSyncChunkResultProperties
{
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_0,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_linked_notebook_sync_chunk_result object */
static gint32
note_store_get_linked_notebook_sync_chunk_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetLinkedNotebookSyncChunkResult * this_object = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_linked_notebook_sync_chunk_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetLinkedNotebookSyncChunkResult * this_object = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetLinkedNotebookSyncChunkResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_linked_notebook_sync_chunk_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  NoteStoreGetLinkedNotebookSyncChunkResult *self = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_linked_notebook_sync_chunk_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  NoteStoreGetLinkedNotebookSyncChunkResult *self = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_linked_notebook_sync_chunk_result_instance_init (NoteStoreGetLinkedNotebookSyncChunkResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SYNC_CHUNK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_linked_notebook_sync_chunk_result_finalize (GObject *object)
{
  NoteStoreGetLinkedNotebookSyncChunkResult *tobject = NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_linked_notebook_sync_chunk_result_class_init (NoteStoreGetLinkedNotebookSyncChunkResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_linked_notebook_sync_chunk_result_read;
  struct_class->write = note_store_get_linked_notebook_sync_chunk_result_write;

  gobject_class->finalize = note_store_get_linked_notebook_sync_chunk_result_finalize;
  gobject_class->get_property = note_store_get_linked_notebook_sync_chunk_result_get_property;
  gobject_class->set_property = note_store_get_linked_notebook_sync_chunk_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SYNC_CHUNK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_linked_notebook_sync_chunk_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetLinkedNotebookSyncChunkResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_linked_notebook_sync_chunk_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetLinkedNotebookSyncChunkResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_linked_notebook_sync_chunk_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetLinkedNotebookSyncChunkResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListNotebooksArgsProperties
{
  PROP_NOTE_STORE_LIST_NOTEBOOKS_ARGS_0,
  PROP_NOTE_STORE_LIST_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_list_notebooks_args object */
static gint32
note_store_list_notebooks_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListNotebooksArgs * this_object = NOTE_STORE_LIST_NOTEBOOKS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_notebooks_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListNotebooksArgs * this_object = NOTE_STORE_LIST_NOTEBOOKS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListNotebooksArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_notebooks_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreListNotebooksArgs *self = NOTE_STORE_LIST_NOTEBOOKS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_notebooks_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreListNotebooksArgs *self = NOTE_STORE_LIST_NOTEBOOKS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_notebooks_args_instance_init (NoteStoreListNotebooksArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_list_notebooks_args_finalize (GObject *object)
{
  NoteStoreListNotebooksArgs *tobject = NOTE_STORE_LIST_NOTEBOOKS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_list_notebooks_args_class_init (NoteStoreListNotebooksArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_notebooks_args_read;
  struct_class->write = note_store_list_notebooks_args_write;

  gobject_class->finalize = note_store_list_notebooks_args_finalize;
  gobject_class->get_property = note_store_list_notebooks_args_get_property;
  gobject_class->set_property = note_store_list_notebooks_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_list_notebooks_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListNotebooksArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_notebooks_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListNotebooksArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_notebooks_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListNotebooksArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListNotebooksResultProperties
{
  PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_0,
  PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_SUCCESS,
  PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_list_notebooks_result object */
static gint32
note_store_list_notebooks_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListNotebooksResult * this_object = NOTE_STORE_LIST_NOTEBOOKS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Notebook * _elem104 = NULL;
              if ( _elem104 != NULL)
              {
                g_object_unref (_elem104);
              }
              _elem104 = g_object_new (TYPE_NOTEBOOK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem104), protocol, error)) < 0)
              {
                g_object_unref (_elem104);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem104);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_notebooks_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListNotebooksResult * this_object = NOTE_STORE_LIST_NOTEBOOKS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListNotebooksResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i105;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i105 = 0; i105 < (this_object->success ? this_object->success->len : 0); i105++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i105))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_notebooks_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreListNotebooksResult *self = NOTE_STORE_LIST_NOTEBOOKS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_notebooks_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreListNotebooksResult *self = NOTE_STORE_LIST_NOTEBOOKS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_notebooks_result_instance_init (NoteStoreListNotebooksResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_list_notebooks_result_finalize (GObject *object)
{
  NoteStoreListNotebooksResult *tobject = NOTE_STORE_LIST_NOTEBOOKS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_list_notebooks_result_class_init (NoteStoreListNotebooksResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_notebooks_result_read;
  struct_class->write = note_store_list_notebooks_result_write;

  gobject_class->finalize = note_store_list_notebooks_result_finalize;
  gobject_class->get_property = note_store_list_notebooks_result_get_property;
  gobject_class->set_property = note_store_list_notebooks_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_list_notebooks_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListNotebooksResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_notebooks_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListNotebooksResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_notebooks_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListNotebooksResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListAccessibleBusinessNotebooksArgsProperties
{
  PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS_0,
  PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_list_accessible_business_notebooks_args object */
static gint32
note_store_list_accessible_business_notebooks_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListAccessibleBusinessNotebooksArgs * this_object = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_accessible_business_notebooks_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListAccessibleBusinessNotebooksArgs * this_object = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListAccessibleBusinessNotebooksArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_accessible_business_notebooks_args_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  NoteStoreListAccessibleBusinessNotebooksArgs *self = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_accessible_business_notebooks_args_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  NoteStoreListAccessibleBusinessNotebooksArgs *self = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_accessible_business_notebooks_args_instance_init (NoteStoreListAccessibleBusinessNotebooksArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_list_accessible_business_notebooks_args_finalize (GObject *object)
{
  NoteStoreListAccessibleBusinessNotebooksArgs *tobject = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_list_accessible_business_notebooks_args_class_init (NoteStoreListAccessibleBusinessNotebooksArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_accessible_business_notebooks_args_read;
  struct_class->write = note_store_list_accessible_business_notebooks_args_write;

  gobject_class->finalize = note_store_list_accessible_business_notebooks_args_finalize;
  gobject_class->get_property = note_store_list_accessible_business_notebooks_args_get_property;
  gobject_class->set_property = note_store_list_accessible_business_notebooks_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_list_accessible_business_notebooks_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListAccessibleBusinessNotebooksArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_accessible_business_notebooks_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListAccessibleBusinessNotebooksArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_accessible_business_notebooks_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListAccessibleBusinessNotebooksArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListAccessibleBusinessNotebooksResultProperties
{
  PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_0,
  PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_SUCCESS,
  PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_list_accessible_business_notebooks_result object */
static gint32
note_store_list_accessible_business_notebooks_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListAccessibleBusinessNotebooksResult * this_object = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Notebook * _elem106 = NULL;
              if ( _elem106 != NULL)
              {
                g_object_unref (_elem106);
              }
              _elem106 = g_object_new (TYPE_NOTEBOOK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem106), protocol, error)) < 0)
              {
                g_object_unref (_elem106);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem106);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_accessible_business_notebooks_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListAccessibleBusinessNotebooksResult * this_object = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListAccessibleBusinessNotebooksResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i107;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i107 = 0; i107 < (this_object->success ? this_object->success->len : 0); i107++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i107))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_accessible_business_notebooks_result_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  NoteStoreListAccessibleBusinessNotebooksResult *self = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_accessible_business_notebooks_result_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  NoteStoreListAccessibleBusinessNotebooksResult *self = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_accessible_business_notebooks_result_instance_init (NoteStoreListAccessibleBusinessNotebooksResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_list_accessible_business_notebooks_result_finalize (GObject *object)
{
  NoteStoreListAccessibleBusinessNotebooksResult *tobject = NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_list_accessible_business_notebooks_result_class_init (NoteStoreListAccessibleBusinessNotebooksResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_accessible_business_notebooks_result_read;
  struct_class->write = note_store_list_accessible_business_notebooks_result_write;

  gobject_class->finalize = note_store_list_accessible_business_notebooks_result_finalize;
  gobject_class->get_property = note_store_list_accessible_business_notebooks_result_get_property;
  gobject_class->set_property = note_store_list_accessible_business_notebooks_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_list_accessible_business_notebooks_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListAccessibleBusinessNotebooksResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_accessible_business_notebooks_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListAccessibleBusinessNotebooksResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_accessible_business_notebooks_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListAccessibleBusinessNotebooksResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNotebookArgsProperties
{
  PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_GUID
};

/* reads a note_store_get_notebook_args object */
static gint32
note_store_get_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNotebookArgs * this_object = NOTE_STORE_GET_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNotebookArgs * this_object = NOTE_STORE_GET_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_notebook_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreGetNotebookArgs *self = NOTE_STORE_GET_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_notebook_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreGetNotebookArgs *self = NOTE_STORE_GET_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_notebook_args_instance_init (NoteStoreGetNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_notebook_args_finalize (GObject *object)
{
  NoteStoreGetNotebookArgs *tobject = NOTE_STORE_GET_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_notebook_args_class_init (NoteStoreGetNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_notebook_args_read;
  struct_class->write = note_store_get_notebook_args_write;

  gobject_class->finalize = note_store_get_notebook_args_finalize;
  gobject_class->get_property = note_store_get_notebook_args_get_property;
  gobject_class->set_property = note_store_get_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNotebookResultProperties
{
  PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_notebook_result object */
static gint32
note_store_get_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNotebookResult * this_object = NOTE_STORE_GET_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNotebookResult * this_object = NOTE_STORE_GET_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_notebook_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreGetNotebookResult *self = NOTE_STORE_GET_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_notebook_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreGetNotebookResult *self = NOTE_STORE_GET_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_notebook_result_instance_init (NoteStoreGetNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTEBOOK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_notebook_result_finalize (GObject *object)
{
  NoteStoreGetNotebookResult *tobject = NOTE_STORE_GET_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_notebook_result_class_init (NoteStoreGetNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_notebook_result_read;
  struct_class->write = note_store_get_notebook_result_write;

  gobject_class->finalize = note_store_get_notebook_result_finalize;
  gobject_class->get_property = note_store_get_notebook_result_get_property;
  gobject_class->set_property = note_store_get_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetDefaultNotebookArgsProperties
{
  PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_get_default_notebook_args object */
static gint32
note_store_get_default_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetDefaultNotebookArgs * this_object = NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_default_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetDefaultNotebookArgs * this_object = NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetDefaultNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_default_notebook_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreGetDefaultNotebookArgs *self = NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_default_notebook_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreGetDefaultNotebookArgs *self = NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_default_notebook_args_instance_init (NoteStoreGetDefaultNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_get_default_notebook_args_finalize (GObject *object)
{
  NoteStoreGetDefaultNotebookArgs *tobject = NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_get_default_notebook_args_class_init (NoteStoreGetDefaultNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_default_notebook_args_read;
  struct_class->write = note_store_get_default_notebook_args_write;

  gobject_class->finalize = note_store_get_default_notebook_args_finalize;
  gobject_class->get_property = note_store_get_default_notebook_args_get_property;
  gobject_class->set_property = note_store_get_default_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_default_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetDefaultNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_default_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetDefaultNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_default_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetDefaultNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetDefaultNotebookResultProperties
{
  PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_get_default_notebook_result object */
static gint32
note_store_get_default_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetDefaultNotebookResult * this_object = NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_default_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetDefaultNotebookResult * this_object = NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetDefaultNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_default_notebook_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreGetDefaultNotebookResult *self = NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_default_notebook_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreGetDefaultNotebookResult *self = NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_default_notebook_result_instance_init (NoteStoreGetDefaultNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTEBOOK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_get_default_notebook_result_finalize (GObject *object)
{
  NoteStoreGetDefaultNotebookResult *tobject = NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_get_default_notebook_result_class_init (NoteStoreGetDefaultNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_default_notebook_result_read;
  struct_class->write = note_store_get_default_notebook_result_write;

  gobject_class->finalize = note_store_get_default_notebook_result_finalize;
  gobject_class->get_property = note_store_get_default_notebook_result_get_property;
  gobject_class->set_property = note_store_get_default_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_default_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetDefaultNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_default_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetDefaultNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_default_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetDefaultNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateNotebookArgsProperties
{
  PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_NOTEBOOK
};

/* reads a note_store_create_notebook_args object */
static gint32
note_store_create_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateNotebookArgs * this_object = NOTE_STORE_CREATE_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notebook), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_notebook = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateNotebookArgs * this_object = NOTE_STORE_CREATE_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "notebook", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notebook), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_notebook_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreCreateNotebookArgs *self = NOTE_STORE_CREATE_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_NOTEBOOK:
      if (self->notebook != NULL)
        g_object_unref (self->notebook);
      self->notebook = g_value_dup_object (value);
      self->__isset_notebook = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_notebook_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreCreateNotebookArgs *self = NOTE_STORE_CREATE_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_NOTEBOOK:
      g_value_set_object (value, self->notebook);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_notebook_args_instance_init (NoteStoreCreateNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->notebook = g_object_new (TYPE_NOTEBOOK, NULL);
  object->__isset_notebook = FALSE;
}

static void 
note_store_create_notebook_args_finalize (GObject *object)
{
  NoteStoreCreateNotebookArgs *tobject = NOTE_STORE_CREATE_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->notebook != NULL)
  {
    g_object_unref(tobject->notebook);
    tobject->notebook = NULL;
  }
}

static void
note_store_create_notebook_args_class_init (NoteStoreCreateNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_notebook_args_read;
  struct_class->write = note_store_create_notebook_args_write;

  gobject_class->finalize = note_store_create_notebook_args_finalize;
  gobject_class->get_property = note_store_create_notebook_args_get_property;
  gobject_class->set_property = note_store_create_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTEBOOK_ARGS_NOTEBOOK,
     g_param_spec_object ("notebook",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK,
                         G_PARAM_READWRITE));
}

GType
note_store_create_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateNotebookResultProperties
{
  PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_create_notebook_result object */
static gint32
note_store_create_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateNotebookResult * this_object = NOTE_STORE_CREATE_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateNotebookResult * this_object = NOTE_STORE_CREATE_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_notebook_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreCreateNotebookResult *self = NOTE_STORE_CREATE_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_notebook_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreCreateNotebookResult *self = NOTE_STORE_CREATE_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_notebook_result_instance_init (NoteStoreCreateNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTEBOOK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_create_notebook_result_finalize (GObject *object)
{
  NoteStoreCreateNotebookResult *tobject = NOTE_STORE_CREATE_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_create_notebook_result_class_init (NoteStoreCreateNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_notebook_result_read;
  struct_class->write = note_store_create_notebook_result_write;

  gobject_class->finalize = note_store_create_notebook_result_finalize;
  gobject_class->get_property = note_store_create_notebook_result_get_property;
  gobject_class->set_property = note_store_create_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_create_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateNotebookArgsProperties
{
  PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_NOTEBOOK
};

/* reads a note_store_update_notebook_args object */
static gint32
note_store_update_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateNotebookArgs * this_object = NOTE_STORE_UPDATE_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notebook), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_notebook = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateNotebookArgs * this_object = NOTE_STORE_UPDATE_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "notebook", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notebook), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_notebook_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreUpdateNotebookArgs *self = NOTE_STORE_UPDATE_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_NOTEBOOK:
      if (self->notebook != NULL)
        g_object_unref (self->notebook);
      self->notebook = g_value_dup_object (value);
      self->__isset_notebook = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_notebook_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreUpdateNotebookArgs *self = NOTE_STORE_UPDATE_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_NOTEBOOK:
      g_value_set_object (value, self->notebook);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_notebook_args_instance_init (NoteStoreUpdateNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->notebook = g_object_new (TYPE_NOTEBOOK, NULL);
  object->__isset_notebook = FALSE;
}

static void 
note_store_update_notebook_args_finalize (GObject *object)
{
  NoteStoreUpdateNotebookArgs *tobject = NOTE_STORE_UPDATE_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->notebook != NULL)
  {
    g_object_unref(tobject->notebook);
    tobject->notebook = NULL;
  }
}

static void
note_store_update_notebook_args_class_init (NoteStoreUpdateNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_notebook_args_read;
  struct_class->write = note_store_update_notebook_args_write;

  gobject_class->finalize = note_store_update_notebook_args_finalize;
  gobject_class->get_property = note_store_update_notebook_args_get_property;
  gobject_class->set_property = note_store_update_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTEBOOK_ARGS_NOTEBOOK,
     g_param_spec_object ("notebook",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK,
                         G_PARAM_READWRITE));
}

GType
note_store_update_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateNotebookResultProperties
{
  PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_update_notebook_result object */
static gint32
note_store_update_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateNotebookResult * this_object = NOTE_STORE_UPDATE_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateNotebookResult * this_object = NOTE_STORE_UPDATE_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_notebook_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreUpdateNotebookResult *self = NOTE_STORE_UPDATE_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_notebook_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreUpdateNotebookResult *self = NOTE_STORE_UPDATE_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_notebook_result_instance_init (NoteStoreUpdateNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_update_notebook_result_finalize (GObject *object)
{
  NoteStoreUpdateNotebookResult *tobject = NOTE_STORE_UPDATE_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_update_notebook_result_class_init (NoteStoreUpdateNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_notebook_result_read;
  struct_class->write = note_store_update_notebook_result_write;

  gobject_class->finalize = note_store_update_notebook_result_finalize;
  gobject_class->get_property = note_store_update_notebook_result_get_property;
  gobject_class->set_property = note_store_update_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_update_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeNotebookArgsProperties
{
  PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_GUID
};

/* reads a note_store_expunge_notebook_args object */
static gint32
note_store_expunge_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeNotebookArgs * this_object = NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeNotebookArgs * this_object = NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_notebook_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreExpungeNotebookArgs *self = NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_notebook_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreExpungeNotebookArgs *self = NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_notebook_args_instance_init (NoteStoreExpungeNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_expunge_notebook_args_finalize (GObject *object)
{
  NoteStoreExpungeNotebookArgs *tobject = NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_expunge_notebook_args_class_init (NoteStoreExpungeNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_notebook_args_read;
  struct_class->write = note_store_expunge_notebook_args_write;

  gobject_class->finalize = note_store_expunge_notebook_args_finalize;
  gobject_class->get_property = note_store_expunge_notebook_args_get_property;
  gobject_class->set_property = note_store_expunge_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_expunge_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeNotebookResultProperties
{
  PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_expunge_notebook_result object */
static gint32
note_store_expunge_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeNotebookResult * this_object = NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeNotebookResult * this_object = NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_notebook_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreExpungeNotebookResult *self = NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_notebook_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreExpungeNotebookResult *self = NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_notebook_result_instance_init (NoteStoreExpungeNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_expunge_notebook_result_finalize (GObject *object)
{
  NoteStoreExpungeNotebookResult *tobject = NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_expunge_notebook_result_class_init (NoteStoreExpungeNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_notebook_result_read;
  struct_class->write = note_store_expunge_notebook_result_write;

  gobject_class->finalize = note_store_expunge_notebook_result_finalize;
  gobject_class->get_property = note_store_expunge_notebook_result_get_property;
  gobject_class->set_property = note_store_expunge_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_expunge_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListTagsArgsProperties
{
  PROP_NOTE_STORE_LIST_TAGS_ARGS_0,
  PROP_NOTE_STORE_LIST_TAGS_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_list_tags_args object */
static gint32
note_store_list_tags_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListTagsArgs * this_object = NOTE_STORE_LIST_TAGS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_tags_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListTagsArgs * this_object = NOTE_STORE_LIST_TAGS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListTagsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_tags_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  NoteStoreListTagsArgs *self = NOTE_STORE_LIST_TAGS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_TAGS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_tags_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  NoteStoreListTagsArgs *self = NOTE_STORE_LIST_TAGS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_TAGS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_tags_args_instance_init (NoteStoreListTagsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_list_tags_args_finalize (GObject *object)
{
  NoteStoreListTagsArgs *tobject = NOTE_STORE_LIST_TAGS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_list_tags_args_class_init (NoteStoreListTagsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_tags_args_read;
  struct_class->write = note_store_list_tags_args_write;

  gobject_class->finalize = note_store_list_tags_args_finalize;
  gobject_class->get_property = note_store_list_tags_args_get_property;
  gobject_class->set_property = note_store_list_tags_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_list_tags_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListTagsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_tags_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListTagsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_tags_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListTagsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListTagsResultProperties
{
  PROP_NOTE_STORE_LIST_TAGS_RESULT_0,
  PROP_NOTE_STORE_LIST_TAGS_RESULT_SUCCESS,
  PROP_NOTE_STORE_LIST_TAGS_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_LIST_TAGS_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_list_tags_result object */
static gint32
note_store_list_tags_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListTagsResult * this_object = NOTE_STORE_LIST_TAGS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Tag * _elem108 = NULL;
              if ( _elem108 != NULL)
              {
                g_object_unref (_elem108);
              }
              _elem108 = g_object_new (TYPE_TAG, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem108), protocol, error)) < 0)
              {
                g_object_unref (_elem108);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem108);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_tags_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListTagsResult * this_object = NOTE_STORE_LIST_TAGS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListTagsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i109;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i109 = 0; i109 < (this_object->success ? this_object->success->len : 0); i109++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i109))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_tags_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreListTagsResult *self = NOTE_STORE_LIST_TAGS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_TAGS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_TAGS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_TAGS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_tags_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreListTagsResult *self = NOTE_STORE_LIST_TAGS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_TAGS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_LIST_TAGS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_LIST_TAGS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_tags_result_instance_init (NoteStoreListTagsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_list_tags_result_finalize (GObject *object)
{
  NoteStoreListTagsResult *tobject = NOTE_STORE_LIST_TAGS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_list_tags_result_class_init (NoteStoreListTagsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_tags_result_read;
  struct_class->write = note_store_list_tags_result_write;

  gobject_class->finalize = note_store_list_tags_result_finalize;
  gobject_class->get_property = note_store_list_tags_result_get_property;
  gobject_class->set_property = note_store_list_tags_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_list_tags_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListTagsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_tags_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListTagsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_tags_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListTagsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListTagsByNotebookArgsProperties
{
  PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_NOTEBOOK_GUID
};

/* reads a note_store_list_tags_by_notebook_args object */
static gint32
note_store_list_tags_by_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListTagsByNotebookArgs * this_object = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->notebookGuid != NULL)
          {
            g_free(this_object->notebookGuid);
            this_object->notebookGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->notebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_notebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_tags_by_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListTagsByNotebookArgs * this_object = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListTagsByNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->notebookGuid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_tags_by_notebook_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreListTagsByNotebookArgs *self = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_NOTEBOOK_GUID:
      if (self->notebookGuid != NULL)
        g_free (self->notebookGuid);
      self->notebookGuid = g_value_dup_string (value);
      self->__isset_notebookGuid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_tags_by_notebook_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreListTagsByNotebookArgs *self = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_NOTEBOOK_GUID:
      g_value_set_string (value, self->notebookGuid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_tags_by_notebook_args_instance_init (NoteStoreListTagsByNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->notebookGuid = NULL;
  object->__isset_notebookGuid = FALSE;
}

static void 
note_store_list_tags_by_notebook_args_finalize (GObject *object)
{
  NoteStoreListTagsByNotebookArgs *tobject = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->notebookGuid != NULL)
  {
    g_free(tobject->notebookGuid);
    tobject->notebookGuid = NULL;
  }
}

static void
note_store_list_tags_by_notebook_args_class_init (NoteStoreListTagsByNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_tags_by_notebook_args_read;
  struct_class->write = note_store_list_tags_by_notebook_args_write;

  gobject_class->finalize = note_store_list_tags_by_notebook_args_finalize;
  gobject_class->get_property = note_store_list_tags_by_notebook_args_get_property;
  gobject_class->set_property = note_store_list_tags_by_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS_NOTEBOOK_GUID,
     g_param_spec_string ("notebookGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_list_tags_by_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListTagsByNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_tags_by_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListTagsByNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_tags_by_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListTagsByNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListTagsByNotebookResultProperties
{
  PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_list_tags_by_notebook_result object */
static gint32
note_store_list_tags_by_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListTagsByNotebookResult * this_object = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Tag * _elem110 = NULL;
              if ( _elem110 != NULL)
              {
                g_object_unref (_elem110);
              }
              _elem110 = g_object_new (TYPE_TAG, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem110), protocol, error)) < 0)
              {
                g_object_unref (_elem110);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem110);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_tags_by_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListTagsByNotebookResult * this_object = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListTagsByNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i111;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i111 = 0; i111 < (this_object->success ? this_object->success->len : 0); i111++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i111))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_tags_by_notebook_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreListTagsByNotebookResult *self = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_tags_by_notebook_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreListTagsByNotebookResult *self = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_tags_by_notebook_result_instance_init (NoteStoreListTagsByNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_list_tags_by_notebook_result_finalize (GObject *object)
{
  NoteStoreListTagsByNotebookResult *tobject = NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_list_tags_by_notebook_result_class_init (NoteStoreListTagsByNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_tags_by_notebook_result_read;
  struct_class->write = note_store_list_tags_by_notebook_result_write;

  gobject_class->finalize = note_store_list_tags_by_notebook_result_finalize;
  gobject_class->get_property = note_store_list_tags_by_notebook_result_get_property;
  gobject_class->set_property = note_store_list_tags_by_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_list_tags_by_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListTagsByNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_tags_by_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListTagsByNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_tags_by_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListTagsByNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetTagArgsProperties
{
  PROP_NOTE_STORE_GET_TAG_ARGS_0,
  PROP_NOTE_STORE_GET_TAG_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_TAG_ARGS_GUID
};

/* reads a note_store_get_tag_args object */
static gint32
note_store_get_tag_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetTagArgs * this_object = NOTE_STORE_GET_TAG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_tag_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetTagArgs * this_object = NOTE_STORE_GET_TAG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetTagArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_tag_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  NoteStoreGetTagArgs *self = NOTE_STORE_GET_TAG_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_TAG_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_TAG_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_tag_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  NoteStoreGetTagArgs *self = NOTE_STORE_GET_TAG_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_TAG_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_TAG_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_tag_args_instance_init (NoteStoreGetTagArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_tag_args_finalize (GObject *object)
{
  NoteStoreGetTagArgs *tobject = NOTE_STORE_GET_TAG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_tag_args_class_init (NoteStoreGetTagArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_tag_args_read;
  struct_class->write = note_store_get_tag_args_write;

  gobject_class->finalize = note_store_get_tag_args_finalize;
  gobject_class->get_property = note_store_get_tag_args_get_property;
  gobject_class->set_property = note_store_get_tag_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_TAG_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_TAG_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_tag_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetTagArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_tag_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetTagArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_tag_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetTagArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetTagResultProperties
{
  PROP_NOTE_STORE_GET_TAG_RESULT_0,
  PROP_NOTE_STORE_GET_TAG_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_TAG_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_TAG_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_TAG_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_tag_result object */
static gint32
note_store_get_tag_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetTagResult * this_object = NOTE_STORE_GET_TAG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_tag_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetTagResult * this_object = NOTE_STORE_GET_TAG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetTagResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_tag_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  NoteStoreGetTagResult *self = NOTE_STORE_GET_TAG_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_TAG_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_TAG_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_TAG_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_TAG_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_tag_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  NoteStoreGetTagResult *self = NOTE_STORE_GET_TAG_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_TAG_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_TAG_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_TAG_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_TAG_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_tag_result_instance_init (NoteStoreGetTagResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TAG, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_tag_result_finalize (GObject *object)
{
  NoteStoreGetTagResult *tobject = NOTE_STORE_GET_TAG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_tag_result_class_init (NoteStoreGetTagResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_tag_result_read;
  struct_class->write = note_store_get_tag_result_write;

  gobject_class->finalize = note_store_get_tag_result_finalize;
  gobject_class->get_property = note_store_get_tag_result_get_property;
  gobject_class->set_property = note_store_get_tag_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_TAG_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TAG,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_TAG_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_TAG_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_TAG_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_tag_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetTagResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_tag_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetTagResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_tag_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetTagResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateTagArgsProperties
{
  PROP_NOTE_STORE_CREATE_TAG_ARGS_0,
  PROP_NOTE_STORE_CREATE_TAG_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_CREATE_TAG_ARGS_TAG
};

/* reads a note_store_create_tag_args object */
static gint32
note_store_create_tag_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateTagArgs * this_object = NOTE_STORE_CREATE_TAG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tag), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_tag_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateTagArgs * this_object = NOTE_STORE_CREATE_TAG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateTagArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tag", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tag), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_tag_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreCreateTagArgs *self = NOTE_STORE_CREATE_TAG_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_TAG_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_TAG_ARGS_TAG:
      if (self->tag != NULL)
        g_object_unref (self->tag);
      self->tag = g_value_dup_object (value);
      self->__isset_tag = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_tag_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreCreateTagArgs *self = NOTE_STORE_CREATE_TAG_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_TAG_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_CREATE_TAG_ARGS_TAG:
      g_value_set_object (value, self->tag);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_tag_args_instance_init (NoteStoreCreateTagArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->tag = g_object_new (TYPE_TAG, NULL);
  object->__isset_tag = FALSE;
}

static void 
note_store_create_tag_args_finalize (GObject *object)
{
  NoteStoreCreateTagArgs *tobject = NOTE_STORE_CREATE_TAG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->tag != NULL)
  {
    g_object_unref(tobject->tag);
    tobject->tag = NULL;
  }
}

static void
note_store_create_tag_args_class_init (NoteStoreCreateTagArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_tag_args_read;
  struct_class->write = note_store_create_tag_args_write;

  gobject_class->finalize = note_store_create_tag_args_finalize;
  gobject_class->get_property = note_store_create_tag_args_get_property;
  gobject_class->set_property = note_store_create_tag_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_TAG_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_TAG_ARGS_TAG,
     g_param_spec_object ("tag",
                         NULL,
                         NULL,
                         TYPE_TAG,
                         G_PARAM_READWRITE));
}

GType
note_store_create_tag_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateTagArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_tag_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateTagArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_tag_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateTagArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateTagResultProperties
{
  PROP_NOTE_STORE_CREATE_TAG_RESULT_0,
  PROP_NOTE_STORE_CREATE_TAG_RESULT_SUCCESS,
  PROP_NOTE_STORE_CREATE_TAG_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_CREATE_TAG_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_CREATE_TAG_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_create_tag_result object */
static gint32
note_store_create_tag_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateTagResult * this_object = NOTE_STORE_CREATE_TAG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_tag_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateTagResult * this_object = NOTE_STORE_CREATE_TAG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateTagResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_tag_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreCreateTagResult *self = NOTE_STORE_CREATE_TAG_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_TAG_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_TAG_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_TAG_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_TAG_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_tag_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreCreateTagResult *self = NOTE_STORE_CREATE_TAG_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_TAG_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_CREATE_TAG_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_CREATE_TAG_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_CREATE_TAG_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_tag_result_instance_init (NoteStoreCreateTagResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TAG, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_create_tag_result_finalize (GObject *object)
{
  NoteStoreCreateTagResult *tobject = NOTE_STORE_CREATE_TAG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_create_tag_result_class_init (NoteStoreCreateTagResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_tag_result_read;
  struct_class->write = note_store_create_tag_result_write;

  gobject_class->finalize = note_store_create_tag_result_finalize;
  gobject_class->get_property = note_store_create_tag_result_get_property;
  gobject_class->set_property = note_store_create_tag_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_TAG_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TAG,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_TAG_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_TAG_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_TAG_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_create_tag_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateTagResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_tag_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateTagResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_tag_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateTagResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateTagArgsProperties
{
  PROP_NOTE_STORE_UPDATE_TAG_ARGS_0,
  PROP_NOTE_STORE_UPDATE_TAG_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UPDATE_TAG_ARGS_TAG
};

/* reads a note_store_update_tag_args object */
static gint32
note_store_update_tag_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateTagArgs * this_object = NOTE_STORE_UPDATE_TAG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tag), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_tag_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateTagArgs * this_object = NOTE_STORE_UPDATE_TAG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateTagArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tag", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tag), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_tag_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreUpdateTagArgs *self = NOTE_STORE_UPDATE_TAG_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_TAG_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_TAG_ARGS_TAG:
      if (self->tag != NULL)
        g_object_unref (self->tag);
      self->tag = g_value_dup_object (value);
      self->__isset_tag = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_tag_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreUpdateTagArgs *self = NOTE_STORE_UPDATE_TAG_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_TAG_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UPDATE_TAG_ARGS_TAG:
      g_value_set_object (value, self->tag);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_tag_args_instance_init (NoteStoreUpdateTagArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->tag = g_object_new (TYPE_TAG, NULL);
  object->__isset_tag = FALSE;
}

static void 
note_store_update_tag_args_finalize (GObject *object)
{
  NoteStoreUpdateTagArgs *tobject = NOTE_STORE_UPDATE_TAG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->tag != NULL)
  {
    g_object_unref(tobject->tag);
    tobject->tag = NULL;
  }
}

static void
note_store_update_tag_args_class_init (NoteStoreUpdateTagArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_tag_args_read;
  struct_class->write = note_store_update_tag_args_write;

  gobject_class->finalize = note_store_update_tag_args_finalize;
  gobject_class->get_property = note_store_update_tag_args_get_property;
  gobject_class->set_property = note_store_update_tag_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_TAG_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_TAG_ARGS_TAG,
     g_param_spec_object ("tag",
                         NULL,
                         NULL,
                         TYPE_TAG,
                         G_PARAM_READWRITE));
}

GType
note_store_update_tag_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateTagArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_tag_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateTagArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_tag_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateTagArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateTagResultProperties
{
  PROP_NOTE_STORE_UPDATE_TAG_RESULT_0,
  PROP_NOTE_STORE_UPDATE_TAG_RESULT_SUCCESS,
  PROP_NOTE_STORE_UPDATE_TAG_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_TAG_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_TAG_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_update_tag_result object */
static gint32
note_store_update_tag_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateTagResult * this_object = NOTE_STORE_UPDATE_TAG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_tag_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateTagResult * this_object = NOTE_STORE_UPDATE_TAG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateTagResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_tag_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreUpdateTagResult *self = NOTE_STORE_UPDATE_TAG_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_TAG_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_TAG_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_TAG_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_TAG_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_tag_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreUpdateTagResult *self = NOTE_STORE_UPDATE_TAG_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_TAG_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_UPDATE_TAG_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UPDATE_TAG_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_UPDATE_TAG_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_tag_result_instance_init (NoteStoreUpdateTagResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_update_tag_result_finalize (GObject *object)
{
  NoteStoreUpdateTagResult *tobject = NOTE_STORE_UPDATE_TAG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_update_tag_result_class_init (NoteStoreUpdateTagResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_tag_result_read;
  struct_class->write = note_store_update_tag_result_write;

  gobject_class->finalize = note_store_update_tag_result_finalize;
  gobject_class->get_property = note_store_update_tag_result_get_property;
  gobject_class->set_property = note_store_update_tag_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_TAG_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_TAG_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_TAG_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_TAG_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_update_tag_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateTagResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_tag_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateTagResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_tag_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateTagResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUntagAllArgsProperties
{
  PROP_NOTE_STORE_UNTAG_ALL_ARGS_0,
  PROP_NOTE_STORE_UNTAG_ALL_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UNTAG_ALL_ARGS_GUID
};

/* reads a note_store_untag_all_args object */
static gint32
note_store_untag_all_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUntagAllArgs * this_object = NOTE_STORE_UNTAG_ALL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_untag_all_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUntagAllArgs * this_object = NOTE_STORE_UNTAG_ALL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUntagAllArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_untag_all_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  NoteStoreUntagAllArgs *self = NOTE_STORE_UNTAG_ALL_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNTAG_ALL_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UNTAG_ALL_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_untag_all_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  NoteStoreUntagAllArgs *self = NOTE_STORE_UNTAG_ALL_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNTAG_ALL_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UNTAG_ALL_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_untag_all_args_instance_init (NoteStoreUntagAllArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_untag_all_args_finalize (GObject *object)
{
  NoteStoreUntagAllArgs *tobject = NOTE_STORE_UNTAG_ALL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_untag_all_args_class_init (NoteStoreUntagAllArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_untag_all_args_read;
  struct_class->write = note_store_untag_all_args_write;

  gobject_class->finalize = note_store_untag_all_args_finalize;
  gobject_class->get_property = note_store_untag_all_args_get_property;
  gobject_class->set_property = note_store_untag_all_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNTAG_ALL_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNTAG_ALL_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_untag_all_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUntagAllArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_untag_all_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUntagAllArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_untag_all_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUntagAllArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUntagAllResultProperties
{
  PROP_NOTE_STORE_UNTAG_ALL_RESULT_0,
  PROP_NOTE_STORE_UNTAG_ALL_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UNTAG_ALL_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_UNTAG_ALL_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_untag_all_result object */
static gint32
note_store_untag_all_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUntagAllResult * this_object = NOTE_STORE_UNTAG_ALL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_untag_all_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUntagAllResult * this_object = NOTE_STORE_UNTAG_ALL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUntagAllResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_untag_all_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreUntagAllResult *self = NOTE_STORE_UNTAG_ALL_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNTAG_ALL_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UNTAG_ALL_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_UNTAG_ALL_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_untag_all_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreUntagAllResult *self = NOTE_STORE_UNTAG_ALL_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNTAG_ALL_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UNTAG_ALL_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_UNTAG_ALL_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_untag_all_result_instance_init (NoteStoreUntagAllResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_untag_all_result_finalize (GObject *object)
{
  NoteStoreUntagAllResult *tobject = NOTE_STORE_UNTAG_ALL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_untag_all_result_class_init (NoteStoreUntagAllResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_untag_all_result_read;
  struct_class->write = note_store_untag_all_result_write;

  gobject_class->finalize = note_store_untag_all_result_finalize;
  gobject_class->get_property = note_store_untag_all_result_get_property;
  gobject_class->set_property = note_store_untag_all_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNTAG_ALL_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNTAG_ALL_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNTAG_ALL_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_untag_all_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUntagAllResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_untag_all_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUntagAllResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_untag_all_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUntagAllResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeTagArgsProperties
{
  PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_0,
  PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_GUID
};

/* reads a note_store_expunge_tag_args object */
static gint32
note_store_expunge_tag_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeTagArgs * this_object = NOTE_STORE_EXPUNGE_TAG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_tag_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeTagArgs * this_object = NOTE_STORE_EXPUNGE_TAG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeTagArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_tag_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreExpungeTagArgs *self = NOTE_STORE_EXPUNGE_TAG_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_tag_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreExpungeTagArgs *self = NOTE_STORE_EXPUNGE_TAG_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_tag_args_instance_init (NoteStoreExpungeTagArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_expunge_tag_args_finalize (GObject *object)
{
  NoteStoreExpungeTagArgs *tobject = NOTE_STORE_EXPUNGE_TAG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_expunge_tag_args_class_init (NoteStoreExpungeTagArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_tag_args_read;
  struct_class->write = note_store_expunge_tag_args_write;

  gobject_class->finalize = note_store_expunge_tag_args_finalize;
  gobject_class->get_property = note_store_expunge_tag_args_get_property;
  gobject_class->set_property = note_store_expunge_tag_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_TAG_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_expunge_tag_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeTagArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_tag_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeTagArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_tag_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeTagArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeTagResultProperties
{
  PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_0,
  PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_SUCCESS,
  PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_expunge_tag_result object */
static gint32
note_store_expunge_tag_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeTagResult * this_object = NOTE_STORE_EXPUNGE_TAG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_tag_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeTagResult * this_object = NOTE_STORE_EXPUNGE_TAG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeTagResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_tag_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreExpungeTagResult *self = NOTE_STORE_EXPUNGE_TAG_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_tag_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreExpungeTagResult *self = NOTE_STORE_EXPUNGE_TAG_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_tag_result_instance_init (NoteStoreExpungeTagResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_expunge_tag_result_finalize (GObject *object)
{
  NoteStoreExpungeTagResult *tobject = NOTE_STORE_EXPUNGE_TAG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_expunge_tag_result_class_init (NoteStoreExpungeTagResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_tag_result_read;
  struct_class->write = note_store_expunge_tag_result_write;

  gobject_class->finalize = note_store_expunge_tag_result_finalize;
  gobject_class->get_property = note_store_expunge_tag_result_get_property;
  gobject_class->set_property = note_store_expunge_tag_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_TAG_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_expunge_tag_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeTagResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_tag_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeTagResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_tag_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeTagResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListSearchesArgsProperties
{
  PROP_NOTE_STORE_LIST_SEARCHES_ARGS_0,
  PROP_NOTE_STORE_LIST_SEARCHES_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_list_searches_args object */
static gint32
note_store_list_searches_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListSearchesArgs * this_object = NOTE_STORE_LIST_SEARCHES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_searches_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListSearchesArgs * this_object = NOTE_STORE_LIST_SEARCHES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListSearchesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_searches_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreListSearchesArgs *self = NOTE_STORE_LIST_SEARCHES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_SEARCHES_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_searches_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreListSearchesArgs *self = NOTE_STORE_LIST_SEARCHES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_SEARCHES_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_searches_args_instance_init (NoteStoreListSearchesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_list_searches_args_finalize (GObject *object)
{
  NoteStoreListSearchesArgs *tobject = NOTE_STORE_LIST_SEARCHES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_list_searches_args_class_init (NoteStoreListSearchesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_searches_args_read;
  struct_class->write = note_store_list_searches_args_write;

  gobject_class->finalize = note_store_list_searches_args_finalize;
  gobject_class->get_property = note_store_list_searches_args_get_property;
  gobject_class->set_property = note_store_list_searches_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SEARCHES_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_list_searches_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListSearchesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_searches_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListSearchesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_searches_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListSearchesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListSearchesResultProperties
{
  PROP_NOTE_STORE_LIST_SEARCHES_RESULT_0,
  PROP_NOTE_STORE_LIST_SEARCHES_RESULT_SUCCESS,
  PROP_NOTE_STORE_LIST_SEARCHES_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_LIST_SEARCHES_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_list_searches_result object */
static gint32
note_store_list_searches_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListSearchesResult * this_object = NOTE_STORE_LIST_SEARCHES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              SavedSearch * _elem112 = NULL;
              if ( _elem112 != NULL)
              {
                g_object_unref (_elem112);
              }
              _elem112 = g_object_new (TYPE_SAVED_SEARCH, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem112), protocol, error)) < 0)
              {
                g_object_unref (_elem112);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem112);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_searches_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListSearchesResult * this_object = NOTE_STORE_LIST_SEARCHES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListSearchesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i113;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i113 = 0; i113 < (this_object->success ? this_object->success->len : 0); i113++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i113))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_searches_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreListSearchesResult *self = NOTE_STORE_LIST_SEARCHES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_SEARCHES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_SEARCHES_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_SEARCHES_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_searches_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreListSearchesResult *self = NOTE_STORE_LIST_SEARCHES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_SEARCHES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_LIST_SEARCHES_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_LIST_SEARCHES_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_searches_result_instance_init (NoteStoreListSearchesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_list_searches_result_finalize (GObject *object)
{
  NoteStoreListSearchesResult *tobject = NOTE_STORE_LIST_SEARCHES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_list_searches_result_class_init (NoteStoreListSearchesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_searches_result_read;
  struct_class->write = note_store_list_searches_result_write;

  gobject_class->finalize = note_store_list_searches_result_finalize;
  gobject_class->get_property = note_store_list_searches_result_get_property;
  gobject_class->set_property = note_store_list_searches_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SEARCHES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SEARCHES_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SEARCHES_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_list_searches_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListSearchesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_searches_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListSearchesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_searches_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListSearchesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetSearchArgsProperties
{
  PROP_NOTE_STORE_GET_SEARCH_ARGS_0,
  PROP_NOTE_STORE_GET_SEARCH_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_SEARCH_ARGS_GUID
};

/* reads a note_store_get_search_args object */
static gint32
note_store_get_search_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetSearchArgs * this_object = NOTE_STORE_GET_SEARCH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_search_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetSearchArgs * this_object = NOTE_STORE_GET_SEARCH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetSearchArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_search_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreGetSearchArgs *self = NOTE_STORE_GET_SEARCH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SEARCH_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SEARCH_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_search_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreGetSearchArgs *self = NOTE_STORE_GET_SEARCH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SEARCH_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_SEARCH_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_search_args_instance_init (NoteStoreGetSearchArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_search_args_finalize (GObject *object)
{
  NoteStoreGetSearchArgs *tobject = NOTE_STORE_GET_SEARCH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_search_args_class_init (NoteStoreGetSearchArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_search_args_read;
  struct_class->write = note_store_get_search_args_write;

  gobject_class->finalize = note_store_get_search_args_finalize;
  gobject_class->get_property = note_store_get_search_args_get_property;
  gobject_class->set_property = note_store_get_search_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SEARCH_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SEARCH_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_search_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetSearchArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_search_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetSearchArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_search_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetSearchArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetSearchResultProperties
{
  PROP_NOTE_STORE_GET_SEARCH_RESULT_0,
  PROP_NOTE_STORE_GET_SEARCH_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_SEARCH_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_SEARCH_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_SEARCH_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_search_result object */
static gint32
note_store_get_search_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetSearchResult * this_object = NOTE_STORE_GET_SEARCH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_search_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetSearchResult * this_object = NOTE_STORE_GET_SEARCH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetSearchResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_search_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreGetSearchResult *self = NOTE_STORE_GET_SEARCH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SEARCH_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SEARCH_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SEARCH_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SEARCH_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_search_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreGetSearchResult *self = NOTE_STORE_GET_SEARCH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SEARCH_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_SEARCH_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_SEARCH_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_SEARCH_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_search_result_instance_init (NoteStoreGetSearchResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SAVED_SEARCH, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_search_result_finalize (GObject *object)
{
  NoteStoreGetSearchResult *tobject = NOTE_STORE_GET_SEARCH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_search_result_class_init (NoteStoreGetSearchResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_search_result_read;
  struct_class->write = note_store_get_search_result_write;

  gobject_class->finalize = note_store_get_search_result_finalize;
  gobject_class->get_property = note_store_get_search_result_get_property;
  gobject_class->set_property = note_store_get_search_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SEARCH_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SAVED_SEARCH,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SEARCH_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SEARCH_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SEARCH_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_search_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetSearchResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_search_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetSearchResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_search_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetSearchResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateSearchArgsProperties
{
  PROP_NOTE_STORE_CREATE_SEARCH_ARGS_0,
  PROP_NOTE_STORE_CREATE_SEARCH_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_CREATE_SEARCH_ARGS_SEARCH
};

/* reads a note_store_create_search_args object */
static gint32
note_store_create_search_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateSearchArgs * this_object = NOTE_STORE_CREATE_SEARCH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->search), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_search = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_search_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateSearchArgs * this_object = NOTE_STORE_CREATE_SEARCH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateSearchArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->search), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_search_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreCreateSearchArgs *self = NOTE_STORE_CREATE_SEARCH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_SEARCH_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_SEARCH_ARGS_SEARCH:
      if (self->search != NULL)
        g_object_unref (self->search);
      self->search = g_value_dup_object (value);
      self->__isset_search = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_search_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreCreateSearchArgs *self = NOTE_STORE_CREATE_SEARCH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_SEARCH_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_CREATE_SEARCH_ARGS_SEARCH:
      g_value_set_object (value, self->search);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_search_args_instance_init (NoteStoreCreateSearchArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->search = g_object_new (TYPE_SAVED_SEARCH, NULL);
  object->__isset_search = FALSE;
}

static void 
note_store_create_search_args_finalize (GObject *object)
{
  NoteStoreCreateSearchArgs *tobject = NOTE_STORE_CREATE_SEARCH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->search != NULL)
  {
    g_object_unref(tobject->search);
    tobject->search = NULL;
  }
}

static void
note_store_create_search_args_class_init (NoteStoreCreateSearchArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_search_args_read;
  struct_class->write = note_store_create_search_args_write;

  gobject_class->finalize = note_store_create_search_args_finalize;
  gobject_class->get_property = note_store_create_search_args_get_property;
  gobject_class->set_property = note_store_create_search_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_SEARCH_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_SEARCH_ARGS_SEARCH,
     g_param_spec_object ("search",
                         NULL,
                         NULL,
                         TYPE_SAVED_SEARCH,
                         G_PARAM_READWRITE));
}

GType
note_store_create_search_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateSearchArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_search_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateSearchArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_search_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateSearchArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateSearchResultProperties
{
  PROP_NOTE_STORE_CREATE_SEARCH_RESULT_0,
  PROP_NOTE_STORE_CREATE_SEARCH_RESULT_SUCCESS,
  PROP_NOTE_STORE_CREATE_SEARCH_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_CREATE_SEARCH_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_create_search_result object */
static gint32
note_store_create_search_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateSearchResult * this_object = NOTE_STORE_CREATE_SEARCH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_search_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateSearchResult * this_object = NOTE_STORE_CREATE_SEARCH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateSearchResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_search_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreCreateSearchResult *self = NOTE_STORE_CREATE_SEARCH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_SEARCH_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_SEARCH_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_SEARCH_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_search_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreCreateSearchResult *self = NOTE_STORE_CREATE_SEARCH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_SEARCH_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_CREATE_SEARCH_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_CREATE_SEARCH_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_search_result_instance_init (NoteStoreCreateSearchResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SAVED_SEARCH, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_create_search_result_finalize (GObject *object)
{
  NoteStoreCreateSearchResult *tobject = NOTE_STORE_CREATE_SEARCH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_create_search_result_class_init (NoteStoreCreateSearchResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_search_result_read;
  struct_class->write = note_store_create_search_result_write;

  gobject_class->finalize = note_store_create_search_result_finalize;
  gobject_class->get_property = note_store_create_search_result_get_property;
  gobject_class->set_property = note_store_create_search_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_SEARCH_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SAVED_SEARCH,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_SEARCH_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_SEARCH_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_create_search_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateSearchResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_search_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateSearchResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_search_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateSearchResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateSearchArgsProperties
{
  PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_0,
  PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_SEARCH
};

/* reads a note_store_update_search_args object */
static gint32
note_store_update_search_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateSearchArgs * this_object = NOTE_STORE_UPDATE_SEARCH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->search), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_search = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_search_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateSearchArgs * this_object = NOTE_STORE_UPDATE_SEARCH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateSearchArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->search), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_search_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreUpdateSearchArgs *self = NOTE_STORE_UPDATE_SEARCH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_SEARCH:
      if (self->search != NULL)
        g_object_unref (self->search);
      self->search = g_value_dup_object (value);
      self->__isset_search = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_search_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreUpdateSearchArgs *self = NOTE_STORE_UPDATE_SEARCH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_SEARCH:
      g_value_set_object (value, self->search);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_search_args_instance_init (NoteStoreUpdateSearchArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->search = g_object_new (TYPE_SAVED_SEARCH, NULL);
  object->__isset_search = FALSE;
}

static void 
note_store_update_search_args_finalize (GObject *object)
{
  NoteStoreUpdateSearchArgs *tobject = NOTE_STORE_UPDATE_SEARCH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->search != NULL)
  {
    g_object_unref(tobject->search);
    tobject->search = NULL;
  }
}

static void
note_store_update_search_args_class_init (NoteStoreUpdateSearchArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_search_args_read;
  struct_class->write = note_store_update_search_args_write;

  gobject_class->finalize = note_store_update_search_args_finalize;
  gobject_class->get_property = note_store_update_search_args_get_property;
  gobject_class->set_property = note_store_update_search_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SEARCH_ARGS_SEARCH,
     g_param_spec_object ("search",
                         NULL,
                         NULL,
                         TYPE_SAVED_SEARCH,
                         G_PARAM_READWRITE));
}

GType
note_store_update_search_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateSearchArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_search_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateSearchArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_search_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateSearchArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateSearchResultProperties
{
  PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_0,
  PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_SUCCESS,
  PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_update_search_result object */
static gint32
note_store_update_search_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateSearchResult * this_object = NOTE_STORE_UPDATE_SEARCH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_search_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateSearchResult * this_object = NOTE_STORE_UPDATE_SEARCH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateSearchResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_search_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreUpdateSearchResult *self = NOTE_STORE_UPDATE_SEARCH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_search_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreUpdateSearchResult *self = NOTE_STORE_UPDATE_SEARCH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_search_result_instance_init (NoteStoreUpdateSearchResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_update_search_result_finalize (GObject *object)
{
  NoteStoreUpdateSearchResult *tobject = NOTE_STORE_UPDATE_SEARCH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_update_search_result_class_init (NoteStoreUpdateSearchResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_search_result_read;
  struct_class->write = note_store_update_search_result_write;

  gobject_class->finalize = note_store_update_search_result_finalize;
  gobject_class->get_property = note_store_update_search_result_get_property;
  gobject_class->set_property = note_store_update_search_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SEARCH_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_update_search_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateSearchResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_search_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateSearchResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_search_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateSearchResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeSearchArgsProperties
{
  PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_0,
  PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_GUID
};

/* reads a note_store_expunge_search_args object */
static gint32
note_store_expunge_search_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeSearchArgs * this_object = NOTE_STORE_EXPUNGE_SEARCH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_search_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeSearchArgs * this_object = NOTE_STORE_EXPUNGE_SEARCH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeSearchArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_search_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreExpungeSearchArgs *self = NOTE_STORE_EXPUNGE_SEARCH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_search_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreExpungeSearchArgs *self = NOTE_STORE_EXPUNGE_SEARCH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_search_args_instance_init (NoteStoreExpungeSearchArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_expunge_search_args_finalize (GObject *object)
{
  NoteStoreExpungeSearchArgs *tobject = NOTE_STORE_EXPUNGE_SEARCH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_expunge_search_args_class_init (NoteStoreExpungeSearchArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_search_args_read;
  struct_class->write = note_store_expunge_search_args_write;

  gobject_class->finalize = note_store_expunge_search_args_finalize;
  gobject_class->get_property = note_store_expunge_search_args_get_property;
  gobject_class->set_property = note_store_expunge_search_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_SEARCH_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_expunge_search_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeSearchArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_search_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeSearchArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_search_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeSearchArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeSearchResultProperties
{
  PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_0,
  PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_SUCCESS,
  PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_expunge_search_result object */
static gint32
note_store_expunge_search_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeSearchResult * this_object = NOTE_STORE_EXPUNGE_SEARCH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_search_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeSearchResult * this_object = NOTE_STORE_EXPUNGE_SEARCH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeSearchResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_search_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreExpungeSearchResult *self = NOTE_STORE_EXPUNGE_SEARCH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_search_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreExpungeSearchResult *self = NOTE_STORE_EXPUNGE_SEARCH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_search_result_instance_init (NoteStoreExpungeSearchResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_expunge_search_result_finalize (GObject *object)
{
  NoteStoreExpungeSearchResult *tobject = NOTE_STORE_EXPUNGE_SEARCH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_expunge_search_result_class_init (NoteStoreExpungeSearchResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_search_result_read;
  struct_class->write = note_store_expunge_search_result_write;

  gobject_class->finalize = note_store_expunge_search_result_finalize;
  gobject_class->get_property = note_store_expunge_search_result_get_property;
  gobject_class->set_property = note_store_expunge_search_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_SEARCH_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_expunge_search_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeSearchResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_search_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeSearchResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_search_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeSearchResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreFindNoteOffsetArgsProperties
{
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_0,
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_FILTER,
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_GUID
};

/* reads a note_store_find_note_offset_args object */
static gint32
note_store_find_note_offset_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreFindNoteOffsetArgs * this_object = NOTE_STORE_FIND_NOTE_OFFSET_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_find_note_offset_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreFindNoteOffsetArgs * this_object = NOTE_STORE_FIND_NOTE_OFFSET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreFindNoteOffsetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_find_note_offset_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreFindNoteOffsetArgs *self = NOTE_STORE_FIND_NOTE_OFFSET_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_find_note_offset_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreFindNoteOffsetArgs *self = NOTE_STORE_FIND_NOTE_OFFSET_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_FILTER:
      g_value_set_object (value, self->filter);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_find_note_offset_args_instance_init (NoteStoreFindNoteOffsetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->filter = g_object_new (TYPE_NOTE_FILTER, NULL);
  object->__isset_filter = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_find_note_offset_args_finalize (GObject *object)
{
  NoteStoreFindNoteOffsetArgs *tobject = NOTE_STORE_FIND_NOTE_OFFSET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_find_note_offset_args_class_init (NoteStoreFindNoteOffsetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_find_note_offset_args_read;
  struct_class->write = note_store_find_note_offset_args_write;

  gobject_class->finalize = note_store_find_note_offset_args_finalize;
  gobject_class->get_property = note_store_find_note_offset_args_get_property;
  gobject_class->set_property = note_store_find_note_offset_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_NOTE_FILTER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_OFFSET_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_find_note_offset_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreFindNoteOffsetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_find_note_offset_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreFindNoteOffsetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_find_note_offset_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreFindNoteOffsetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreFindNoteOffsetResultProperties
{
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_0,
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_SUCCESS,
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_find_note_offset_result object */
static gint32
note_store_find_note_offset_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreFindNoteOffsetResult * this_object = NOTE_STORE_FIND_NOTE_OFFSET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_find_note_offset_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreFindNoteOffsetResult * this_object = NOTE_STORE_FIND_NOTE_OFFSET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreFindNoteOffsetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_find_note_offset_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreFindNoteOffsetResult *self = NOTE_STORE_FIND_NOTE_OFFSET_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_find_note_offset_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreFindNoteOffsetResult *self = NOTE_STORE_FIND_NOTE_OFFSET_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_find_note_offset_result_instance_init (NoteStoreFindNoteOffsetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_find_note_offset_result_finalize (GObject *object)
{
  NoteStoreFindNoteOffsetResult *tobject = NOTE_STORE_FIND_NOTE_OFFSET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_find_note_offset_result_class_init (NoteStoreFindNoteOffsetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_find_note_offset_result_read;
  struct_class->write = note_store_find_note_offset_result_write;

  gobject_class->finalize = note_store_find_note_offset_result_finalize;
  gobject_class->get_property = note_store_find_note_offset_result_get_property;
  gobject_class->set_property = note_store_find_note_offset_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_OFFSET_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_find_note_offset_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreFindNoteOffsetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_find_note_offset_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreFindNoteOffsetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_find_note_offset_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreFindNoteOffsetResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreFindNotesMetadataArgsProperties
{
  PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_0,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_FILTER,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_OFFSET,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_MAX_NOTES,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_RESULT_SPEC
};

/* reads a note_store_find_notes_metadata_args object */
static gint32
note_store_find_notes_metadata_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreFindNotesMetadataArgs * this_object = NOTE_STORE_FIND_NOTES_METADATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxNotes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxNotes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->resultSpec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_resultSpec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_find_notes_metadata_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreFindNotesMetadataArgs * this_object = NOTE_STORE_FIND_NOTES_METADATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreFindNotesMetadataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "offset", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->offset, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxNotes", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxNotes, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "resultSpec", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->resultSpec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_find_notes_metadata_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreFindNotesMetadataArgs *self = NOTE_STORE_FIND_NOTES_METADATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_OFFSET:
      self->offset = g_value_get_int (value);
      self->__isset_offset = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_MAX_NOTES:
      self->maxNotes = g_value_get_int (value);
      self->__isset_maxNotes = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_RESULT_SPEC:
      if (self->resultSpec != NULL)
        g_object_unref (self->resultSpec);
      self->resultSpec = g_value_dup_object (value);
      self->__isset_resultSpec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_find_notes_metadata_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreFindNotesMetadataArgs *self = NOTE_STORE_FIND_NOTES_METADATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_FILTER:
      g_value_set_object (value, self->filter);
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_OFFSET:
      g_value_set_int (value, self->offset);
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_MAX_NOTES:
      g_value_set_int (value, self->maxNotes);
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_RESULT_SPEC:
      g_value_set_object (value, self->resultSpec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_find_notes_metadata_args_instance_init (NoteStoreFindNotesMetadataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->filter = g_object_new (TYPE_NOTE_FILTER, NULL);
  object->__isset_filter = FALSE;
  object->offset = 0;
  object->__isset_offset = FALSE;
  object->maxNotes = 0;
  object->__isset_maxNotes = FALSE;
  object->resultSpec = g_object_new (TYPE_NOTES_METADATA_RESULT_SPEC, NULL);
  object->__isset_resultSpec = FALSE;
}

static void 
note_store_find_notes_metadata_args_finalize (GObject *object)
{
  NoteStoreFindNotesMetadataArgs *tobject = NOTE_STORE_FIND_NOTES_METADATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
  if (tobject->resultSpec != NULL)
  {
    g_object_unref(tobject->resultSpec);
    tobject->resultSpec = NULL;
  }
}

static void
note_store_find_notes_metadata_args_class_init (NoteStoreFindNotesMetadataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_find_notes_metadata_args_read;
  struct_class->write = note_store_find_notes_metadata_args_write;

  gobject_class->finalize = note_store_find_notes_metadata_args_finalize;
  gobject_class->get_property = note_store_find_notes_metadata_args_get_property;
  gobject_class->set_property = note_store_find_notes_metadata_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_NOTE_FILTER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_OFFSET,
     g_param_spec_int ("offset",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_MAX_NOTES,
     g_param_spec_int ("maxNotes",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_ARGS_RESULT_SPEC,
     g_param_spec_object ("resultSpec",
                         NULL,
                         NULL,
                         TYPE_NOTES_METADATA_RESULT_SPEC,
                         G_PARAM_READWRITE));
}

GType
note_store_find_notes_metadata_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreFindNotesMetadataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_find_notes_metadata_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreFindNotesMetadataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_find_notes_metadata_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreFindNotesMetadataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreFindNotesMetadataResultProperties
{
  PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_0,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_SUCCESS,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_find_notes_metadata_result object */
static gint32
note_store_find_notes_metadata_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreFindNotesMetadataResult * this_object = NOTE_STORE_FIND_NOTES_METADATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_find_notes_metadata_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreFindNotesMetadataResult * this_object = NOTE_STORE_FIND_NOTES_METADATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreFindNotesMetadataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_find_notes_metadata_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreFindNotesMetadataResult *self = NOTE_STORE_FIND_NOTES_METADATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_find_notes_metadata_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreFindNotesMetadataResult *self = NOTE_STORE_FIND_NOTES_METADATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_find_notes_metadata_result_instance_init (NoteStoreFindNotesMetadataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTES_METADATA_LIST, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_find_notes_metadata_result_finalize (GObject *object)
{
  NoteStoreFindNotesMetadataResult *tobject = NOTE_STORE_FIND_NOTES_METADATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_find_notes_metadata_result_class_init (NoteStoreFindNotesMetadataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_find_notes_metadata_result_read;
  struct_class->write = note_store_find_notes_metadata_result_write;

  gobject_class->finalize = note_store_find_notes_metadata_result_finalize;
  gobject_class->get_property = note_store_find_notes_metadata_result_get_property;
  gobject_class->set_property = note_store_find_notes_metadata_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTES_METADATA_LIST,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTES_METADATA_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_find_notes_metadata_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreFindNotesMetadataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_find_notes_metadata_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreFindNotesMetadataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_find_notes_metadata_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreFindNotesMetadataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreFindNoteCountsArgsProperties
{
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_0,
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_FILTER,
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_WITH_TRASH
};

/* reads a note_store_find_note_counts_args object */
static gint32
note_store_find_note_counts_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreFindNoteCountsArgs * this_object = NOTE_STORE_FIND_NOTE_COUNTS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_filter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withTrash, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withTrash = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_find_note_counts_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreFindNoteCountsArgs * this_object = NOTE_STORE_FIND_NOTE_COUNTS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreFindNoteCountsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->filter), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withTrash", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withTrash, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_find_note_counts_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreFindNoteCountsArgs *self = NOTE_STORE_FIND_NOTE_COUNTS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_FILTER:
      if (self->filter != NULL)
        g_object_unref (self->filter);
      self->filter = g_value_dup_object (value);
      self->__isset_filter = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_WITH_TRASH:
      self->withTrash = g_value_get_boolean (value);
      self->__isset_withTrash = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_find_note_counts_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreFindNoteCountsArgs *self = NOTE_STORE_FIND_NOTE_COUNTS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_FILTER:
      g_value_set_object (value, self->filter);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_WITH_TRASH:
      g_value_set_boolean (value, self->withTrash);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_find_note_counts_args_instance_init (NoteStoreFindNoteCountsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->filter = g_object_new (TYPE_NOTE_FILTER, NULL);
  object->__isset_filter = FALSE;
  object->withTrash = 0;
  object->__isset_withTrash = FALSE;
}

static void 
note_store_find_note_counts_args_finalize (GObject *object)
{
  NoteStoreFindNoteCountsArgs *tobject = NOTE_STORE_FIND_NOTE_COUNTS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->filter != NULL)
  {
    g_object_unref(tobject->filter);
    tobject->filter = NULL;
  }
}

static void
note_store_find_note_counts_args_class_init (NoteStoreFindNoteCountsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_find_note_counts_args_read;
  struct_class->write = note_store_find_note_counts_args_write;

  gobject_class->finalize = note_store_find_note_counts_args_finalize;
  gobject_class->get_property = note_store_find_note_counts_args_get_property;
  gobject_class->set_property = note_store_find_note_counts_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_FILTER,
     g_param_spec_object ("filter",
                         NULL,
                         NULL,
                         TYPE_NOTE_FILTER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_COUNTS_ARGS_WITH_TRASH,
     g_param_spec_boolean ("withTrash",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_store_find_note_counts_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreFindNoteCountsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_find_note_counts_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreFindNoteCountsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_find_note_counts_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreFindNoteCountsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreFindNoteCountsResultProperties
{
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_0,
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_SUCCESS,
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_find_note_counts_result object */
static gint32
note_store_find_note_counts_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreFindNoteCountsResult * this_object = NOTE_STORE_FIND_NOTE_COUNTS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_find_note_counts_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreFindNoteCountsResult * this_object = NOTE_STORE_FIND_NOTE_COUNTS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreFindNoteCountsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_find_note_counts_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreFindNoteCountsResult *self = NOTE_STORE_FIND_NOTE_COUNTS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_find_note_counts_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreFindNoteCountsResult *self = NOTE_STORE_FIND_NOTE_COUNTS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_find_note_counts_result_instance_init (NoteStoreFindNoteCountsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTE_COLLECTION_COUNTS, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_find_note_counts_result_finalize (GObject *object)
{
  NoteStoreFindNoteCountsResult *tobject = NOTE_STORE_FIND_NOTE_COUNTS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_find_note_counts_result_class_init (NoteStoreFindNoteCountsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_find_note_counts_result_read;
  struct_class->write = note_store_find_note_counts_result_write;

  gobject_class->finalize = note_store_find_note_counts_result_finalize;
  gobject_class->get_property = note_store_find_note_counts_result_get_property;
  gobject_class->set_property = note_store_find_note_counts_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTE_COLLECTION_COUNTS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_NOTE_COUNTS_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_find_note_counts_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreFindNoteCountsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_find_note_counts_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreFindNoteCountsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_find_note_counts_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreFindNoteCountsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteWithResultSpecArgsProperties
{
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_0,
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_GUID,
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_RESULT_SPEC
};

/* reads a note_store_get_note_with_result_spec_args object */
static gint32
note_store_get_note_with_result_spec_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteWithResultSpecArgs * this_object = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->resultSpec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_resultSpec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_with_result_spec_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteWithResultSpecArgs * this_object = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteWithResultSpecArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "resultSpec", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->resultSpec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_with_result_spec_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreGetNoteWithResultSpecArgs *self = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_RESULT_SPEC:
      if (self->resultSpec != NULL)
        g_object_unref (self->resultSpec);
      self->resultSpec = g_value_dup_object (value);
      self->__isset_resultSpec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_with_result_spec_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreGetNoteWithResultSpecArgs *self = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_RESULT_SPEC:
      g_value_set_object (value, self->resultSpec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_with_result_spec_args_instance_init (NoteStoreGetNoteWithResultSpecArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->resultSpec = g_object_new (TYPE_NOTE_RESULT_SPEC, NULL);
  object->__isset_resultSpec = FALSE;
}

static void 
note_store_get_note_with_result_spec_args_finalize (GObject *object)
{
  NoteStoreGetNoteWithResultSpecArgs *tobject = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->resultSpec != NULL)
  {
    g_object_unref(tobject->resultSpec);
    tobject->resultSpec = NULL;
  }
}

static void
note_store_get_note_with_result_spec_args_class_init (NoteStoreGetNoteWithResultSpecArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_with_result_spec_args_read;
  struct_class->write = note_store_get_note_with_result_spec_args_write;

  gobject_class->finalize = note_store_get_note_with_result_spec_args_finalize;
  gobject_class->get_property = note_store_get_note_with_result_spec_args_get_property;
  gobject_class->set_property = note_store_get_note_with_result_spec_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS_RESULT_SPEC,
     g_param_spec_object ("resultSpec",
                         NULL,
                         NULL,
                         TYPE_NOTE_RESULT_SPEC,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_with_result_spec_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteWithResultSpecArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_with_result_spec_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteWithResultSpecArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_with_result_spec_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteWithResultSpecArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteWithResultSpecResultProperties
{
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_0,
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_note_with_result_spec_result object */
static gint32
note_store_get_note_with_result_spec_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteWithResultSpecResult * this_object = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_with_result_spec_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteWithResultSpecResult * this_object = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteWithResultSpecResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_with_result_spec_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreGetNoteWithResultSpecResult *self = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_with_result_spec_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreGetNoteWithResultSpecResult *self = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_with_result_spec_result_instance_init (NoteStoreGetNoteWithResultSpecResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_note_with_result_spec_result_finalize (GObject *object)
{
  NoteStoreGetNoteWithResultSpecResult *tobject = NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_note_with_result_spec_result_class_init (NoteStoreGetNoteWithResultSpecResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_with_result_spec_result_read;
  struct_class->write = note_store_get_note_with_result_spec_result_write;

  gobject_class->finalize = note_store_get_note_with_result_spec_result_finalize;
  gobject_class->get_property = note_store_get_note_with_result_spec_result_get_property;
  gobject_class->set_property = note_store_get_note_with_result_spec_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_with_result_spec_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteWithResultSpecResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_with_result_spec_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteWithResultSpecResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_with_result_spec_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteWithResultSpecResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteArgsProperties
{
  PROP_NOTE_STORE_GET_NOTE_ARGS_0,
  PROP_NOTE_STORE_GET_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTE_ARGS_GUID,
  PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_CONTENT,
  PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_DATA,
  PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_RECOGNITION,
  PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_ALTERNATE_DATA
};

/* reads a note_store_get_note_args object */
static gint32
note_store_get_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteArgs * this_object = NOTE_STORE_GET_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withContent, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withContent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withResourcesData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withResourcesData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withResourcesRecognition, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withResourcesRecognition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withResourcesAlternateData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withResourcesAlternateData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteArgs * this_object = NOTE_STORE_GET_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withContent", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withContent, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesData", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withResourcesData, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesRecognition", T_BOOL, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withResourcesRecognition, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesAlternateData", T_BOOL, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withResourcesAlternateData, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  NoteStoreGetNoteArgs *self = NOTE_STORE_GET_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_CONTENT:
      self->withContent = g_value_get_boolean (value);
      self->__isset_withContent = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_DATA:
      self->withResourcesData = g_value_get_boolean (value);
      self->__isset_withResourcesData = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_RECOGNITION:
      self->withResourcesRecognition = g_value_get_boolean (value);
      self->__isset_withResourcesRecognition = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_ALTERNATE_DATA:
      self->withResourcesAlternateData = g_value_get_boolean (value);
      self->__isset_withResourcesAlternateData = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  NoteStoreGetNoteArgs *self = NOTE_STORE_GET_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_CONTENT:
      g_value_set_boolean (value, self->withContent);
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_DATA:
      g_value_set_boolean (value, self->withResourcesData);
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_RECOGNITION:
      g_value_set_boolean (value, self->withResourcesRecognition);
      break;

    case PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_ALTERNATE_DATA:
      g_value_set_boolean (value, self->withResourcesAlternateData);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_args_instance_init (NoteStoreGetNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->withContent = 0;
  object->__isset_withContent = FALSE;
  object->withResourcesData = 0;
  object->__isset_withResourcesData = FALSE;
  object->withResourcesRecognition = 0;
  object->__isset_withResourcesRecognition = FALSE;
  object->withResourcesAlternateData = 0;
  object->__isset_withResourcesAlternateData = FALSE;
}

static void 
note_store_get_note_args_finalize (GObject *object)
{
  NoteStoreGetNoteArgs *tobject = NOTE_STORE_GET_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_note_args_class_init (NoteStoreGetNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_args_read;
  struct_class->write = note_store_get_note_args_write;

  gobject_class->finalize = note_store_get_note_args_finalize;
  gobject_class->get_property = note_store_get_note_args_get_property;
  gobject_class->set_property = note_store_get_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_CONTENT,
     g_param_spec_boolean ("withContent",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_DATA,
     g_param_spec_boolean ("withResourcesData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_RECOGNITION,
     g_param_spec_boolean ("withResourcesRecognition",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_ARGS_WITH_RESOURCES_ALTERNATE_DATA,
     g_param_spec_boolean ("withResourcesAlternateData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_store_get_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteResultProperties
{
  PROP_NOTE_STORE_GET_NOTE_RESULT_0,
  PROP_NOTE_STORE_GET_NOTE_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_note_result object */
static gint32
note_store_get_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteResult * this_object = NOTE_STORE_GET_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteResult * this_object = NOTE_STORE_GET_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreGetNoteResult *self = NOTE_STORE_GET_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreGetNoteResult *self = NOTE_STORE_GET_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_result_instance_init (NoteStoreGetNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_note_result_finalize (GObject *object)
{
  NoteStoreGetNoteResult *tobject = NOTE_STORE_GET_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_note_result_class_init (NoteStoreGetNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_result_read;
  struct_class->write = note_store_get_note_result_write;

  gobject_class->finalize = note_store_get_note_result_finalize;
  gobject_class->get_property = note_store_get_note_result_get_property;
  gobject_class->set_property = note_store_get_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteApplicationDataArgsProperties
{
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_0,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_GUID
};

/* reads a note_store_get_note_application_data_args object */
static gint32
note_store_get_note_application_data_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteApplicationDataArgs * this_object = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_application_data_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteApplicationDataArgs * this_object = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteApplicationDataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_application_data_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreGetNoteApplicationDataArgs *self = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_application_data_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreGetNoteApplicationDataArgs *self = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_application_data_args_instance_init (NoteStoreGetNoteApplicationDataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_note_application_data_args_finalize (GObject *object)
{
  NoteStoreGetNoteApplicationDataArgs *tobject = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_note_application_data_args_class_init (NoteStoreGetNoteApplicationDataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_application_data_args_read;
  struct_class->write = note_store_get_note_application_data_args_write;

  gobject_class->finalize = note_store_get_note_application_data_args_finalize;
  gobject_class->get_property = note_store_get_note_application_data_args_get_property;
  gobject_class->set_property = note_store_get_note_application_data_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_note_application_data_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteApplicationDataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_application_data_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteApplicationDataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_application_data_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteApplicationDataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteApplicationDataResultProperties
{
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_0,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_note_application_data_result object */
static gint32
note_store_get_note_application_data_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteApplicationDataResult * this_object = NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_application_data_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteApplicationDataResult * this_object = NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteApplicationDataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_application_data_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreGetNoteApplicationDataResult *self = NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_application_data_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreGetNoteApplicationDataResult *self = NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_application_data_result_instance_init (NoteStoreGetNoteApplicationDataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_LAZY_MAP, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_note_application_data_result_finalize (GObject *object)
{
  NoteStoreGetNoteApplicationDataResult *tobject = NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_note_application_data_result_class_init (NoteStoreGetNoteApplicationDataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_application_data_result_read;
  struct_class->write = note_store_get_note_application_data_result_write;

  gobject_class->finalize = note_store_get_note_application_data_result_finalize;
  gobject_class->get_property = note_store_get_note_application_data_result_get_property;
  gobject_class->set_property = note_store_get_note_application_data_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_LAZY_MAP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_application_data_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteApplicationDataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_application_data_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteApplicationDataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_application_data_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteApplicationDataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteApplicationDataEntryArgsProperties
{
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_0,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY
};

/* reads a note_store_get_note_application_data_entry_args object */
static gint32
note_store_get_note_application_data_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteApplicationDataEntryArgs * this_object = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_application_data_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteApplicationDataEntryArgs * this_object = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteApplicationDataEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_application_data_entry_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreGetNoteApplicationDataEntryArgs *self = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_application_data_entry_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreGetNoteApplicationDataEntryArgs *self = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_application_data_entry_args_instance_init (NoteStoreGetNoteApplicationDataEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
note_store_get_note_application_data_entry_args_finalize (GObject *object)
{
  NoteStoreGetNoteApplicationDataEntryArgs *tobject = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
note_store_get_note_application_data_entry_args_class_init (NoteStoreGetNoteApplicationDataEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_application_data_entry_args_read;
  struct_class->write = note_store_get_note_application_data_entry_args_write;

  gobject_class->finalize = note_store_get_note_application_data_entry_args_finalize;
  gobject_class->get_property = note_store_get_note_application_data_entry_args_get_property;
  gobject_class->set_property = note_store_get_note_application_data_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_note_application_data_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteApplicationDataEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_application_data_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteApplicationDataEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_application_data_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteApplicationDataEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteApplicationDataEntryResultProperties
{
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_0,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_note_application_data_entry_result object */
static gint32
note_store_get_note_application_data_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteApplicationDataEntryResult * this_object = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_application_data_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteApplicationDataEntryResult * this_object = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteApplicationDataEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_application_data_entry_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreGetNoteApplicationDataEntryResult *self = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_application_data_entry_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreGetNoteApplicationDataEntryResult *self = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_application_data_entry_result_instance_init (NoteStoreGetNoteApplicationDataEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_note_application_data_entry_result_finalize (GObject *object)
{
  NoteStoreGetNoteApplicationDataEntryResult *tobject = NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_note_application_data_entry_result_class_init (NoteStoreGetNoteApplicationDataEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_application_data_entry_result_read;
  struct_class->write = note_store_get_note_application_data_entry_result_write;

  gobject_class->finalize = note_store_get_note_application_data_entry_result_finalize;
  gobject_class->get_property = note_store_get_note_application_data_entry_result_get_property;
  gobject_class->set_property = note_store_get_note_application_data_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_application_data_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteApplicationDataEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_application_data_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteApplicationDataEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_application_data_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteApplicationDataEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreSetNoteApplicationDataEntryArgsProperties
{
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_0,
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID,
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY,
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_VALUE
};

/* reads a note_store_set_note_application_data_entry_args object */
static gint32
note_store_set_note_application_data_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreSetNoteApplicationDataEntryArgs * this_object = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_set_note_application_data_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreSetNoteApplicationDataEntryArgs * this_object = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreSetNoteApplicationDataEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_set_note_application_data_entry_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreSetNoteApplicationDataEntryArgs *self = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_set_note_application_data_entry_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreSetNoteApplicationDataEntryArgs *self = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_VALUE:
      g_value_set_string (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_set_note_application_data_entry_args_instance_init (NoteStoreSetNoteApplicationDataEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
note_store_set_note_application_data_entry_args_finalize (GObject *object)
{
  NoteStoreSetNoteApplicationDataEntryArgs *tobject = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
note_store_set_note_application_data_entry_args_class_init (NoteStoreSetNoteApplicationDataEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_set_note_application_data_entry_args_read;
  struct_class->write = note_store_set_note_application_data_entry_args_write;

  gobject_class->finalize = note_store_set_note_application_data_entry_args_finalize;
  gobject_class->get_property = note_store_set_note_application_data_entry_args_get_property;
  gobject_class->set_property = note_store_set_note_application_data_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_set_note_application_data_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreSetNoteApplicationDataEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_set_note_application_data_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreSetNoteApplicationDataEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_set_note_application_data_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreSetNoteApplicationDataEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreSetNoteApplicationDataEntryResultProperties
{
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_0,
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_set_note_application_data_entry_result object */
static gint32
note_store_set_note_application_data_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreSetNoteApplicationDataEntryResult * this_object = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_set_note_application_data_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreSetNoteApplicationDataEntryResult * this_object = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreSetNoteApplicationDataEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_set_note_application_data_entry_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreSetNoteApplicationDataEntryResult *self = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_set_note_application_data_entry_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreSetNoteApplicationDataEntryResult *self = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_set_note_application_data_entry_result_instance_init (NoteStoreSetNoteApplicationDataEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_set_note_application_data_entry_result_finalize (GObject *object)
{
  NoteStoreSetNoteApplicationDataEntryResult *tobject = NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_set_note_application_data_entry_result_class_init (NoteStoreSetNoteApplicationDataEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_set_note_application_data_entry_result_read;
  struct_class->write = note_store_set_note_application_data_entry_result_write;

  gobject_class->finalize = note_store_set_note_application_data_entry_result_finalize;
  gobject_class->get_property = note_store_set_note_application_data_entry_result_get_property;
  gobject_class->set_property = note_store_set_note_application_data_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_set_note_application_data_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreSetNoteApplicationDataEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_set_note_application_data_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreSetNoteApplicationDataEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_set_note_application_data_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreSetNoteApplicationDataEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUnsetNoteApplicationDataEntryArgsProperties
{
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_0,
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID,
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY
};

/* reads a note_store_unset_note_application_data_entry_args object */
static gint32
note_store_unset_note_application_data_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUnsetNoteApplicationDataEntryArgs * this_object = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_unset_note_application_data_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUnsetNoteApplicationDataEntryArgs * this_object = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUnsetNoteApplicationDataEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_unset_note_application_data_entry_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreUnsetNoteApplicationDataEntryArgs *self = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_unset_note_application_data_entry_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreUnsetNoteApplicationDataEntryArgs *self = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_unset_note_application_data_entry_args_instance_init (NoteStoreUnsetNoteApplicationDataEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
note_store_unset_note_application_data_entry_args_finalize (GObject *object)
{
  NoteStoreUnsetNoteApplicationDataEntryArgs *tobject = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
note_store_unset_note_application_data_entry_args_class_init (NoteStoreUnsetNoteApplicationDataEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_unset_note_application_data_entry_args_read;
  struct_class->write = note_store_unset_note_application_data_entry_args_write;

  gobject_class->finalize = note_store_unset_note_application_data_entry_args_finalize;
  gobject_class->get_property = note_store_unset_note_application_data_entry_args_get_property;
  gobject_class->set_property = note_store_unset_note_application_data_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_unset_note_application_data_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUnsetNoteApplicationDataEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_unset_note_application_data_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUnsetNoteApplicationDataEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_unset_note_application_data_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUnsetNoteApplicationDataEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUnsetNoteApplicationDataEntryResultProperties
{
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_0,
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_unset_note_application_data_entry_result object */
static gint32
note_store_unset_note_application_data_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUnsetNoteApplicationDataEntryResult * this_object = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_unset_note_application_data_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUnsetNoteApplicationDataEntryResult * this_object = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUnsetNoteApplicationDataEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_unset_note_application_data_entry_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  NoteStoreUnsetNoteApplicationDataEntryResult *self = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_unset_note_application_data_entry_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  NoteStoreUnsetNoteApplicationDataEntryResult *self = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_unset_note_application_data_entry_result_instance_init (NoteStoreUnsetNoteApplicationDataEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_unset_note_application_data_entry_result_finalize (GObject *object)
{
  NoteStoreUnsetNoteApplicationDataEntryResult *tobject = NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_unset_note_application_data_entry_result_class_init (NoteStoreUnsetNoteApplicationDataEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_unset_note_application_data_entry_result_read;
  struct_class->write = note_store_unset_note_application_data_entry_result_write;

  gobject_class->finalize = note_store_unset_note_application_data_entry_result_finalize;
  gobject_class->get_property = note_store_unset_note_application_data_entry_result_get_property;
  gobject_class->set_property = note_store_unset_note_application_data_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_unset_note_application_data_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUnsetNoteApplicationDataEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_unset_note_application_data_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUnsetNoteApplicationDataEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_unset_note_application_data_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUnsetNoteApplicationDataEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteContentArgsProperties
{
  PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_0,
  PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_GUID
};

/* reads a note_store_get_note_content_args object */
static gint32
note_store_get_note_content_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteContentArgs * this_object = NOTE_STORE_GET_NOTE_CONTENT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_content_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteContentArgs * this_object = NOTE_STORE_GET_NOTE_CONTENT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteContentArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_content_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreGetNoteContentArgs *self = NOTE_STORE_GET_NOTE_CONTENT_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_content_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreGetNoteContentArgs *self = NOTE_STORE_GET_NOTE_CONTENT_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_content_args_instance_init (NoteStoreGetNoteContentArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_note_content_args_finalize (GObject *object)
{
  NoteStoreGetNoteContentArgs *tobject = NOTE_STORE_GET_NOTE_CONTENT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_note_content_args_class_init (NoteStoreGetNoteContentArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_content_args_read;
  struct_class->write = note_store_get_note_content_args_write;

  gobject_class->finalize = note_store_get_note_content_args_finalize;
  gobject_class->get_property = note_store_get_note_content_args_get_property;
  gobject_class->set_property = note_store_get_note_content_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_CONTENT_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_note_content_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteContentArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_content_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteContentArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_content_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteContentArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteContentResultProperties
{
  PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_0,
  PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_note_content_result object */
static gint32
note_store_get_note_content_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteContentResult * this_object = NOTE_STORE_GET_NOTE_CONTENT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_content_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteContentResult * this_object = NOTE_STORE_GET_NOTE_CONTENT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteContentResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_content_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreGetNoteContentResult *self = NOTE_STORE_GET_NOTE_CONTENT_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_content_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreGetNoteContentResult *self = NOTE_STORE_GET_NOTE_CONTENT_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_content_result_instance_init (NoteStoreGetNoteContentResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_note_content_result_finalize (GObject *object)
{
  NoteStoreGetNoteContentResult *tobject = NOTE_STORE_GET_NOTE_CONTENT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_note_content_result_class_init (NoteStoreGetNoteContentResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_content_result_read;
  struct_class->write = note_store_get_note_content_result_write;

  gobject_class->finalize = note_store_get_note_content_result_finalize;
  gobject_class->get_property = note_store_get_note_content_result_get_property;
  gobject_class->set_property = note_store_get_note_content_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_CONTENT_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_content_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteContentResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_content_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteContentResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_content_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteContentResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteSearchTextArgsProperties
{
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_0,
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_GUID,
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_NOTE_ONLY,
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_TOKENIZE_FOR_INDEXING
};

/* reads a note_store_get_note_search_text_args object */
static gint32
note_store_get_note_search_text_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteSearchTextArgs * this_object = NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->noteOnly, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteOnly = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->tokenizeForIndexing, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tokenizeForIndexing = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_search_text_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteSearchTextArgs * this_object = NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteSearchTextArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "noteOnly", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->noteOnly, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tokenizeForIndexing", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->tokenizeForIndexing, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_search_text_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreGetNoteSearchTextArgs *self = NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_NOTE_ONLY:
      self->noteOnly = g_value_get_boolean (value);
      self->__isset_noteOnly = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_TOKENIZE_FOR_INDEXING:
      self->tokenizeForIndexing = g_value_get_boolean (value);
      self->__isset_tokenizeForIndexing = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_search_text_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreGetNoteSearchTextArgs *self = NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_NOTE_ONLY:
      g_value_set_boolean (value, self->noteOnly);
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_TOKENIZE_FOR_INDEXING:
      g_value_set_boolean (value, self->tokenizeForIndexing);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_search_text_args_instance_init (NoteStoreGetNoteSearchTextArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->noteOnly = 0;
  object->__isset_noteOnly = FALSE;
  object->tokenizeForIndexing = 0;
  object->__isset_tokenizeForIndexing = FALSE;
}

static void 
note_store_get_note_search_text_args_finalize (GObject *object)
{
  NoteStoreGetNoteSearchTextArgs *tobject = NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_note_search_text_args_class_init (NoteStoreGetNoteSearchTextArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_search_text_args_read;
  struct_class->write = note_store_get_note_search_text_args_write;

  gobject_class->finalize = note_store_get_note_search_text_args_finalize;
  gobject_class->get_property = note_store_get_note_search_text_args_get_property;
  gobject_class->set_property = note_store_get_note_search_text_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_NOTE_ONLY,
     g_param_spec_boolean ("noteOnly",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS_TOKENIZE_FOR_INDEXING,
     g_param_spec_boolean ("tokenizeForIndexing",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_store_get_note_search_text_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteSearchTextArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_search_text_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteSearchTextArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_search_text_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteSearchTextArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteSearchTextResultProperties
{
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_0,
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_note_search_text_result object */
static gint32
note_store_get_note_search_text_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteSearchTextResult * this_object = NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_search_text_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteSearchTextResult * this_object = NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteSearchTextResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_search_text_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreGetNoteSearchTextResult *self = NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_search_text_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreGetNoteSearchTextResult *self = NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_search_text_result_instance_init (NoteStoreGetNoteSearchTextResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_note_search_text_result_finalize (GObject *object)
{
  NoteStoreGetNoteSearchTextResult *tobject = NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_note_search_text_result_class_init (NoteStoreGetNoteSearchTextResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_search_text_result_read;
  struct_class->write = note_store_get_note_search_text_result_write;

  gobject_class->finalize = note_store_get_note_search_text_result_finalize;
  gobject_class->get_property = note_store_get_note_search_text_result_get_property;
  gobject_class->set_property = note_store_get_note_search_text_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_search_text_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteSearchTextResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_search_text_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteSearchTextResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_search_text_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteSearchTextResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceSearchTextArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_GUID
};

/* reads a note_store_get_resource_search_text_args object */
static gint32
note_store_get_resource_search_text_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceSearchTextArgs * this_object = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_search_text_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceSearchTextArgs * this_object = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceSearchTextArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_search_text_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreGetResourceSearchTextArgs *self = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_search_text_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreGetResourceSearchTextArgs *self = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_search_text_args_instance_init (NoteStoreGetResourceSearchTextArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_resource_search_text_args_finalize (GObject *object)
{
  NoteStoreGetResourceSearchTextArgs *tobject = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_resource_search_text_args_class_init (NoteStoreGetResourceSearchTextArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_search_text_args_read;
  struct_class->write = note_store_get_resource_search_text_args_write;

  gobject_class->finalize = note_store_get_resource_search_text_args_finalize;
  gobject_class->get_property = note_store_get_resource_search_text_args_get_property;
  gobject_class->set_property = note_store_get_resource_search_text_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_resource_search_text_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceSearchTextArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_search_text_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceSearchTextArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_search_text_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceSearchTextArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceSearchTextResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_search_text_result object */
static gint32
note_store_get_resource_search_text_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceSearchTextResult * this_object = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_search_text_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceSearchTextResult * this_object = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceSearchTextResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_search_text_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  NoteStoreGetResourceSearchTextResult *self = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_search_text_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  NoteStoreGetResourceSearchTextResult *self = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_search_text_result_instance_init (NoteStoreGetResourceSearchTextResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_search_text_result_finalize (GObject *object)
{
  NoteStoreGetResourceSearchTextResult *tobject = NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_search_text_result_class_init (NoteStoreGetResourceSearchTextResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_search_text_result_read;
  struct_class->write = note_store_get_resource_search_text_result_write;

  gobject_class->finalize = note_store_get_resource_search_text_result_finalize;
  gobject_class->get_property = note_store_get_resource_search_text_result_get_property;
  gobject_class->set_property = note_store_get_resource_search_text_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_search_text_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceSearchTextResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_search_text_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceSearchTextResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_search_text_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceSearchTextResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteTagNamesArgsProperties
{
  PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_0,
  PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_GUID
};

/* reads a note_store_get_note_tag_names_args object */
static gint32
note_store_get_note_tag_names_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteTagNamesArgs * this_object = NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_tag_names_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteTagNamesArgs * this_object = NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteTagNamesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_tag_names_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreGetNoteTagNamesArgs *self = NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_tag_names_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreGetNoteTagNamesArgs *self = NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_tag_names_args_instance_init (NoteStoreGetNoteTagNamesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_note_tag_names_args_finalize (GObject *object)
{
  NoteStoreGetNoteTagNamesArgs *tobject = NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_note_tag_names_args_class_init (NoteStoreGetNoteTagNamesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_tag_names_args_read;
  struct_class->write = note_store_get_note_tag_names_args_write;

  gobject_class->finalize = note_store_get_note_tag_names_args_finalize;
  gobject_class->get_property = note_store_get_note_tag_names_args_get_property;
  gobject_class->set_property = note_store_get_note_tag_names_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_note_tag_names_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteTagNamesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_tag_names_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteTagNamesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_tag_names_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteTagNamesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteTagNamesResultProperties
{
  PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_0,
  PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_note_tag_names_result object */
static gint32
note_store_get_note_tag_names_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteTagNamesResult * this_object = NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem114 = NULL;
              if (_elem114 != NULL)
              {
                g_free(_elem114);
                _elem114 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem114, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem114);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_tag_names_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteTagNamesResult * this_object = NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteTagNamesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i115;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i115 = 0; i115 < (this_object->success ? this_object->success->len : 0); i115++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i115)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_tag_names_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreGetNoteTagNamesResult *self = NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_tag_names_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreGetNoteTagNamesResult *self = NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_tag_names_result_instance_init (NoteStoreGetNoteTagNamesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_note_tag_names_result_finalize (GObject *object)
{
  NoteStoreGetNoteTagNamesResult *tobject = NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_note_tag_names_result_class_init (NoteStoreGetNoteTagNamesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_tag_names_result_read;
  struct_class->write = note_store_get_note_tag_names_result_write;

  gobject_class->finalize = note_store_get_note_tag_names_result_finalize;
  gobject_class->get_property = note_store_get_note_tag_names_result_get_property;
  gobject_class->set_property = note_store_get_note_tag_names_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_tag_names_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteTagNamesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_tag_names_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteTagNamesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_tag_names_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteTagNamesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateNoteArgsProperties
{
  PROP_NOTE_STORE_CREATE_NOTE_ARGS_0,
  PROP_NOTE_STORE_CREATE_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_CREATE_NOTE_ARGS_NOTE
};

/* reads a note_store_create_note_args object */
static gint32
note_store_create_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateNoteArgs * this_object = NOTE_STORE_CREATE_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_note = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateNoteArgs * this_object = NOTE_STORE_CREATE_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "note", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_note_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreCreateNoteArgs *self = NOTE_STORE_CREATE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_NOTE_ARGS_NOTE:
      if (self->note != NULL)
        g_object_unref (self->note);
      self->note = g_value_dup_object (value);
      self->__isset_note = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_note_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreCreateNoteArgs *self = NOTE_STORE_CREATE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_CREATE_NOTE_ARGS_NOTE:
      g_value_set_object (value, self->note);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_note_args_instance_init (NoteStoreCreateNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->note = g_object_new (TYPE_NOTE, NULL);
  object->__isset_note = FALSE;
}

static void 
note_store_create_note_args_finalize (GObject *object)
{
  NoteStoreCreateNoteArgs *tobject = NOTE_STORE_CREATE_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->note != NULL)
  {
    g_object_unref(tobject->note);
    tobject->note = NULL;
  }
}

static void
note_store_create_note_args_class_init (NoteStoreCreateNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_note_args_read;
  struct_class->write = note_store_create_note_args_write;

  gobject_class->finalize = note_store_create_note_args_finalize;
  gobject_class->get_property = note_store_create_note_args_get_property;
  gobject_class->set_property = note_store_create_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTE_ARGS_NOTE,
     g_param_spec_object ("note",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));
}

GType
note_store_create_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateNoteResultProperties
{
  PROP_NOTE_STORE_CREATE_NOTE_RESULT_0,
  PROP_NOTE_STORE_CREATE_NOTE_RESULT_SUCCESS,
  PROP_NOTE_STORE_CREATE_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_CREATE_NOTE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_CREATE_NOTE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_create_note_result object */
static gint32
note_store_create_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateNoteResult * this_object = NOTE_STORE_CREATE_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateNoteResult * this_object = NOTE_STORE_CREATE_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_note_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreCreateNoteResult *self = NOTE_STORE_CREATE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_NOTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_note_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreCreateNoteResult *self = NOTE_STORE_CREATE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_NOTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_CREATE_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_CREATE_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_CREATE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_note_result_instance_init (NoteStoreCreateNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_create_note_result_finalize (GObject *object)
{
  NoteStoreCreateNoteResult *tobject = NOTE_STORE_CREATE_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_create_note_result_class_init (NoteStoreCreateNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_note_result_read;
  struct_class->write = note_store_create_note_result_write;

  gobject_class->finalize = note_store_create_note_result_finalize;
  gobject_class->get_property = note_store_create_note_result_get_property;
  gobject_class->set_property = note_store_create_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_create_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateNoteArgsProperties
{
  PROP_NOTE_STORE_UPDATE_NOTE_ARGS_0,
  PROP_NOTE_STORE_UPDATE_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UPDATE_NOTE_ARGS_NOTE
};

/* reads a note_store_update_note_args object */
static gint32
note_store_update_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateNoteArgs * this_object = NOTE_STORE_UPDATE_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_note = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateNoteArgs * this_object = NOTE_STORE_UPDATE_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "note", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_note_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreUpdateNoteArgs *self = NOTE_STORE_UPDATE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_ARGS_NOTE:
      if (self->note != NULL)
        g_object_unref (self->note);
      self->note = g_value_dup_object (value);
      self->__isset_note = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_note_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreUpdateNoteArgs *self = NOTE_STORE_UPDATE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_ARGS_NOTE:
      g_value_set_object (value, self->note);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_note_args_instance_init (NoteStoreUpdateNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->note = g_object_new (TYPE_NOTE, NULL);
  object->__isset_note = FALSE;
}

static void 
note_store_update_note_args_finalize (GObject *object)
{
  NoteStoreUpdateNoteArgs *tobject = NOTE_STORE_UPDATE_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->note != NULL)
  {
    g_object_unref(tobject->note);
    tobject->note = NULL;
  }
}

static void
note_store_update_note_args_class_init (NoteStoreUpdateNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_note_args_read;
  struct_class->write = note_store_update_note_args_write;

  gobject_class->finalize = note_store_update_note_args_finalize;
  gobject_class->get_property = note_store_update_note_args_get_property;
  gobject_class->set_property = note_store_update_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_ARGS_NOTE,
     g_param_spec_object ("note",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));
}

GType
note_store_update_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateNoteResultProperties
{
  PROP_NOTE_STORE_UPDATE_NOTE_RESULT_0,
  PROP_NOTE_STORE_UPDATE_NOTE_RESULT_SUCCESS,
  PROP_NOTE_STORE_UPDATE_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_NOTE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_NOTE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_update_note_result object */
static gint32
note_store_update_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateNoteResult * this_object = NOTE_STORE_UPDATE_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateNoteResult * this_object = NOTE_STORE_UPDATE_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_note_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreUpdateNoteResult *self = NOTE_STORE_UPDATE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_note_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreUpdateNoteResult *self = NOTE_STORE_UPDATE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_note_result_instance_init (NoteStoreUpdateNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_update_note_result_finalize (GObject *object)
{
  NoteStoreUpdateNoteResult *tobject = NOTE_STORE_UPDATE_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_update_note_result_class_init (NoteStoreUpdateNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_note_result_read;
  struct_class->write = note_store_update_note_result_write;

  gobject_class->finalize = note_store_update_note_result_finalize;
  gobject_class->get_property = note_store_update_note_result_get_property;
  gobject_class->set_property = note_store_update_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_update_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreDeleteNoteArgsProperties
{
  PROP_NOTE_STORE_DELETE_NOTE_ARGS_0,
  PROP_NOTE_STORE_DELETE_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_DELETE_NOTE_ARGS_GUID
};

/* reads a note_store_delete_note_args object */
static gint32
note_store_delete_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreDeleteNoteArgs * this_object = NOTE_STORE_DELETE_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_delete_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreDeleteNoteArgs * this_object = NOTE_STORE_DELETE_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreDeleteNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_delete_note_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreDeleteNoteArgs *self = NOTE_STORE_DELETE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_DELETE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_DELETE_NOTE_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_delete_note_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreDeleteNoteArgs *self = NOTE_STORE_DELETE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_DELETE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_DELETE_NOTE_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_delete_note_args_instance_init (NoteStoreDeleteNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_delete_note_args_finalize (GObject *object)
{
  NoteStoreDeleteNoteArgs *tobject = NOTE_STORE_DELETE_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_delete_note_args_class_init (NoteStoreDeleteNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_delete_note_args_read;
  struct_class->write = note_store_delete_note_args_write;

  gobject_class->finalize = note_store_delete_note_args_finalize;
  gobject_class->get_property = note_store_delete_note_args_get_property;
  gobject_class->set_property = note_store_delete_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_DELETE_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_DELETE_NOTE_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_delete_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreDeleteNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_delete_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreDeleteNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_delete_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreDeleteNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreDeleteNoteResultProperties
{
  PROP_NOTE_STORE_DELETE_NOTE_RESULT_0,
  PROP_NOTE_STORE_DELETE_NOTE_RESULT_SUCCESS,
  PROP_NOTE_STORE_DELETE_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_DELETE_NOTE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_DELETE_NOTE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_delete_note_result object */
static gint32
note_store_delete_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreDeleteNoteResult * this_object = NOTE_STORE_DELETE_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_delete_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreDeleteNoteResult * this_object = NOTE_STORE_DELETE_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreDeleteNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_delete_note_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreDeleteNoteResult *self = NOTE_STORE_DELETE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_DELETE_NOTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_DELETE_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_DELETE_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_DELETE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_delete_note_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  NoteStoreDeleteNoteResult *self = NOTE_STORE_DELETE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_DELETE_NOTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_DELETE_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_DELETE_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_DELETE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_delete_note_result_instance_init (NoteStoreDeleteNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_delete_note_result_finalize (GObject *object)
{
  NoteStoreDeleteNoteResult *tobject = NOTE_STORE_DELETE_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_delete_note_result_class_init (NoteStoreDeleteNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_delete_note_result_read;
  struct_class->write = note_store_delete_note_result_write;

  gobject_class->finalize = note_store_delete_note_result_finalize;
  gobject_class->get_property = note_store_delete_note_result_get_property;
  gobject_class->set_property = note_store_delete_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_DELETE_NOTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_DELETE_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_DELETE_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_DELETE_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_delete_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreDeleteNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_delete_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreDeleteNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_delete_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreDeleteNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeNoteArgsProperties
{
  PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_0,
  PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_GUID
};

/* reads a note_store_expunge_note_args object */
static gint32
note_store_expunge_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeNoteArgs * this_object = NOTE_STORE_EXPUNGE_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeNoteArgs * this_object = NOTE_STORE_EXPUNGE_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_note_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreExpungeNoteArgs *self = NOTE_STORE_EXPUNGE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_note_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreExpungeNoteArgs *self = NOTE_STORE_EXPUNGE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_note_args_instance_init (NoteStoreExpungeNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_expunge_note_args_finalize (GObject *object)
{
  NoteStoreExpungeNoteArgs *tobject = NOTE_STORE_EXPUNGE_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_expunge_note_args_class_init (NoteStoreExpungeNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_note_args_read;
  struct_class->write = note_store_expunge_note_args_write;

  gobject_class->finalize = note_store_expunge_note_args_finalize;
  gobject_class->get_property = note_store_expunge_note_args_get_property;
  gobject_class->set_property = note_store_expunge_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTE_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_expunge_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeNoteResultProperties
{
  PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_0,
  PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_SUCCESS,
  PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_expunge_note_result object */
static gint32
note_store_expunge_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeNoteResult * this_object = NOTE_STORE_EXPUNGE_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeNoteResult * this_object = NOTE_STORE_EXPUNGE_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_note_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreExpungeNoteResult *self = NOTE_STORE_EXPUNGE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_note_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreExpungeNoteResult *self = NOTE_STORE_EXPUNGE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_note_result_instance_init (NoteStoreExpungeNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_expunge_note_result_finalize (GObject *object)
{
  NoteStoreExpungeNoteResult *tobject = NOTE_STORE_EXPUNGE_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_expunge_note_result_class_init (NoteStoreExpungeNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_note_result_read;
  struct_class->write = note_store_expunge_note_result_write;

  gobject_class->finalize = note_store_expunge_note_result_finalize;
  gobject_class->get_property = note_store_expunge_note_result_get_property;
  gobject_class->set_property = note_store_expunge_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_expunge_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCopyNoteArgsProperties
{
  PROP_NOTE_STORE_COPY_NOTE_ARGS_0,
  PROP_NOTE_STORE_COPY_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_COPY_NOTE_ARGS_NOTE_GUID,
  PROP_NOTE_STORE_COPY_NOTE_ARGS_TO_NOTEBOOK_GUID
};

/* reads a note_store_copy_note_args object */
static gint32
note_store_copy_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCopyNoteArgs * this_object = NOTE_STORE_COPY_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->noteGuid != NULL)
          {
            g_free(this_object->noteGuid);
            this_object->noteGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->toNotebookGuid != NULL)
          {
            g_free(this_object->toNotebookGuid);
            this_object->toNotebookGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->toNotebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_toNotebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_copy_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCopyNoteArgs * this_object = NOTE_STORE_COPY_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCopyNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->noteGuid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "toNotebookGuid", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->toNotebookGuid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_copy_note_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  NoteStoreCopyNoteArgs *self = NOTE_STORE_COPY_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_COPY_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_COPY_NOTE_ARGS_NOTE_GUID:
      if (self->noteGuid != NULL)
        g_free (self->noteGuid);
      self->noteGuid = g_value_dup_string (value);
      self->__isset_noteGuid = TRUE;
      break;

    case PROP_NOTE_STORE_COPY_NOTE_ARGS_TO_NOTEBOOK_GUID:
      if (self->toNotebookGuid != NULL)
        g_free (self->toNotebookGuid);
      self->toNotebookGuid = g_value_dup_string (value);
      self->__isset_toNotebookGuid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_copy_note_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  NoteStoreCopyNoteArgs *self = NOTE_STORE_COPY_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_COPY_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_COPY_NOTE_ARGS_NOTE_GUID:
      g_value_set_string (value, self->noteGuid);
      break;

    case PROP_NOTE_STORE_COPY_NOTE_ARGS_TO_NOTEBOOK_GUID:
      g_value_set_string (value, self->toNotebookGuid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_copy_note_args_instance_init (NoteStoreCopyNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->noteGuid = NULL;
  object->__isset_noteGuid = FALSE;
  object->toNotebookGuid = NULL;
  object->__isset_toNotebookGuid = FALSE;
}

static void 
note_store_copy_note_args_finalize (GObject *object)
{
  NoteStoreCopyNoteArgs *tobject = NOTE_STORE_COPY_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->noteGuid != NULL)
  {
    g_free(tobject->noteGuid);
    tobject->noteGuid = NULL;
  }
  if (tobject->toNotebookGuid != NULL)
  {
    g_free(tobject->toNotebookGuid);
    tobject->toNotebookGuid = NULL;
  }
}

static void
note_store_copy_note_args_class_init (NoteStoreCopyNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_copy_note_args_read;
  struct_class->write = note_store_copy_note_args_write;

  gobject_class->finalize = note_store_copy_note_args_finalize;
  gobject_class->get_property = note_store_copy_note_args_get_property;
  gobject_class->set_property = note_store_copy_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_COPY_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_COPY_NOTE_ARGS_NOTE_GUID,
     g_param_spec_string ("noteGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_COPY_NOTE_ARGS_TO_NOTEBOOK_GUID,
     g_param_spec_string ("toNotebookGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_copy_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCopyNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_copy_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCopyNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_copy_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCopyNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCopyNoteResultProperties
{
  PROP_NOTE_STORE_COPY_NOTE_RESULT_0,
  PROP_NOTE_STORE_COPY_NOTE_RESULT_SUCCESS,
  PROP_NOTE_STORE_COPY_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_COPY_NOTE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_COPY_NOTE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_copy_note_result object */
static gint32
note_store_copy_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCopyNoteResult * this_object = NOTE_STORE_COPY_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_copy_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCopyNoteResult * this_object = NOTE_STORE_COPY_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCopyNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_copy_note_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreCopyNoteResult *self = NOTE_STORE_COPY_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_COPY_NOTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_COPY_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_COPY_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_COPY_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_copy_note_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  NoteStoreCopyNoteResult *self = NOTE_STORE_COPY_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_COPY_NOTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_COPY_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_COPY_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_COPY_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_copy_note_result_instance_init (NoteStoreCopyNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_copy_note_result_finalize (GObject *object)
{
  NoteStoreCopyNoteResult *tobject = NOTE_STORE_COPY_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_copy_note_result_class_init (NoteStoreCopyNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_copy_note_result_read;
  struct_class->write = note_store_copy_note_result_write;

  gobject_class->finalize = note_store_copy_note_result_finalize;
  gobject_class->get_property = note_store_copy_note_result_get_property;
  gobject_class->set_property = note_store_copy_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_COPY_NOTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_COPY_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_COPY_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_COPY_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_copy_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCopyNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_copy_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCopyNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_copy_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCopyNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListNoteVersionsArgsProperties
{
  PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_0,
  PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_NOTE_GUID
};

/* reads a note_store_list_note_versions_args object */
static gint32
note_store_list_note_versions_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListNoteVersionsArgs * this_object = NOTE_STORE_LIST_NOTE_VERSIONS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->noteGuid != NULL)
          {
            g_free(this_object->noteGuid);
            this_object->noteGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_note_versions_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListNoteVersionsArgs * this_object = NOTE_STORE_LIST_NOTE_VERSIONS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListNoteVersionsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->noteGuid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_note_versions_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreListNoteVersionsArgs *self = NOTE_STORE_LIST_NOTE_VERSIONS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_NOTE_GUID:
      if (self->noteGuid != NULL)
        g_free (self->noteGuid);
      self->noteGuid = g_value_dup_string (value);
      self->__isset_noteGuid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_note_versions_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreListNoteVersionsArgs *self = NOTE_STORE_LIST_NOTE_VERSIONS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_NOTE_GUID:
      g_value_set_string (value, self->noteGuid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_note_versions_args_instance_init (NoteStoreListNoteVersionsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->noteGuid = NULL;
  object->__isset_noteGuid = FALSE;
}

static void 
note_store_list_note_versions_args_finalize (GObject *object)
{
  NoteStoreListNoteVersionsArgs *tobject = NOTE_STORE_LIST_NOTE_VERSIONS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->noteGuid != NULL)
  {
    g_free(tobject->noteGuid);
    tobject->noteGuid = NULL;
  }
}

static void
note_store_list_note_versions_args_class_init (NoteStoreListNoteVersionsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_note_versions_args_read;
  struct_class->write = note_store_list_note_versions_args_write;

  gobject_class->finalize = note_store_list_note_versions_args_finalize;
  gobject_class->get_property = note_store_list_note_versions_args_get_property;
  gobject_class->set_property = note_store_list_note_versions_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS_NOTE_GUID,
     g_param_spec_string ("noteGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_list_note_versions_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListNoteVersionsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_note_versions_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListNoteVersionsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_note_versions_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListNoteVersionsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListNoteVersionsResultProperties
{
  PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_0,
  PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_SUCCESS,
  PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_list_note_versions_result object */
static gint32
note_store_list_note_versions_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListNoteVersionsResult * this_object = NOTE_STORE_LIST_NOTE_VERSIONS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              NoteVersionId * _elem116 = NULL;
              if ( _elem116 != NULL)
              {
                g_object_unref (_elem116);
              }
              _elem116 = g_object_new (TYPE_NOTE_VERSION_ID, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem116), protocol, error)) < 0)
              {
                g_object_unref (_elem116);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem116);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_note_versions_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListNoteVersionsResult * this_object = NOTE_STORE_LIST_NOTE_VERSIONS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListNoteVersionsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i117;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i117 = 0; i117 < (this_object->success ? this_object->success->len : 0); i117++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i117))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_note_versions_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreListNoteVersionsResult *self = NOTE_STORE_LIST_NOTE_VERSIONS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_note_versions_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreListNoteVersionsResult *self = NOTE_STORE_LIST_NOTE_VERSIONS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_note_versions_result_instance_init (NoteStoreListNoteVersionsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_list_note_versions_result_finalize (GObject *object)
{
  NoteStoreListNoteVersionsResult *tobject = NOTE_STORE_LIST_NOTE_VERSIONS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_list_note_versions_result_class_init (NoteStoreListNoteVersionsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_note_versions_result_read;
  struct_class->write = note_store_list_note_versions_result_write;

  gobject_class->finalize = note_store_list_note_versions_result_finalize;
  gobject_class->get_property = note_store_list_note_versions_result_get_property;
  gobject_class->set_property = note_store_list_note_versions_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_list_note_versions_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListNoteVersionsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_note_versions_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListNoteVersionsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_note_versions_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListNoteVersionsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteVersionArgsProperties
{
  PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_0,
  PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_NOTE_GUID,
  PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_UPDATE_SEQUENCE_NUM,
  PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_DATA,
  PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_RECOGNITION,
  PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_ALTERNATE_DATA
};

/* reads a note_store_get_note_version_args object */
static gint32
note_store_get_note_version_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteVersionArgs * this_object = NOTE_STORE_GET_NOTE_VERSION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->noteGuid != NULL)
          {
            g_free(this_object->noteGuid);
            this_object->noteGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->updateSequenceNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateSequenceNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withResourcesData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withResourcesData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withResourcesRecognition, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withResourcesRecognition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withResourcesAlternateData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withResourcesAlternateData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_version_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteVersionArgs * this_object = NOTE_STORE_GET_NOTE_VERSION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteVersionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->noteGuid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updateSequenceNum", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->updateSequenceNum, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesData", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withResourcesData, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesRecognition", T_BOOL, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withResourcesRecognition, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesAlternateData", T_BOOL, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withResourcesAlternateData, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_version_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreGetNoteVersionArgs *self = NOTE_STORE_GET_NOTE_VERSION_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_NOTE_GUID:
      if (self->noteGuid != NULL)
        g_free (self->noteGuid);
      self->noteGuid = g_value_dup_string (value);
      self->__isset_noteGuid = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_UPDATE_SEQUENCE_NUM:
      self->updateSequenceNum = g_value_get_int (value);
      self->__isset_updateSequenceNum = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_DATA:
      self->withResourcesData = g_value_get_boolean (value);
      self->__isset_withResourcesData = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_RECOGNITION:
      self->withResourcesRecognition = g_value_get_boolean (value);
      self->__isset_withResourcesRecognition = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_ALTERNATE_DATA:
      self->withResourcesAlternateData = g_value_get_boolean (value);
      self->__isset_withResourcesAlternateData = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_version_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreGetNoteVersionArgs *self = NOTE_STORE_GET_NOTE_VERSION_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_NOTE_GUID:
      g_value_set_string (value, self->noteGuid);
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_UPDATE_SEQUENCE_NUM:
      g_value_set_int (value, self->updateSequenceNum);
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_DATA:
      g_value_set_boolean (value, self->withResourcesData);
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_RECOGNITION:
      g_value_set_boolean (value, self->withResourcesRecognition);
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_ALTERNATE_DATA:
      g_value_set_boolean (value, self->withResourcesAlternateData);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_version_args_instance_init (NoteStoreGetNoteVersionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->noteGuid = NULL;
  object->__isset_noteGuid = FALSE;
  object->updateSequenceNum = 0;
  object->__isset_updateSequenceNum = FALSE;
  object->withResourcesData = 0;
  object->__isset_withResourcesData = FALSE;
  object->withResourcesRecognition = 0;
  object->__isset_withResourcesRecognition = FALSE;
  object->withResourcesAlternateData = 0;
  object->__isset_withResourcesAlternateData = FALSE;
}

static void 
note_store_get_note_version_args_finalize (GObject *object)
{
  NoteStoreGetNoteVersionArgs *tobject = NOTE_STORE_GET_NOTE_VERSION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->noteGuid != NULL)
  {
    g_free(tobject->noteGuid);
    tobject->noteGuid = NULL;
  }
}

static void
note_store_get_note_version_args_class_init (NoteStoreGetNoteVersionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_version_args_read;
  struct_class->write = note_store_get_note_version_args_write;

  gobject_class->finalize = note_store_get_note_version_args_finalize;
  gobject_class->get_property = note_store_get_note_version_args_get_property;
  gobject_class->set_property = note_store_get_note_version_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_NOTE_GUID,
     g_param_spec_string ("noteGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_UPDATE_SEQUENCE_NUM,
     g_param_spec_int ("updateSequenceNum",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_DATA,
     g_param_spec_boolean ("withResourcesData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_RECOGNITION,
     g_param_spec_boolean ("withResourcesRecognition",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_ARGS_WITH_RESOURCES_ALTERNATE_DATA,
     g_param_spec_boolean ("withResourcesAlternateData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_store_get_note_version_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteVersionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_version_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteVersionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_version_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteVersionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNoteVersionResultProperties
{
  PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_0,
  PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_note_version_result object */
static gint32
note_store_get_note_version_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNoteVersionResult * this_object = NOTE_STORE_GET_NOTE_VERSION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_note_version_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNoteVersionResult * this_object = NOTE_STORE_GET_NOTE_VERSION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNoteVersionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_note_version_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreGetNoteVersionResult *self = NOTE_STORE_GET_NOTE_VERSION_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_note_version_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  NoteStoreGetNoteVersionResult *self = NOTE_STORE_GET_NOTE_VERSION_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_note_version_result_instance_init (NoteStoreGetNoteVersionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_note_version_result_finalize (GObject *object)
{
  NoteStoreGetNoteVersionResult *tobject = NOTE_STORE_GET_NOTE_VERSION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_note_version_result_class_init (NoteStoreGetNoteVersionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_note_version_result_read;
  struct_class->write = note_store_get_note_version_result_write;

  gobject_class->finalize = note_store_get_note_version_result_finalize;
  gobject_class->get_property = note_store_get_note_version_result_get_property;
  gobject_class->set_property = note_store_get_note_version_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTE_VERSION_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_note_version_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNoteVersionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_note_version_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNoteVersionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_note_version_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNoteVersionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_ARGS_GUID,
  PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_DATA,
  PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_RECOGNITION,
  PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_ATTRIBUTES,
  PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_ALTERNATE_DATA
};

/* reads a note_store_get_resource_args object */
static gint32
note_store_get_resource_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceArgs * this_object = NOTE_STORE_GET_RESOURCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withRecognition, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withRecognition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withAttributes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withAttributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withAlternateData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withAlternateData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceArgs * this_object = NOTE_STORE_GET_RESOURCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withData", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withData, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withRecognition", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withRecognition, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withAttributes", T_BOOL, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withAttributes, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withAlternateData", T_BOOL, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withAlternateData, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreGetResourceArgs *self = NOTE_STORE_GET_RESOURCE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_DATA:
      self->withData = g_value_get_boolean (value);
      self->__isset_withData = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_RECOGNITION:
      self->withRecognition = g_value_get_boolean (value);
      self->__isset_withRecognition = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_ATTRIBUTES:
      self->withAttributes = g_value_get_boolean (value);
      self->__isset_withAttributes = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_ALTERNATE_DATA:
      self->withAlternateData = g_value_get_boolean (value);
      self->__isset_withAlternateData = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreGetResourceArgs *self = NOTE_STORE_GET_RESOURCE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_DATA:
      g_value_set_boolean (value, self->withData);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_RECOGNITION:
      g_value_set_boolean (value, self->withRecognition);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_ATTRIBUTES:
      g_value_set_boolean (value, self->withAttributes);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_ALTERNATE_DATA:
      g_value_set_boolean (value, self->withAlternateData);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_args_instance_init (NoteStoreGetResourceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->withData = 0;
  object->__isset_withData = FALSE;
  object->withRecognition = 0;
  object->__isset_withRecognition = FALSE;
  object->withAttributes = 0;
  object->__isset_withAttributes = FALSE;
  object->withAlternateData = 0;
  object->__isset_withAlternateData = FALSE;
}

static void 
note_store_get_resource_args_finalize (GObject *object)
{
  NoteStoreGetResourceArgs *tobject = NOTE_STORE_GET_RESOURCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_resource_args_class_init (NoteStoreGetResourceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_args_read;
  struct_class->write = note_store_get_resource_args_write;

  gobject_class->finalize = note_store_get_resource_args_finalize;
  gobject_class->get_property = note_store_get_resource_args_get_property;
  gobject_class->set_property = note_store_get_resource_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_DATA,
     g_param_spec_boolean ("withData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_RECOGNITION,
     g_param_spec_boolean ("withRecognition",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_ATTRIBUTES,
     g_param_spec_boolean ("withAttributes",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ARGS_WITH_ALTERNATE_DATA,
     g_param_spec_boolean ("withAlternateData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_store_get_resource_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_result object */
static gint32
note_store_get_resource_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceResult * this_object = NOTE_STORE_GET_RESOURCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceResult * this_object = NOTE_STORE_GET_RESOURCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreGetResourceResult *self = NOTE_STORE_GET_RESOURCE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreGetResourceResult *self = NOTE_STORE_GET_RESOURCE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_result_instance_init (NoteStoreGetResourceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_RESOURCE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_result_finalize (GObject *object)
{
  NoteStoreGetResourceResult *tobject = NOTE_STORE_GET_RESOURCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_result_class_init (NoteStoreGetResourceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_result_read;
  struct_class->write = note_store_get_resource_result_write;

  gobject_class->finalize = note_store_get_resource_result_finalize;
  gobject_class->get_property = note_store_get_resource_result_get_property;
  gobject_class->set_property = note_store_get_resource_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_RESOURCE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceApplicationDataArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_GUID
};

/* reads a note_store_get_resource_application_data_args object */
static gint32
note_store_get_resource_application_data_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceApplicationDataArgs * this_object = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_application_data_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceApplicationDataArgs * this_object = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceApplicationDataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_application_data_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  NoteStoreGetResourceApplicationDataArgs *self = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_application_data_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  NoteStoreGetResourceApplicationDataArgs *self = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_application_data_args_instance_init (NoteStoreGetResourceApplicationDataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_resource_application_data_args_finalize (GObject *object)
{
  NoteStoreGetResourceApplicationDataArgs *tobject = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_resource_application_data_args_class_init (NoteStoreGetResourceApplicationDataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_application_data_args_read;
  struct_class->write = note_store_get_resource_application_data_args_write;

  gobject_class->finalize = note_store_get_resource_application_data_args_finalize;
  gobject_class->get_property = note_store_get_resource_application_data_args_get_property;
  gobject_class->set_property = note_store_get_resource_application_data_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_resource_application_data_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceApplicationDataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_application_data_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceApplicationDataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_application_data_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceApplicationDataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceApplicationDataResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_application_data_result object */
static gint32
note_store_get_resource_application_data_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceApplicationDataResult * this_object = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_application_data_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceApplicationDataResult * this_object = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceApplicationDataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_application_data_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreGetResourceApplicationDataResult *self = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_application_data_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreGetResourceApplicationDataResult *self = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_application_data_result_instance_init (NoteStoreGetResourceApplicationDataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_LAZY_MAP, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_application_data_result_finalize (GObject *object)
{
  NoteStoreGetResourceApplicationDataResult *tobject = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_application_data_result_class_init (NoteStoreGetResourceApplicationDataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_application_data_result_read;
  struct_class->write = note_store_get_resource_application_data_result_write;

  gobject_class->finalize = note_store_get_resource_application_data_result_finalize;
  gobject_class->get_property = note_store_get_resource_application_data_result_get_property;
  gobject_class->set_property = note_store_get_resource_application_data_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_LAZY_MAP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_application_data_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceApplicationDataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_application_data_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceApplicationDataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_application_data_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceApplicationDataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceApplicationDataEntryArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY
};

/* reads a note_store_get_resource_application_data_entry_args object */
static gint32
note_store_get_resource_application_data_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceApplicationDataEntryArgs * this_object = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_application_data_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceApplicationDataEntryArgs * this_object = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceApplicationDataEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_application_data_entry_args_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  NoteStoreGetResourceApplicationDataEntryArgs *self = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_application_data_entry_args_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  NoteStoreGetResourceApplicationDataEntryArgs *self = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_application_data_entry_args_instance_init (NoteStoreGetResourceApplicationDataEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
note_store_get_resource_application_data_entry_args_finalize (GObject *object)
{
  NoteStoreGetResourceApplicationDataEntryArgs *tobject = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
note_store_get_resource_application_data_entry_args_class_init (NoteStoreGetResourceApplicationDataEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_application_data_entry_args_read;
  struct_class->write = note_store_get_resource_application_data_entry_args_write;

  gobject_class->finalize = note_store_get_resource_application_data_entry_args_finalize;
  gobject_class->get_property = note_store_get_resource_application_data_entry_args_get_property;
  gobject_class->set_property = note_store_get_resource_application_data_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_resource_application_data_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceApplicationDataEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_application_data_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceApplicationDataEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_application_data_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceApplicationDataEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceApplicationDataEntryResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_application_data_entry_result object */
static gint32
note_store_get_resource_application_data_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceApplicationDataEntryResult * this_object = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_application_data_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceApplicationDataEntryResult * this_object = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceApplicationDataEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_application_data_entry_result_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  NoteStoreGetResourceApplicationDataEntryResult *self = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_application_data_entry_result_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  NoteStoreGetResourceApplicationDataEntryResult *self = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_application_data_entry_result_instance_init (NoteStoreGetResourceApplicationDataEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_application_data_entry_result_finalize (GObject *object)
{
  NoteStoreGetResourceApplicationDataEntryResult *tobject = NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_application_data_entry_result_class_init (NoteStoreGetResourceApplicationDataEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_application_data_entry_result_read;
  struct_class->write = note_store_get_resource_application_data_entry_result_write;

  gobject_class->finalize = note_store_get_resource_application_data_entry_result_finalize;
  gobject_class->get_property = note_store_get_resource_application_data_entry_result_get_property;
  gobject_class->set_property = note_store_get_resource_application_data_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_application_data_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceApplicationDataEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_application_data_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceApplicationDataEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_application_data_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceApplicationDataEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreSetResourceApplicationDataEntryArgsProperties
{
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_0,
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID,
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY,
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_VALUE
};

/* reads a note_store_set_resource_application_data_entry_args object */
static gint32
note_store_set_resource_application_data_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreSetResourceApplicationDataEntryArgs * this_object = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_set_resource_application_data_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreSetResourceApplicationDataEntryArgs * this_object = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreSetResourceApplicationDataEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_set_resource_application_data_entry_args_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  NoteStoreSetResourceApplicationDataEntryArgs *self = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_set_resource_application_data_entry_args_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  NoteStoreSetResourceApplicationDataEntryArgs *self = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_VALUE:
      g_value_set_string (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_set_resource_application_data_entry_args_instance_init (NoteStoreSetResourceApplicationDataEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
note_store_set_resource_application_data_entry_args_finalize (GObject *object)
{
  NoteStoreSetResourceApplicationDataEntryArgs *tobject = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
note_store_set_resource_application_data_entry_args_class_init (NoteStoreSetResourceApplicationDataEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_set_resource_application_data_entry_args_read;
  struct_class->write = note_store_set_resource_application_data_entry_args_write;

  gobject_class->finalize = note_store_set_resource_application_data_entry_args_finalize;
  gobject_class->get_property = note_store_set_resource_application_data_entry_args_get_property;
  gobject_class->set_property = note_store_set_resource_application_data_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_set_resource_application_data_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreSetResourceApplicationDataEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_set_resource_application_data_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreSetResourceApplicationDataEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_set_resource_application_data_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreSetResourceApplicationDataEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreSetResourceApplicationDataEntryResultProperties
{
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_0,
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_set_resource_application_data_entry_result object */
static gint32
note_store_set_resource_application_data_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreSetResourceApplicationDataEntryResult * this_object = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_set_resource_application_data_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreSetResourceApplicationDataEntryResult * this_object = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreSetResourceApplicationDataEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_set_resource_application_data_entry_result_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  NoteStoreSetResourceApplicationDataEntryResult *self = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_set_resource_application_data_entry_result_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  NoteStoreSetResourceApplicationDataEntryResult *self = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_set_resource_application_data_entry_result_instance_init (NoteStoreSetResourceApplicationDataEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_set_resource_application_data_entry_result_finalize (GObject *object)
{
  NoteStoreSetResourceApplicationDataEntryResult *tobject = NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_set_resource_application_data_entry_result_class_init (NoteStoreSetResourceApplicationDataEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_set_resource_application_data_entry_result_read;
  struct_class->write = note_store_set_resource_application_data_entry_result_write;

  gobject_class->finalize = note_store_set_resource_application_data_entry_result_finalize;
  gobject_class->get_property = note_store_set_resource_application_data_entry_result_get_property;
  gobject_class->set_property = note_store_set_resource_application_data_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_set_resource_application_data_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreSetResourceApplicationDataEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_set_resource_application_data_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreSetResourceApplicationDataEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_set_resource_application_data_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreSetResourceApplicationDataEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUnsetResourceApplicationDataEntryArgsProperties
{
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_0,
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID,
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY
};

/* reads a note_store_unset_resource_application_data_entry_args object */
static gint32
note_store_unset_resource_application_data_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUnsetResourceApplicationDataEntryArgs * this_object = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_unset_resource_application_data_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUnsetResourceApplicationDataEntryArgs * this_object = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUnsetResourceApplicationDataEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_unset_resource_application_data_entry_args_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  NoteStoreUnsetResourceApplicationDataEntryArgs *self = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_unset_resource_application_data_entry_args_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  NoteStoreUnsetResourceApplicationDataEntryArgs *self = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_unset_resource_application_data_entry_args_instance_init (NoteStoreUnsetResourceApplicationDataEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
note_store_unset_resource_application_data_entry_args_finalize (GObject *object)
{
  NoteStoreUnsetResourceApplicationDataEntryArgs *tobject = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
note_store_unset_resource_application_data_entry_args_class_init (NoteStoreUnsetResourceApplicationDataEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_unset_resource_application_data_entry_args_read;
  struct_class->write = note_store_unset_resource_application_data_entry_args_write;

  gobject_class->finalize = note_store_unset_resource_application_data_entry_args_finalize;
  gobject_class->get_property = note_store_unset_resource_application_data_entry_args_get_property;
  gobject_class->set_property = note_store_unset_resource_application_data_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_unset_resource_application_data_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUnsetResourceApplicationDataEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_unset_resource_application_data_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUnsetResourceApplicationDataEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_unset_resource_application_data_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUnsetResourceApplicationDataEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUnsetResourceApplicationDataEntryResultProperties
{
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_0,
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_unset_resource_application_data_entry_result object */
static gint32
note_store_unset_resource_application_data_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUnsetResourceApplicationDataEntryResult * this_object = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_unset_resource_application_data_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUnsetResourceApplicationDataEntryResult * this_object = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUnsetResourceApplicationDataEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_unset_resource_application_data_entry_result_set_property (GObject *object,
                                                                      guint property_id,
                                                                      const GValue *value,
                                                                      GParamSpec *pspec)
{
  NoteStoreUnsetResourceApplicationDataEntryResult *self = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_unset_resource_application_data_entry_result_get_property (GObject *object,
                                                                      guint property_id,
                                                                      GValue *value,
                                                                      GParamSpec *pspec)
{
  NoteStoreUnsetResourceApplicationDataEntryResult *self = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_unset_resource_application_data_entry_result_instance_init (NoteStoreUnsetResourceApplicationDataEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_unset_resource_application_data_entry_result_finalize (GObject *object)
{
  NoteStoreUnsetResourceApplicationDataEntryResult *tobject = NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_unset_resource_application_data_entry_result_class_init (NoteStoreUnsetResourceApplicationDataEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_unset_resource_application_data_entry_result_read;
  struct_class->write = note_store_unset_resource_application_data_entry_result_write;

  gobject_class->finalize = note_store_unset_resource_application_data_entry_result_finalize;
  gobject_class->get_property = note_store_unset_resource_application_data_entry_result_get_property;
  gobject_class->set_property = note_store_unset_resource_application_data_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_unset_resource_application_data_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUnsetResourceApplicationDataEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_unset_resource_application_data_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUnsetResourceApplicationDataEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_unset_resource_application_data_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUnsetResourceApplicationDataEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateResourceArgsProperties
{
  PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_0,
  PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_RESOURCE
};

/* reads a note_store_update_resource_args object */
static gint32
note_store_update_resource_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateResourceArgs * this_object = NOTE_STORE_UPDATE_RESOURCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->resource), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_resource = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_resource_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateResourceArgs * this_object = NOTE_STORE_UPDATE_RESOURCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateResourceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "resource", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->resource), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_resource_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreUpdateResourceArgs *self = NOTE_STORE_UPDATE_RESOURCE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_RESOURCE:
      if (self->resource != NULL)
        g_object_unref (self->resource);
      self->resource = g_value_dup_object (value);
      self->__isset_resource = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_resource_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  NoteStoreUpdateResourceArgs *self = NOTE_STORE_UPDATE_RESOURCE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_RESOURCE:
      g_value_set_object (value, self->resource);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_resource_args_instance_init (NoteStoreUpdateResourceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->resource = g_object_new (TYPE_RESOURCE, NULL);
  object->__isset_resource = FALSE;
}

static void 
note_store_update_resource_args_finalize (GObject *object)
{
  NoteStoreUpdateResourceArgs *tobject = NOTE_STORE_UPDATE_RESOURCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->resource != NULL)
  {
    g_object_unref(tobject->resource);
    tobject->resource = NULL;
  }
}

static void
note_store_update_resource_args_class_init (NoteStoreUpdateResourceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_resource_args_read;
  struct_class->write = note_store_update_resource_args_write;

  gobject_class->finalize = note_store_update_resource_args_finalize;
  gobject_class->get_property = note_store_update_resource_args_get_property;
  gobject_class->set_property = note_store_update_resource_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_RESOURCE_ARGS_RESOURCE,
     g_param_spec_object ("resource",
                         NULL,
                         NULL,
                         TYPE_RESOURCE,
                         G_PARAM_READWRITE));
}

GType
note_store_update_resource_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateResourceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_resource_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateResourceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_resource_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateResourceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateResourceResultProperties
{
  PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_0,
  PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_SUCCESS,
  PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_update_resource_result object */
static gint32
note_store_update_resource_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateResourceResult * this_object = NOTE_STORE_UPDATE_RESOURCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_resource_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateResourceResult * this_object = NOTE_STORE_UPDATE_RESOURCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateResourceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_resource_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreUpdateResourceResult *self = NOTE_STORE_UPDATE_RESOURCE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_resource_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreUpdateResourceResult *self = NOTE_STORE_UPDATE_RESOURCE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_resource_result_instance_init (NoteStoreUpdateResourceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_update_resource_result_finalize (GObject *object)
{
  NoteStoreUpdateResourceResult *tobject = NOTE_STORE_UPDATE_RESOURCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_update_resource_result_class_init (NoteStoreUpdateResourceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_resource_result_read;
  struct_class->write = note_store_update_resource_result_write;

  gobject_class->finalize = note_store_update_resource_result_finalize;
  gobject_class->get_property = note_store_update_resource_result_get_property;
  gobject_class->set_property = note_store_update_resource_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_RESOURCE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_update_resource_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateResourceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_resource_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateResourceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_resource_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateResourceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceDataArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_GUID
};

/* reads a note_store_get_resource_data_args object */
static gint32
note_store_get_resource_data_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceDataArgs * this_object = NOTE_STORE_GET_RESOURCE_DATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_data_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceDataArgs * this_object = NOTE_STORE_GET_RESOURCE_DATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceDataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_data_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreGetResourceDataArgs *self = NOTE_STORE_GET_RESOURCE_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_data_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreGetResourceDataArgs *self = NOTE_STORE_GET_RESOURCE_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_data_args_instance_init (NoteStoreGetResourceDataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_resource_data_args_finalize (GObject *object)
{
  NoteStoreGetResourceDataArgs *tobject = NOTE_STORE_GET_RESOURCE_DATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_resource_data_args_class_init (NoteStoreGetResourceDataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_data_args_read;
  struct_class->write = note_store_get_resource_data_args_write;

  gobject_class->finalize = note_store_get_resource_data_args_finalize;
  gobject_class->get_property = note_store_get_resource_data_args_get_property;
  gobject_class->set_property = note_store_get_resource_data_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_DATA_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_resource_data_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceDataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_data_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceDataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_data_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceDataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceDataResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_data_result object */
static gint32
note_store_get_resource_data_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceDataResult * this_object = NOTE_STORE_GET_RESOURCE_DATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_data_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceDataResult * this_object = NOTE_STORE_GET_RESOURCE_DATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceDataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_data_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreGetResourceDataResult *self = NOTE_STORE_GET_RESOURCE_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_data_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreGetResourceDataResult *self = NOTE_STORE_GET_RESOURCE_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_data_result_instance_init (NoteStoreGetResourceDataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_data_result_finalize (GObject *object)
{
  NoteStoreGetResourceDataResult *tobject = NOTE_STORE_GET_RESOURCE_DATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_data_result_class_init (NoteStoreGetResourceDataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_data_result_read;
  struct_class->write = note_store_get_resource_data_result_write;

  gobject_class->finalize = note_store_get_resource_data_result_finalize;
  gobject_class->get_property = note_store_get_resource_data_result_get_property;
  gobject_class->set_property = note_store_get_resource_data_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_DATA_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_data_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceDataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_data_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceDataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_data_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceDataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceByHashArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_NOTE_GUID,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_CONTENT_HASH,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_DATA,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_RECOGNITION,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_ALTERNATE_DATA
};

/* reads a note_store_get_resource_by_hash_args object */
static gint32
note_store_get_resource_by_hash_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceByHashArgs * this_object = NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->noteGuid != NULL)
          {
            g_free(this_object->noteGuid);
            this_object->noteGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->contentHash != NULL)
          {
            g_free(this_object->contentHash);
            this_object->contentHash = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->contentHash = g_byte_array_new();
          g_byte_array_append (this_object->contentHash, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_contentHash = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withRecognition, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withRecognition = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->withAlternateData, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_withAlternateData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_by_hash_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceByHashArgs * this_object = NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceByHashArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->noteGuid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "contentHash", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->contentHash ? ((GByteArray *) this_object->contentHash)->data : NULL, this_object->contentHash ? ((GByteArray *) this_object->contentHash)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withData", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withData, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withRecognition", T_BOOL, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withRecognition, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "withAlternateData", T_BOOL, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->withAlternateData, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_by_hash_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreGetResourceByHashArgs *self = NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_NOTE_GUID:
      if (self->noteGuid != NULL)
        g_free (self->noteGuid);
      self->noteGuid = g_value_dup_string (value);
      self->__isset_noteGuid = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_CONTENT_HASH:
      if (self->contentHash != NULL)
        g_byte_array_unref (self->contentHash);
      self->contentHash = g_value_dup_boxed (value);
      self->__isset_contentHash = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_DATA:
      self->withData = g_value_get_boolean (value);
      self->__isset_withData = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_RECOGNITION:
      self->withRecognition = g_value_get_boolean (value);
      self->__isset_withRecognition = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_ALTERNATE_DATA:
      self->withAlternateData = g_value_get_boolean (value);
      self->__isset_withAlternateData = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_by_hash_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  NoteStoreGetResourceByHashArgs *self = NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_NOTE_GUID:
      g_value_set_string (value, self->noteGuid);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_CONTENT_HASH:
      g_value_set_boxed (value, self->contentHash);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_DATA:
      g_value_set_boolean (value, self->withData);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_RECOGNITION:
      g_value_set_boolean (value, self->withRecognition);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_ALTERNATE_DATA:
      g_value_set_boolean (value, self->withAlternateData);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_by_hash_args_instance_init (NoteStoreGetResourceByHashArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->noteGuid = NULL;
  object->__isset_noteGuid = FALSE;
  object->contentHash = NULL;
  object->__isset_contentHash = FALSE;
  object->withData = 0;
  object->__isset_withData = FALSE;
  object->withRecognition = 0;
  object->__isset_withRecognition = FALSE;
  object->withAlternateData = 0;
  object->__isset_withAlternateData = FALSE;
}

static void 
note_store_get_resource_by_hash_args_finalize (GObject *object)
{
  NoteStoreGetResourceByHashArgs *tobject = NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->noteGuid != NULL)
  {
    g_free(tobject->noteGuid);
    tobject->noteGuid = NULL;
  }
  if (tobject->contentHash != NULL)
  {
    thrift_string_free(tobject->contentHash);
    tobject->contentHash = NULL;
  }
}

static void
note_store_get_resource_by_hash_args_class_init (NoteStoreGetResourceByHashArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_by_hash_args_read;
  struct_class->write = note_store_get_resource_by_hash_args_write;

  gobject_class->finalize = note_store_get_resource_by_hash_args_finalize;
  gobject_class->get_property = note_store_get_resource_by_hash_args_get_property;
  gobject_class->set_property = note_store_get_resource_by_hash_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_NOTE_GUID,
     g_param_spec_string ("noteGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_CONTENT_HASH,
     g_param_spec_boxed ("contentHash",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_DATA,
     g_param_spec_boolean ("withData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_RECOGNITION,
     g_param_spec_boolean ("withRecognition",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS_WITH_ALTERNATE_DATA,
     g_param_spec_boolean ("withAlternateData",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
note_store_get_resource_by_hash_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceByHashArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_by_hash_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceByHashArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_by_hash_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceByHashArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceByHashResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_by_hash_result object */
static gint32
note_store_get_resource_by_hash_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceByHashResult * this_object = NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_by_hash_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceByHashResult * this_object = NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceByHashResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_by_hash_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreGetResourceByHashResult *self = NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_by_hash_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreGetResourceByHashResult *self = NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_by_hash_result_instance_init (NoteStoreGetResourceByHashResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_RESOURCE, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_by_hash_result_finalize (GObject *object)
{
  NoteStoreGetResourceByHashResult *tobject = NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_by_hash_result_class_init (NoteStoreGetResourceByHashResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_by_hash_result_read;
  struct_class->write = note_store_get_resource_by_hash_result_write;

  gobject_class->finalize = note_store_get_resource_by_hash_result_finalize;
  gobject_class->get_property = note_store_get_resource_by_hash_result_get_property;
  gobject_class->set_property = note_store_get_resource_by_hash_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_RESOURCE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_by_hash_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceByHashResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_by_hash_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceByHashResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_by_hash_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceByHashResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceRecognitionArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_GUID
};

/* reads a note_store_get_resource_recognition_args object */
static gint32
note_store_get_resource_recognition_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceRecognitionArgs * this_object = NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_recognition_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceRecognitionArgs * this_object = NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceRecognitionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_recognition_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreGetResourceRecognitionArgs *self = NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_recognition_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreGetResourceRecognitionArgs *self = NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_recognition_args_instance_init (NoteStoreGetResourceRecognitionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_resource_recognition_args_finalize (GObject *object)
{
  NoteStoreGetResourceRecognitionArgs *tobject = NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_resource_recognition_args_class_init (NoteStoreGetResourceRecognitionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_recognition_args_read;
  struct_class->write = note_store_get_resource_recognition_args_write;

  gobject_class->finalize = note_store_get_resource_recognition_args_finalize;
  gobject_class->get_property = note_store_get_resource_recognition_args_get_property;
  gobject_class->set_property = note_store_get_resource_recognition_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_resource_recognition_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceRecognitionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_recognition_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceRecognitionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_recognition_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceRecognitionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceRecognitionResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_recognition_result object */
static gint32
note_store_get_resource_recognition_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceRecognitionResult * this_object = NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_recognition_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceRecognitionResult * this_object = NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceRecognitionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_recognition_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  NoteStoreGetResourceRecognitionResult *self = NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_recognition_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  NoteStoreGetResourceRecognitionResult *self = NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_recognition_result_instance_init (NoteStoreGetResourceRecognitionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_recognition_result_finalize (GObject *object)
{
  NoteStoreGetResourceRecognitionResult *tobject = NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_recognition_result_class_init (NoteStoreGetResourceRecognitionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_recognition_result_read;
  struct_class->write = note_store_get_resource_recognition_result_write;

  gobject_class->finalize = note_store_get_resource_recognition_result_finalize;
  gobject_class->get_property = note_store_get_resource_recognition_result_get_property;
  gobject_class->set_property = note_store_get_resource_recognition_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_recognition_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceRecognitionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_recognition_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceRecognitionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_recognition_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceRecognitionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceAlternateDataArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_GUID
};

/* reads a note_store_get_resource_alternate_data_args object */
static gint32
note_store_get_resource_alternate_data_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceAlternateDataArgs * this_object = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_alternate_data_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceAlternateDataArgs * this_object = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceAlternateDataArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_alternate_data_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreGetResourceAlternateDataArgs *self = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_alternate_data_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreGetResourceAlternateDataArgs *self = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_alternate_data_args_instance_init (NoteStoreGetResourceAlternateDataArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_resource_alternate_data_args_finalize (GObject *object)
{
  NoteStoreGetResourceAlternateDataArgs *tobject = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_resource_alternate_data_args_class_init (NoteStoreGetResourceAlternateDataArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_alternate_data_args_read;
  struct_class->write = note_store_get_resource_alternate_data_args_write;

  gobject_class->finalize = note_store_get_resource_alternate_data_args_finalize;
  gobject_class->get_property = note_store_get_resource_alternate_data_args_get_property;
  gobject_class->set_property = note_store_get_resource_alternate_data_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_resource_alternate_data_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceAlternateDataArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_alternate_data_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceAlternateDataArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_alternate_data_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceAlternateDataArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceAlternateDataResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_alternate_data_result object */
static gint32
note_store_get_resource_alternate_data_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceAlternateDataResult * this_object = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_alternate_data_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceAlternateDataResult * this_object = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceAlternateDataResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_alternate_data_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  NoteStoreGetResourceAlternateDataResult *self = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_alternate_data_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  NoteStoreGetResourceAlternateDataResult *self = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_alternate_data_result_instance_init (NoteStoreGetResourceAlternateDataResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_alternate_data_result_finalize (GObject *object)
{
  NoteStoreGetResourceAlternateDataResult *tobject = NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_alternate_data_result_class_init (NoteStoreGetResourceAlternateDataResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_alternate_data_result_read;
  struct_class->write = note_store_get_resource_alternate_data_result_write;

  gobject_class->finalize = note_store_get_resource_alternate_data_result_finalize;
  gobject_class->get_property = note_store_get_resource_alternate_data_result_get_property;
  gobject_class->set_property = note_store_get_resource_alternate_data_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_alternate_data_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceAlternateDataResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_alternate_data_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceAlternateDataResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_alternate_data_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceAlternateDataResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceAttributesArgsProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_0,
  PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_GUID
};

/* reads a note_store_get_resource_attributes_args object */
static gint32
note_store_get_resource_attributes_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceAttributesArgs * this_object = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_attributes_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceAttributesArgs * this_object = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceAttributesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_attributes_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreGetResourceAttributesArgs *self = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_attributes_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreGetResourceAttributesArgs *self = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_attributes_args_instance_init (NoteStoreGetResourceAttributesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_get_resource_attributes_args_finalize (GObject *object)
{
  NoteStoreGetResourceAttributesArgs *tobject = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_get_resource_attributes_args_class_init (NoteStoreGetResourceAttributesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_attributes_args_read;
  struct_class->write = note_store_get_resource_attributes_args_write;

  gobject_class->finalize = note_store_get_resource_attributes_args_finalize;
  gobject_class->get_property = note_store_get_resource_attributes_args_get_property;
  gobject_class->set_property = note_store_get_resource_attributes_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_resource_attributes_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceAttributesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_attributes_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceAttributesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_attributes_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceAttributesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetResourceAttributesResultProperties
{
  PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_0,
  PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_resource_attributes_result object */
static gint32
note_store_get_resource_attributes_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetResourceAttributesResult * this_object = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_resource_attributes_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetResourceAttributesResult * this_object = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetResourceAttributesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_resource_attributes_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreGetResourceAttributesResult *self = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_resource_attributes_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreGetResourceAttributesResult *self = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_resource_attributes_result_instance_init (NoteStoreGetResourceAttributesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_RESOURCE_ATTRIBUTES, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_resource_attributes_result_finalize (GObject *object)
{
  NoteStoreGetResourceAttributesResult *tobject = NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_resource_attributes_result_class_init (NoteStoreGetResourceAttributesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_resource_attributes_result_read;
  struct_class->write = note_store_get_resource_attributes_result_write;

  gobject_class->finalize = note_store_get_resource_attributes_result_finalize;
  gobject_class->get_property = note_store_get_resource_attributes_result_get_property;
  gobject_class->set_property = note_store_get_resource_attributes_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_RESOURCE_ATTRIBUTES,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_resource_attributes_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetResourceAttributesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_resource_attributes_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetResourceAttributesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_resource_attributes_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetResourceAttributesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetPublicNotebookArgsProperties
{
  PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_USER_ID,
  PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_PUBLIC_URI
};

/* reads a note_store_get_public_notebook_args object */
static gint32
note_store_get_public_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetPublicNotebookArgs * this_object = NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->userId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_userId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->publicUri != NULL)
          {
            g_free(this_object->publicUri);
            this_object->publicUri = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->publicUri, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_publicUri = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_public_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetPublicNotebookArgs * this_object = NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetPublicNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "userId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->userId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "publicUri", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->publicUri, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_public_notebook_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreGetPublicNotebookArgs *self = NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_USER_ID:
      self->userId = g_value_get_int (value);
      self->__isset_userId = TRUE;
      break;

    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_PUBLIC_URI:
      if (self->publicUri != NULL)
        g_free (self->publicUri);
      self->publicUri = g_value_dup_string (value);
      self->__isset_publicUri = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_public_notebook_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreGetPublicNotebookArgs *self = NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_USER_ID:
      g_value_set_int (value, self->userId);
      break;

    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_PUBLIC_URI:
      g_value_set_string (value, self->publicUri);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_public_notebook_args_instance_init (NoteStoreGetPublicNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userId = 0;
  object->__isset_userId = FALSE;
  object->publicUri = NULL;
  object->__isset_publicUri = FALSE;
}

static void 
note_store_get_public_notebook_args_finalize (GObject *object)
{
  NoteStoreGetPublicNotebookArgs *tobject = NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->publicUri != NULL)
  {
    g_free(tobject->publicUri);
    tobject->publicUri = NULL;
  }
}

static void
note_store_get_public_notebook_args_class_init (NoteStoreGetPublicNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_public_notebook_args_read;
  struct_class->write = note_store_get_public_notebook_args_write;

  gobject_class->finalize = note_store_get_public_notebook_args_finalize;
  gobject_class->get_property = note_store_get_public_notebook_args_get_property;
  gobject_class->set_property = note_store_get_public_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_USER_ID,
     g_param_spec_int ("userId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS_PUBLIC_URI,
     g_param_spec_string ("publicUri",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_public_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetPublicNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_public_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetPublicNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_public_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetPublicNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetPublicNotebookResultProperties
{
  PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_get_public_notebook_result object */
static gint32
note_store_get_public_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetPublicNotebookResult * this_object = NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_public_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetPublicNotebookResult * this_object = NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetPublicNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_public_notebook_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreGetPublicNotebookResult *self = NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_public_notebook_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreGetPublicNotebookResult *self = NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_public_notebook_result_instance_init (NoteStoreGetPublicNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTEBOOK, NULL);
  object->__isset_success = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_get_public_notebook_result_finalize (GObject *object)
{
  NoteStoreGetPublicNotebookResult *tobject = NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_get_public_notebook_result_class_init (NoteStoreGetPublicNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_public_notebook_result_read;
  struct_class->write = note_store_get_public_notebook_result_write;

  gobject_class->finalize = note_store_get_public_notebook_result_finalize;
  gobject_class->get_property = note_store_get_public_notebook_result_get_property;
  gobject_class->set_property = note_store_get_public_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_public_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetPublicNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_public_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetPublicNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_public_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetPublicNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreShareNotebookArgsProperties
{
  PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_SHARED_NOTEBOOK,
  PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_MESSAGE
};

/* reads a note_store_share_notebook_args object */
static gint32
note_store_share_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreShareNotebookArgs * this_object = NOTE_STORE_SHARE_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->sharedNotebook), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_sharedNotebook = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_share_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreShareNotebookArgs * this_object = NOTE_STORE_SHARE_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreShareNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sharedNotebook", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->sharedNotebook), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_share_notebook_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreShareNotebookArgs *self = NOTE_STORE_SHARE_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_SHARED_NOTEBOOK:
      if (self->sharedNotebook != NULL)
        g_object_unref (self->sharedNotebook);
      self->sharedNotebook = g_value_dup_object (value);
      self->__isset_sharedNotebook = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_share_notebook_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreShareNotebookArgs *self = NOTE_STORE_SHARE_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_SHARED_NOTEBOOK:
      g_value_set_object (value, self->sharedNotebook);
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_share_notebook_args_instance_init (NoteStoreShareNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->sharedNotebook = g_object_new (TYPE_SHARED_NOTEBOOK, NULL);
  object->__isset_sharedNotebook = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
note_store_share_notebook_args_finalize (GObject *object)
{
  NoteStoreShareNotebookArgs *tobject = NOTE_STORE_SHARE_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->sharedNotebook != NULL)
  {
    g_object_unref(tobject->sharedNotebook);
    tobject->sharedNotebook = NULL;
  }
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
note_store_share_notebook_args_class_init (NoteStoreShareNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_share_notebook_args_read;
  struct_class->write = note_store_share_notebook_args_write;

  gobject_class->finalize = note_store_share_notebook_args_finalize;
  gobject_class->get_property = note_store_share_notebook_args_get_property;
  gobject_class->set_property = note_store_share_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_SHARED_NOTEBOOK,
     g_param_spec_object ("sharedNotebook",
                         NULL,
                         NULL,
                         TYPE_SHARED_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTEBOOK_ARGS_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_share_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreShareNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_share_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreShareNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_share_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreShareNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreShareNotebookResultProperties
{
  PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_share_notebook_result object */
static gint32
note_store_share_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreShareNotebookResult * this_object = NOTE_STORE_SHARE_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_share_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreShareNotebookResult * this_object = NOTE_STORE_SHARE_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreShareNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_share_notebook_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreShareNotebookResult *self = NOTE_STORE_SHARE_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_share_notebook_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  NoteStoreShareNotebookResult *self = NOTE_STORE_SHARE_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_share_notebook_result_instance_init (NoteStoreShareNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SHARED_NOTEBOOK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_share_notebook_result_finalize (GObject *object)
{
  NoteStoreShareNotebookResult *tobject = NOTE_STORE_SHARE_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_share_notebook_result_class_init (NoteStoreShareNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_share_notebook_result_read;
  struct_class->write = note_store_share_notebook_result_write;

  gobject_class->finalize = note_store_share_notebook_result_finalize;
  gobject_class->get_property = note_store_share_notebook_result_get_property;
  gobject_class->set_property = note_store_share_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SHARED_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_share_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreShareNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_share_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreShareNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_share_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreShareNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateOrUpdateNotebookSharesArgsProperties
{
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_0,
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_SHARE_TEMPLATE
};

/* reads a note_store_create_or_update_notebook_shares_args object */
static gint32
note_store_create_or_update_notebook_shares_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateOrUpdateNotebookSharesArgs * this_object = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->shareTemplate), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_shareTemplate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_or_update_notebook_shares_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateOrUpdateNotebookSharesArgs * this_object = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateOrUpdateNotebookSharesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "shareTemplate", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->shareTemplate), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_or_update_notebook_shares_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  NoteStoreCreateOrUpdateNotebookSharesArgs *self = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_SHARE_TEMPLATE:
      if (self->shareTemplate != NULL)
        g_object_unref (self->shareTemplate);
      self->shareTemplate = g_value_dup_object (value);
      self->__isset_shareTemplate = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_or_update_notebook_shares_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  NoteStoreCreateOrUpdateNotebookSharesArgs *self = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_SHARE_TEMPLATE:
      g_value_set_object (value, self->shareTemplate);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_or_update_notebook_shares_args_instance_init (NoteStoreCreateOrUpdateNotebookSharesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->shareTemplate = g_object_new (TYPE_NOTEBOOK_SHARE_TEMPLATE, NULL);
  object->__isset_shareTemplate = FALSE;
}

static void 
note_store_create_or_update_notebook_shares_args_finalize (GObject *object)
{
  NoteStoreCreateOrUpdateNotebookSharesArgs *tobject = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->shareTemplate != NULL)
  {
    g_object_unref(tobject->shareTemplate);
    tobject->shareTemplate = NULL;
  }
}

static void
note_store_create_or_update_notebook_shares_args_class_init (NoteStoreCreateOrUpdateNotebookSharesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_or_update_notebook_shares_args_read;
  struct_class->write = note_store_create_or_update_notebook_shares_args_write;

  gobject_class->finalize = note_store_create_or_update_notebook_shares_args_finalize;
  gobject_class->get_property = note_store_create_or_update_notebook_shares_args_get_property;
  gobject_class->set_property = note_store_create_or_update_notebook_shares_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS_SHARE_TEMPLATE,
     g_param_spec_object ("shareTemplate",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK_SHARE_TEMPLATE,
                         G_PARAM_READWRITE));
}

GType
note_store_create_or_update_notebook_shares_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateOrUpdateNotebookSharesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_or_update_notebook_shares_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateOrUpdateNotebookSharesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_or_update_notebook_shares_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateOrUpdateNotebookSharesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateOrUpdateNotebookSharesResultProperties
{
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_0,
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_SUCCESS,
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_INVALID_CONTACTS_EXCEPTION
};

/* reads a note_store_create_or_update_notebook_shares_result object */
static gint32
note_store_create_or_update_notebook_shares_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateOrUpdateNotebookSharesResult * this_object = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->invalidContactsException != NULL)
          {
            g_object_unref (this_object->invalidContactsException);
          }
          this_object->invalidContactsException = g_object_new (TYPE_E_D_A_M_INVALID_CONTACTS_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->invalidContactsException), protocol, error)) < 0)
          {
            g_object_unref (this_object->invalidContactsException);
            this_object->invalidContactsException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_invalidContactsException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_or_update_notebook_shares_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateOrUpdateNotebookSharesResult * this_object = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateOrUpdateNotebookSharesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_invalidContactsException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "invalidContactsException", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->invalidContactsException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_or_update_notebook_shares_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  NoteStoreCreateOrUpdateNotebookSharesResult *self = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_INVALID_CONTACTS_EXCEPTION:
      if (self->invalidContactsException != NULL)
        g_object_unref (self->invalidContactsException);
      self->invalidContactsException = g_value_dup_object (value);
      self->__isset_invalidContactsException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_or_update_notebook_shares_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  NoteStoreCreateOrUpdateNotebookSharesResult *self = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_INVALID_CONTACTS_EXCEPTION:
      g_value_set_object (value, self->invalidContactsException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_or_update_notebook_shares_result_instance_init (NoteStoreCreateOrUpdateNotebookSharesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->invalidContactsException = NULL;
  object->__isset_invalidContactsException = FALSE;
}

static void 
note_store_create_or_update_notebook_shares_result_finalize (GObject *object)
{
  NoteStoreCreateOrUpdateNotebookSharesResult *tobject = NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->invalidContactsException != NULL)
  {
    g_object_unref(tobject->invalidContactsException);
    tobject->invalidContactsException = NULL;
  }
}

static void
note_store_create_or_update_notebook_shares_result_class_init (NoteStoreCreateOrUpdateNotebookSharesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_or_update_notebook_shares_result_read;
  struct_class->write = note_store_create_or_update_notebook_shares_result_write;

  gobject_class->finalize = note_store_create_or_update_notebook_shares_result_finalize;
  gobject_class->get_property = note_store_create_or_update_notebook_shares_result_get_property;
  gobject_class->set_property = note_store_create_or_update_notebook_shares_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT_INVALID_CONTACTS_EXCEPTION,
     g_param_spec_object ("invalidContactsException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_INVALID_CONTACTS_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_create_or_update_notebook_shares_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateOrUpdateNotebookSharesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_or_update_notebook_shares_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateOrUpdateNotebookSharesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_or_update_notebook_shares_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateOrUpdateNotebookSharesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateSharedNotebookArgsProperties
{
  PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_SHARED_NOTEBOOK
};

/* reads a note_store_update_shared_notebook_args object */
static gint32
note_store_update_shared_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateSharedNotebookArgs * this_object = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->sharedNotebook), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_sharedNotebook = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_shared_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateSharedNotebookArgs * this_object = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateSharedNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sharedNotebook", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->sharedNotebook), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_shared_notebook_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreUpdateSharedNotebookArgs *self = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_SHARED_NOTEBOOK:
      if (self->sharedNotebook != NULL)
        g_object_unref (self->sharedNotebook);
      self->sharedNotebook = g_value_dup_object (value);
      self->__isset_sharedNotebook = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_shared_notebook_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreUpdateSharedNotebookArgs *self = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_SHARED_NOTEBOOK:
      g_value_set_object (value, self->sharedNotebook);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_shared_notebook_args_instance_init (NoteStoreUpdateSharedNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->sharedNotebook = g_object_new (TYPE_SHARED_NOTEBOOK, NULL);
  object->__isset_sharedNotebook = FALSE;
}

static void 
note_store_update_shared_notebook_args_finalize (GObject *object)
{
  NoteStoreUpdateSharedNotebookArgs *tobject = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->sharedNotebook != NULL)
  {
    g_object_unref(tobject->sharedNotebook);
    tobject->sharedNotebook = NULL;
  }
}

static void
note_store_update_shared_notebook_args_class_init (NoteStoreUpdateSharedNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_shared_notebook_args_read;
  struct_class->write = note_store_update_shared_notebook_args_write;

  gobject_class->finalize = note_store_update_shared_notebook_args_finalize;
  gobject_class->get_property = note_store_update_shared_notebook_args_get_property;
  gobject_class->set_property = note_store_update_shared_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS_SHARED_NOTEBOOK,
     g_param_spec_object ("sharedNotebook",
                         NULL,
                         NULL,
                         TYPE_SHARED_NOTEBOOK,
                         G_PARAM_READWRITE));
}

GType
note_store_update_shared_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateSharedNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_shared_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateSharedNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_shared_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateSharedNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateSharedNotebookResultProperties
{
  PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_update_shared_notebook_result object */
static gint32
note_store_update_shared_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateSharedNotebookResult * this_object = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_shared_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateSharedNotebookResult * this_object = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateSharedNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_shared_notebook_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreUpdateSharedNotebookResult *self = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_shared_notebook_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreUpdateSharedNotebookResult *self = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_shared_notebook_result_instance_init (NoteStoreUpdateSharedNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_update_shared_notebook_result_finalize (GObject *object)
{
  NoteStoreUpdateSharedNotebookResult *tobject = NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_update_shared_notebook_result_class_init (NoteStoreUpdateSharedNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_shared_notebook_result_read;
  struct_class->write = note_store_update_shared_notebook_result_write;

  gobject_class->finalize = note_store_update_shared_notebook_result_finalize;
  gobject_class->get_property = note_store_update_shared_notebook_result_get_property;
  gobject_class->set_property = note_store_update_shared_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_update_shared_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateSharedNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_shared_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateSharedNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_shared_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateSharedNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreSetNotebookRecipientSettingsArgsProperties
{
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_0,
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_NOTEBOOK_GUID,
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_RECIPIENT_SETTINGS
};

/* reads a note_store_set_notebook_recipient_settings_args object */
static gint32
note_store_set_notebook_recipient_settings_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreSetNotebookRecipientSettingsArgs * this_object = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->notebookGuid != NULL)
          {
            g_free(this_object->notebookGuid);
            this_object->notebookGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->notebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_notebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->recipientSettings), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_recipientSettings = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_set_notebook_recipient_settings_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreSetNotebookRecipientSettingsArgs * this_object = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreSetNotebookRecipientSettingsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->notebookGuid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "recipientSettings", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->recipientSettings), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_set_notebook_recipient_settings_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreSetNotebookRecipientSettingsArgs *self = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_NOTEBOOK_GUID:
      if (self->notebookGuid != NULL)
        g_free (self->notebookGuid);
      self->notebookGuid = g_value_dup_string (value);
      self->__isset_notebookGuid = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_RECIPIENT_SETTINGS:
      if (self->recipientSettings != NULL)
        g_object_unref (self->recipientSettings);
      self->recipientSettings = g_value_dup_object (value);
      self->__isset_recipientSettings = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_set_notebook_recipient_settings_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreSetNotebookRecipientSettingsArgs *self = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_NOTEBOOK_GUID:
      g_value_set_string (value, self->notebookGuid);
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_RECIPIENT_SETTINGS:
      g_value_set_object (value, self->recipientSettings);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_set_notebook_recipient_settings_args_instance_init (NoteStoreSetNotebookRecipientSettingsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->notebookGuid = NULL;
  object->__isset_notebookGuid = FALSE;
  object->recipientSettings = g_object_new (TYPE_NOTEBOOK_RECIPIENT_SETTINGS, NULL);
  object->__isset_recipientSettings = FALSE;
}

static void 
note_store_set_notebook_recipient_settings_args_finalize (GObject *object)
{
  NoteStoreSetNotebookRecipientSettingsArgs *tobject = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->notebookGuid != NULL)
  {
    g_free(tobject->notebookGuid);
    tobject->notebookGuid = NULL;
  }
  if (tobject->recipientSettings != NULL)
  {
    g_object_unref(tobject->recipientSettings);
    tobject->recipientSettings = NULL;
  }
}

static void
note_store_set_notebook_recipient_settings_args_class_init (NoteStoreSetNotebookRecipientSettingsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_set_notebook_recipient_settings_args_read;
  struct_class->write = note_store_set_notebook_recipient_settings_args_write;

  gobject_class->finalize = note_store_set_notebook_recipient_settings_args_finalize;
  gobject_class->get_property = note_store_set_notebook_recipient_settings_args_get_property;
  gobject_class->set_property = note_store_set_notebook_recipient_settings_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_NOTEBOOK_GUID,
     g_param_spec_string ("notebookGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS_RECIPIENT_SETTINGS,
     g_param_spec_object ("recipientSettings",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK_RECIPIENT_SETTINGS,
                         G_PARAM_READWRITE));
}

GType
note_store_set_notebook_recipient_settings_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreSetNotebookRecipientSettingsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_set_notebook_recipient_settings_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreSetNotebookRecipientSettingsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_set_notebook_recipient_settings_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreSetNotebookRecipientSettingsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreSetNotebookRecipientSettingsResultProperties
{
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_0,
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_SUCCESS,
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_set_notebook_recipient_settings_result object */
static gint32
note_store_set_notebook_recipient_settings_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreSetNotebookRecipientSettingsResult * this_object = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_set_notebook_recipient_settings_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreSetNotebookRecipientSettingsResult * this_object = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreSetNotebookRecipientSettingsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_set_notebook_recipient_settings_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreSetNotebookRecipientSettingsResult *self = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_set_notebook_recipient_settings_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreSetNotebookRecipientSettingsResult *self = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_set_notebook_recipient_settings_result_instance_init (NoteStoreSetNotebookRecipientSettingsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_NOTEBOOK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_set_notebook_recipient_settings_result_finalize (GObject *object)
{
  NoteStoreSetNotebookRecipientSettingsResult *tobject = NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_set_notebook_recipient_settings_result_class_init (NoteStoreSetNotebookRecipientSettingsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_set_notebook_recipient_settings_result_read;
  struct_class->write = note_store_set_notebook_recipient_settings_result_write;

  gobject_class->finalize = note_store_set_notebook_recipient_settings_result_finalize;
  gobject_class->get_property = note_store_set_notebook_recipient_settings_result_get_property;
  gobject_class->set_property = note_store_set_notebook_recipient_settings_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_set_notebook_recipient_settings_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreSetNotebookRecipientSettingsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_set_notebook_recipient_settings_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreSetNotebookRecipientSettingsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_set_notebook_recipient_settings_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreSetNotebookRecipientSettingsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListSharedNotebooksArgsProperties
{
  PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS_0,
  PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_list_shared_notebooks_args object */
static gint32
note_store_list_shared_notebooks_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListSharedNotebooksArgs * this_object = NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_shared_notebooks_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListSharedNotebooksArgs * this_object = NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListSharedNotebooksArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_shared_notebooks_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreListSharedNotebooksArgs *self = NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_shared_notebooks_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreListSharedNotebooksArgs *self = NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_shared_notebooks_args_instance_init (NoteStoreListSharedNotebooksArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_list_shared_notebooks_args_finalize (GObject *object)
{
  NoteStoreListSharedNotebooksArgs *tobject = NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_list_shared_notebooks_args_class_init (NoteStoreListSharedNotebooksArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_shared_notebooks_args_read;
  struct_class->write = note_store_list_shared_notebooks_args_write;

  gobject_class->finalize = note_store_list_shared_notebooks_args_finalize;
  gobject_class->get_property = note_store_list_shared_notebooks_args_get_property;
  gobject_class->set_property = note_store_list_shared_notebooks_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_list_shared_notebooks_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListSharedNotebooksArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_shared_notebooks_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListSharedNotebooksArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_shared_notebooks_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListSharedNotebooksArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListSharedNotebooksResultProperties
{
  PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_0,
  PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_SUCCESS,
  PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_list_shared_notebooks_result object */
static gint32
note_store_list_shared_notebooks_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListSharedNotebooksResult * this_object = NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              SharedNotebook * _elem118 = NULL;
              if ( _elem118 != NULL)
              {
                g_object_unref (_elem118);
              }
              _elem118 = g_object_new (TYPE_SHARED_NOTEBOOK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem118), protocol, error)) < 0)
              {
                g_object_unref (_elem118);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem118);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_shared_notebooks_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListSharedNotebooksResult * this_object = NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListSharedNotebooksResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i119;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i119 = 0; i119 < (this_object->success ? this_object->success->len : 0); i119++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i119))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_shared_notebooks_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreListSharedNotebooksResult *self = NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_shared_notebooks_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreListSharedNotebooksResult *self = NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_shared_notebooks_result_instance_init (NoteStoreListSharedNotebooksResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_list_shared_notebooks_result_finalize (GObject *object)
{
  NoteStoreListSharedNotebooksResult *tobject = NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_list_shared_notebooks_result_class_init (NoteStoreListSharedNotebooksResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_shared_notebooks_result_read;
  struct_class->write = note_store_list_shared_notebooks_result_write;

  gobject_class->finalize = note_store_list_shared_notebooks_result_finalize;
  gobject_class->get_property = note_store_list_shared_notebooks_result_get_property;
  gobject_class->set_property = note_store_list_shared_notebooks_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_list_shared_notebooks_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListSharedNotebooksResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_shared_notebooks_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListSharedNotebooksResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_shared_notebooks_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListSharedNotebooksResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateLinkedNotebookArgsProperties
{
  PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_LINKED_NOTEBOOK
};

/* reads a note_store_create_linked_notebook_args object */
static gint32
note_store_create_linked_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateLinkedNotebookArgs * this_object = NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->linkedNotebook), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_linkedNotebook = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_linked_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateLinkedNotebookArgs * this_object = NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateLinkedNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebook", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->linkedNotebook), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_linked_notebook_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreCreateLinkedNotebookArgs *self = NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_LINKED_NOTEBOOK:
      if (self->linkedNotebook != NULL)
        g_object_unref (self->linkedNotebook);
      self->linkedNotebook = g_value_dup_object (value);
      self->__isset_linkedNotebook = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_linked_notebook_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreCreateLinkedNotebookArgs *self = NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_LINKED_NOTEBOOK:
      g_value_set_object (value, self->linkedNotebook);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_linked_notebook_args_instance_init (NoteStoreCreateLinkedNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->linkedNotebook = g_object_new (TYPE_LINKED_NOTEBOOK, NULL);
  object->__isset_linkedNotebook = FALSE;
}

static void 
note_store_create_linked_notebook_args_finalize (GObject *object)
{
  NoteStoreCreateLinkedNotebookArgs *tobject = NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->linkedNotebook != NULL)
  {
    g_object_unref(tobject->linkedNotebook);
    tobject->linkedNotebook = NULL;
  }
}

static void
note_store_create_linked_notebook_args_class_init (NoteStoreCreateLinkedNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_linked_notebook_args_read;
  struct_class->write = note_store_create_linked_notebook_args_write;

  gobject_class->finalize = note_store_create_linked_notebook_args_finalize;
  gobject_class->get_property = note_store_create_linked_notebook_args_get_property;
  gobject_class->set_property = note_store_create_linked_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS_LINKED_NOTEBOOK,
     g_param_spec_object ("linkedNotebook",
                         NULL,
                         NULL,
                         TYPE_LINKED_NOTEBOOK,
                         G_PARAM_READWRITE));
}

GType
note_store_create_linked_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateLinkedNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_linked_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateLinkedNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_linked_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateLinkedNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreCreateLinkedNotebookResultProperties
{
  PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_create_linked_notebook_result object */
static gint32
note_store_create_linked_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreCreateLinkedNotebookResult * this_object = NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_create_linked_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreCreateLinkedNotebookResult * this_object = NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreCreateLinkedNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_create_linked_notebook_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreCreateLinkedNotebookResult *self = NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_create_linked_notebook_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreCreateLinkedNotebookResult *self = NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_create_linked_notebook_result_instance_init (NoteStoreCreateLinkedNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_LINKED_NOTEBOOK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_create_linked_notebook_result_finalize (GObject *object)
{
  NoteStoreCreateLinkedNotebookResult *tobject = NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_create_linked_notebook_result_class_init (NoteStoreCreateLinkedNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_create_linked_notebook_result_read;
  struct_class->write = note_store_create_linked_notebook_result_write;

  gobject_class->finalize = note_store_create_linked_notebook_result_finalize;
  gobject_class->get_property = note_store_create_linked_notebook_result_get_property;
  gobject_class->set_property = note_store_create_linked_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_LINKED_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_create_linked_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreCreateLinkedNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_create_linked_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreCreateLinkedNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_create_linked_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreCreateLinkedNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateLinkedNotebookArgsProperties
{
  PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_LINKED_NOTEBOOK
};

/* reads a note_store_update_linked_notebook_args object */
static gint32
note_store_update_linked_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateLinkedNotebookArgs * this_object = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->linkedNotebook), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_linkedNotebook = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_linked_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateLinkedNotebookArgs * this_object = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateLinkedNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebook", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->linkedNotebook), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_linked_notebook_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreUpdateLinkedNotebookArgs *self = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_LINKED_NOTEBOOK:
      if (self->linkedNotebook != NULL)
        g_object_unref (self->linkedNotebook);
      self->linkedNotebook = g_value_dup_object (value);
      self->__isset_linkedNotebook = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_linked_notebook_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreUpdateLinkedNotebookArgs *self = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_LINKED_NOTEBOOK:
      g_value_set_object (value, self->linkedNotebook);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_linked_notebook_args_instance_init (NoteStoreUpdateLinkedNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->linkedNotebook = g_object_new (TYPE_LINKED_NOTEBOOK, NULL);
  object->__isset_linkedNotebook = FALSE;
}

static void 
note_store_update_linked_notebook_args_finalize (GObject *object)
{
  NoteStoreUpdateLinkedNotebookArgs *tobject = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->linkedNotebook != NULL)
  {
    g_object_unref(tobject->linkedNotebook);
    tobject->linkedNotebook = NULL;
  }
}

static void
note_store_update_linked_notebook_args_class_init (NoteStoreUpdateLinkedNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_linked_notebook_args_read;
  struct_class->write = note_store_update_linked_notebook_args_write;

  gobject_class->finalize = note_store_update_linked_notebook_args_finalize;
  gobject_class->get_property = note_store_update_linked_notebook_args_get_property;
  gobject_class->set_property = note_store_update_linked_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS_LINKED_NOTEBOOK,
     g_param_spec_object ("linkedNotebook",
                         NULL,
                         NULL,
                         TYPE_LINKED_NOTEBOOK,
                         G_PARAM_READWRITE));
}

GType
note_store_update_linked_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateLinkedNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_linked_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateLinkedNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_linked_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateLinkedNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateLinkedNotebookResultProperties
{
  PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_update_linked_notebook_result object */
static gint32
note_store_update_linked_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateLinkedNotebookResult * this_object = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_linked_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateLinkedNotebookResult * this_object = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateLinkedNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_linked_notebook_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreUpdateLinkedNotebookResult *self = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_linked_notebook_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreUpdateLinkedNotebookResult *self = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_linked_notebook_result_instance_init (NoteStoreUpdateLinkedNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_update_linked_notebook_result_finalize (GObject *object)
{
  NoteStoreUpdateLinkedNotebookResult *tobject = NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_update_linked_notebook_result_class_init (NoteStoreUpdateLinkedNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_linked_notebook_result_read;
  struct_class->write = note_store_update_linked_notebook_result_write;

  gobject_class->finalize = note_store_update_linked_notebook_result_finalize;
  gobject_class->get_property = note_store_update_linked_notebook_result_get_property;
  gobject_class->set_property = note_store_update_linked_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_update_linked_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateLinkedNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_linked_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateLinkedNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_linked_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateLinkedNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListLinkedNotebooksArgsProperties
{
  PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS_0,
  PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_list_linked_notebooks_args object */
static gint32
note_store_list_linked_notebooks_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListLinkedNotebooksArgs * this_object = NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_linked_notebooks_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListLinkedNotebooksArgs * this_object = NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListLinkedNotebooksArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_linked_notebooks_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreListLinkedNotebooksArgs *self = NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_linked_notebooks_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreListLinkedNotebooksArgs *self = NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_linked_notebooks_args_instance_init (NoteStoreListLinkedNotebooksArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_list_linked_notebooks_args_finalize (GObject *object)
{
  NoteStoreListLinkedNotebooksArgs *tobject = NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_list_linked_notebooks_args_class_init (NoteStoreListLinkedNotebooksArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_linked_notebooks_args_read;
  struct_class->write = note_store_list_linked_notebooks_args_write;

  gobject_class->finalize = note_store_list_linked_notebooks_args_finalize;
  gobject_class->get_property = note_store_list_linked_notebooks_args_get_property;
  gobject_class->set_property = note_store_list_linked_notebooks_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_list_linked_notebooks_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListLinkedNotebooksArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_linked_notebooks_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListLinkedNotebooksArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_linked_notebooks_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListLinkedNotebooksArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreListLinkedNotebooksResultProperties
{
  PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_0,
  PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_SUCCESS,
  PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_list_linked_notebooks_result object */
static gint32
note_store_list_linked_notebooks_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreListLinkedNotebooksResult * this_object = NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LinkedNotebook * _elem120 = NULL;
              if ( _elem120 != NULL)
              {
                g_object_unref (_elem120);
              }
              _elem120 = g_object_new (TYPE_LINKED_NOTEBOOK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem120), protocol, error)) < 0)
              {
                g_object_unref (_elem120);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem120);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_list_linked_notebooks_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreListLinkedNotebooksResult * this_object = NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreListLinkedNotebooksResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i121;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i121 = 0; i121 < (this_object->success ? this_object->success->len : 0); i121++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i121))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_list_linked_notebooks_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreListLinkedNotebooksResult *self = NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_list_linked_notebooks_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreListLinkedNotebooksResult *self = NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_list_linked_notebooks_result_instance_init (NoteStoreListLinkedNotebooksResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_list_linked_notebooks_result_finalize (GObject *object)
{
  NoteStoreListLinkedNotebooksResult *tobject = NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_list_linked_notebooks_result_class_init (NoteStoreListLinkedNotebooksResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_list_linked_notebooks_result_read;
  struct_class->write = note_store_list_linked_notebooks_result_write;

  gobject_class->finalize = note_store_list_linked_notebooks_result_finalize;
  gobject_class->get_property = note_store_list_linked_notebooks_result_get_property;
  gobject_class->set_property = note_store_list_linked_notebooks_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_list_linked_notebooks_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreListLinkedNotebooksResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_list_linked_notebooks_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreListLinkedNotebooksResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_list_linked_notebooks_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreListLinkedNotebooksResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeLinkedNotebookArgsProperties
{
  PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_GUID
};

/* reads a note_store_expunge_linked_notebook_args object */
static gint32
note_store_expunge_linked_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeLinkedNotebookArgs * this_object = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_linked_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeLinkedNotebookArgs * this_object = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeLinkedNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_linked_notebook_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreExpungeLinkedNotebookArgs *self = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_linked_notebook_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  NoteStoreExpungeLinkedNotebookArgs *self = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_linked_notebook_args_instance_init (NoteStoreExpungeLinkedNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_expunge_linked_notebook_args_finalize (GObject *object)
{
  NoteStoreExpungeLinkedNotebookArgs *tobject = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_expunge_linked_notebook_args_class_init (NoteStoreExpungeLinkedNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_linked_notebook_args_read;
  struct_class->write = note_store_expunge_linked_notebook_args_write;

  gobject_class->finalize = note_store_expunge_linked_notebook_args_finalize;
  gobject_class->get_property = note_store_expunge_linked_notebook_args_get_property;
  gobject_class->set_property = note_store_expunge_linked_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_expunge_linked_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeLinkedNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_linked_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeLinkedNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_linked_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeLinkedNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreExpungeLinkedNotebookResultProperties
{
  PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_expunge_linked_notebook_result object */
static gint32
note_store_expunge_linked_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreExpungeLinkedNotebookResult * this_object = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_expunge_linked_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreExpungeLinkedNotebookResult * this_object = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreExpungeLinkedNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_expunge_linked_notebook_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreExpungeLinkedNotebookResult *self = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_expunge_linked_notebook_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  NoteStoreExpungeLinkedNotebookResult *self = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_expunge_linked_notebook_result_instance_init (NoteStoreExpungeLinkedNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_expunge_linked_notebook_result_finalize (GObject *object)
{
  NoteStoreExpungeLinkedNotebookResult *tobject = NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_expunge_linked_notebook_result_class_init (NoteStoreExpungeLinkedNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_expunge_linked_notebook_result_read;
  struct_class->write = note_store_expunge_linked_notebook_result_write;

  gobject_class->finalize = note_store_expunge_linked_notebook_result_finalize;
  gobject_class->get_property = note_store_expunge_linked_notebook_result_get_property;
  gobject_class->set_property = note_store_expunge_linked_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_expunge_linked_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreExpungeLinkedNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_expunge_linked_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreExpungeLinkedNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_expunge_linked_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreExpungeLinkedNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreAuthenticateToSharedNotebookArgsProperties
{
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_0,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_SHARE_KEY_OR_GLOBAL_ID,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_authenticate_to_shared_notebook_args object */
static gint32
note_store_authenticate_to_shared_notebook_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreAuthenticateToSharedNotebookArgs * this_object = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->shareKeyOrGlobalId != NULL)
          {
            g_free(this_object->shareKeyOrGlobalId);
            this_object->shareKeyOrGlobalId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->shareKeyOrGlobalId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_shareKeyOrGlobalId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_authenticate_to_shared_notebook_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreAuthenticateToSharedNotebookArgs * this_object = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreAuthenticateToSharedNotebookArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "shareKeyOrGlobalId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->shareKeyOrGlobalId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_authenticate_to_shared_notebook_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreAuthenticateToSharedNotebookArgs *self = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_SHARE_KEY_OR_GLOBAL_ID:
      if (self->shareKeyOrGlobalId != NULL)
        g_free (self->shareKeyOrGlobalId);
      self->shareKeyOrGlobalId = g_value_dup_string (value);
      self->__isset_shareKeyOrGlobalId = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_authenticate_to_shared_notebook_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  NoteStoreAuthenticateToSharedNotebookArgs *self = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_SHARE_KEY_OR_GLOBAL_ID:
      g_value_set_string (value, self->shareKeyOrGlobalId);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_authenticate_to_shared_notebook_args_instance_init (NoteStoreAuthenticateToSharedNotebookArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->shareKeyOrGlobalId = NULL;
  object->__isset_shareKeyOrGlobalId = FALSE;
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_authenticate_to_shared_notebook_args_finalize (GObject *object)
{
  NoteStoreAuthenticateToSharedNotebookArgs *tobject = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->shareKeyOrGlobalId != NULL)
  {
    g_free(tobject->shareKeyOrGlobalId);
    tobject->shareKeyOrGlobalId = NULL;
  }
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_authenticate_to_shared_notebook_args_class_init (NoteStoreAuthenticateToSharedNotebookArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_authenticate_to_shared_notebook_args_read;
  struct_class->write = note_store_authenticate_to_shared_notebook_args_write;

  gobject_class->finalize = note_store_authenticate_to_shared_notebook_args_finalize;
  gobject_class->get_property = note_store_authenticate_to_shared_notebook_args_get_property;
  gobject_class->set_property = note_store_authenticate_to_shared_notebook_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_SHARE_KEY_OR_GLOBAL_ID,
     g_param_spec_string ("shareKeyOrGlobalId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_authenticate_to_shared_notebook_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreAuthenticateToSharedNotebookArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_authenticate_to_shared_notebook_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreAuthenticateToSharedNotebookArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_authenticate_to_shared_notebook_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreAuthenticateToSharedNotebookArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreAuthenticateToSharedNotebookResultProperties
{
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_0,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_SUCCESS,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_authenticate_to_shared_notebook_result object */
static gint32
note_store_authenticate_to_shared_notebook_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreAuthenticateToSharedNotebookResult * this_object = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_authenticate_to_shared_notebook_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreAuthenticateToSharedNotebookResult * this_object = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreAuthenticateToSharedNotebookResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_authenticate_to_shared_notebook_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreAuthenticateToSharedNotebookResult *self = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_authenticate_to_shared_notebook_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  NoteStoreAuthenticateToSharedNotebookResult *self = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_authenticate_to_shared_notebook_result_instance_init (NoteStoreAuthenticateToSharedNotebookResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_AUTHENTICATION_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_authenticate_to_shared_notebook_result_finalize (GObject *object)
{
  NoteStoreAuthenticateToSharedNotebookResult *tobject = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_authenticate_to_shared_notebook_result_class_init (NoteStoreAuthenticateToSharedNotebookResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_authenticate_to_shared_notebook_result_read;
  struct_class->write = note_store_authenticate_to_shared_notebook_result_write;

  gobject_class->finalize = note_store_authenticate_to_shared_notebook_result_finalize;
  gobject_class->get_property = note_store_authenticate_to_shared_notebook_result_get_property;
  gobject_class->set_property = note_store_authenticate_to_shared_notebook_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_AUTHENTICATION_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_authenticate_to_shared_notebook_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreAuthenticateToSharedNotebookResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_authenticate_to_shared_notebook_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreAuthenticateToSharedNotebookResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_authenticate_to_shared_notebook_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreAuthenticateToSharedNotebookResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetSharedNotebookByAuthArgsProperties
{
  PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS_0,
  PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_get_shared_notebook_by_auth_args object */
static gint32
note_store_get_shared_notebook_by_auth_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetSharedNotebookByAuthArgs * this_object = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_shared_notebook_by_auth_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetSharedNotebookByAuthArgs * this_object = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetSharedNotebookByAuthArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_shared_notebook_by_auth_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreGetSharedNotebookByAuthArgs *self = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_shared_notebook_by_auth_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreGetSharedNotebookByAuthArgs *self = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_shared_notebook_by_auth_args_instance_init (NoteStoreGetSharedNotebookByAuthArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_get_shared_notebook_by_auth_args_finalize (GObject *object)
{
  NoteStoreGetSharedNotebookByAuthArgs *tobject = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_get_shared_notebook_by_auth_args_class_init (NoteStoreGetSharedNotebookByAuthArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_shared_notebook_by_auth_args_read;
  struct_class->write = note_store_get_shared_notebook_by_auth_args_write;

  gobject_class->finalize = note_store_get_shared_notebook_by_auth_args_finalize;
  gobject_class->get_property = note_store_get_shared_notebook_by_auth_args_get_property;
  gobject_class->set_property = note_store_get_shared_notebook_by_auth_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_shared_notebook_by_auth_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetSharedNotebookByAuthArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_shared_notebook_by_auth_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetSharedNotebookByAuthArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_shared_notebook_by_auth_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetSharedNotebookByAuthArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetSharedNotebookByAuthResultProperties
{
  PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_0,
  PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_get_shared_notebook_by_auth_result object */
static gint32
note_store_get_shared_notebook_by_auth_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetSharedNotebookByAuthResult * this_object = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_shared_notebook_by_auth_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetSharedNotebookByAuthResult * this_object = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetSharedNotebookByAuthResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_shared_notebook_by_auth_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  NoteStoreGetSharedNotebookByAuthResult *self = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_shared_notebook_by_auth_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  NoteStoreGetSharedNotebookByAuthResult *self = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_shared_notebook_by_auth_result_instance_init (NoteStoreGetSharedNotebookByAuthResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SHARED_NOTEBOOK, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_get_shared_notebook_by_auth_result_finalize (GObject *object)
{
  NoteStoreGetSharedNotebookByAuthResult *tobject = NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_get_shared_notebook_by_auth_result_class_init (NoteStoreGetSharedNotebookByAuthResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_shared_notebook_by_auth_result_read;
  struct_class->write = note_store_get_shared_notebook_by_auth_result_write;

  gobject_class->finalize = note_store_get_shared_notebook_by_auth_result_finalize;
  gobject_class->get_property = note_store_get_shared_notebook_by_auth_result_get_property;
  gobject_class->set_property = note_store_get_shared_notebook_by_auth_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SHARED_NOTEBOOK,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_shared_notebook_by_auth_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetSharedNotebookByAuthResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_shared_notebook_by_auth_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetSharedNotebookByAuthResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_shared_notebook_by_auth_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetSharedNotebookByAuthResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreEmailNoteArgsProperties
{
  PROP_NOTE_STORE_EMAIL_NOTE_ARGS_0,
  PROP_NOTE_STORE_EMAIL_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_EMAIL_NOTE_ARGS_PARAMETERS
};

/* reads a note_store_email_note_args object */
static gint32
note_store_email_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreEmailNoteArgs * this_object = NOTE_STORE_EMAIL_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->parameters), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_parameters = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_email_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreEmailNoteArgs * this_object = NOTE_STORE_EMAIL_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreEmailNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "parameters", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->parameters), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_email_note_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreEmailNoteArgs *self = NOTE_STORE_EMAIL_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EMAIL_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_EMAIL_NOTE_ARGS_PARAMETERS:
      if (self->parameters != NULL)
        g_object_unref (self->parameters);
      self->parameters = g_value_dup_object (value);
      self->__isset_parameters = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_email_note_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreEmailNoteArgs *self = NOTE_STORE_EMAIL_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EMAIL_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_EMAIL_NOTE_ARGS_PARAMETERS:
      g_value_set_object (value, self->parameters);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_email_note_args_instance_init (NoteStoreEmailNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->parameters = g_object_new (TYPE_NOTE_EMAIL_PARAMETERS, NULL);
  object->__isset_parameters = FALSE;
}

static void 
note_store_email_note_args_finalize (GObject *object)
{
  NoteStoreEmailNoteArgs *tobject = NOTE_STORE_EMAIL_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->parameters != NULL)
  {
    g_object_unref(tobject->parameters);
    tobject->parameters = NULL;
  }
}

static void
note_store_email_note_args_class_init (NoteStoreEmailNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_email_note_args_read;
  struct_class->write = note_store_email_note_args_write;

  gobject_class->finalize = note_store_email_note_args_finalize;
  gobject_class->get_property = note_store_email_note_args_get_property;
  gobject_class->set_property = note_store_email_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EMAIL_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EMAIL_NOTE_ARGS_PARAMETERS,
     g_param_spec_object ("parameters",
                         NULL,
                         NULL,
                         TYPE_NOTE_EMAIL_PARAMETERS,
                         G_PARAM_READWRITE));
}

GType
note_store_email_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreEmailNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_email_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreEmailNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_email_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreEmailNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreEmailNoteResultProperties
{
  PROP_NOTE_STORE_EMAIL_NOTE_RESULT_0,
  PROP_NOTE_STORE_EMAIL_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_EMAIL_NOTE_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_EMAIL_NOTE_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_email_note_result object */
static gint32
note_store_email_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreEmailNoteResult * this_object = NOTE_STORE_EMAIL_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_email_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreEmailNoteResult * this_object = NOTE_STORE_EMAIL_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreEmailNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_email_note_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreEmailNoteResult *self = NOTE_STORE_EMAIL_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EMAIL_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_EMAIL_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_EMAIL_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_email_note_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreEmailNoteResult *self = NOTE_STORE_EMAIL_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_EMAIL_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_EMAIL_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_EMAIL_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_email_note_result_instance_init (NoteStoreEmailNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_email_note_result_finalize (GObject *object)
{
  NoteStoreEmailNoteResult *tobject = NOTE_STORE_EMAIL_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_email_note_result_class_init (NoteStoreEmailNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_email_note_result_read;
  struct_class->write = note_store_email_note_result_write;

  gobject_class->finalize = note_store_email_note_result_finalize;
  gobject_class->get_property = note_store_email_note_result_get_property;
  gobject_class->set_property = note_store_email_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EMAIL_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EMAIL_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_EMAIL_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_email_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreEmailNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_email_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreEmailNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_email_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreEmailNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreShareNoteArgsProperties
{
  PROP_NOTE_STORE_SHARE_NOTE_ARGS_0,
  PROP_NOTE_STORE_SHARE_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_SHARE_NOTE_ARGS_GUID
};

/* reads a note_store_share_note_args object */
static gint32
note_store_share_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreShareNoteArgs * this_object = NOTE_STORE_SHARE_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_share_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreShareNoteArgs * this_object = NOTE_STORE_SHARE_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreShareNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_share_note_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreShareNoteArgs *self = NOTE_STORE_SHARE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SHARE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTE_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_share_note_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  NoteStoreShareNoteArgs *self = NOTE_STORE_SHARE_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SHARE_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_SHARE_NOTE_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_share_note_args_instance_init (NoteStoreShareNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_share_note_args_finalize (GObject *object)
{
  NoteStoreShareNoteArgs *tobject = NOTE_STORE_SHARE_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_share_note_args_class_init (NoteStoreShareNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_share_note_args_read;
  struct_class->write = note_store_share_note_args_write;

  gobject_class->finalize = note_store_share_note_args_finalize;
  gobject_class->get_property = note_store_share_note_args_get_property;
  gobject_class->set_property = note_store_share_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTE_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_share_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreShareNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_share_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreShareNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_share_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreShareNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreShareNoteResultProperties
{
  PROP_NOTE_STORE_SHARE_NOTE_RESULT_0,
  PROP_NOTE_STORE_SHARE_NOTE_RESULT_SUCCESS,
  PROP_NOTE_STORE_SHARE_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_SHARE_NOTE_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_SHARE_NOTE_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_share_note_result object */
static gint32
note_store_share_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreShareNoteResult * this_object = NOTE_STORE_SHARE_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_share_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreShareNoteResult * this_object = NOTE_STORE_SHARE_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreShareNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_share_note_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreShareNoteResult *self = NOTE_STORE_SHARE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SHARE_NOTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_SHARE_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_share_note_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreShareNoteResult *self = NOTE_STORE_SHARE_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_SHARE_NOTE_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_NOTE_STORE_SHARE_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_SHARE_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_SHARE_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_share_note_result_instance_init (NoteStoreShareNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_share_note_result_finalize (GObject *object)
{
  NoteStoreShareNoteResult *tobject = NOTE_STORE_SHARE_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_share_note_result_class_init (NoteStoreShareNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_share_note_result_read;
  struct_class->write = note_store_share_note_result_write;

  gobject_class->finalize = note_store_share_note_result_finalize;
  gobject_class->get_property = note_store_share_note_result_get_property;
  gobject_class->set_property = note_store_share_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTE_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_SHARE_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_share_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreShareNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_share_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreShareNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_share_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreShareNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreStopSharingNoteArgsProperties
{
  PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_0,
  PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_GUID
};

/* reads a note_store_stop_sharing_note_args object */
static gint32
note_store_stop_sharing_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreStopSharingNoteArgs * this_object = NOTE_STORE_STOP_SHARING_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_stop_sharing_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreStopSharingNoteArgs * this_object = NOTE_STORE_STOP_SHARING_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreStopSharingNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_stop_sharing_note_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreStopSharingNoteArgs *self = NOTE_STORE_STOP_SHARING_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_stop_sharing_note_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  NoteStoreStopSharingNoteArgs *self = NOTE_STORE_STOP_SHARING_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_stop_sharing_note_args_instance_init (NoteStoreStopSharingNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->guid = NULL;
  object->__isset_guid = FALSE;
}

static void 
note_store_stop_sharing_note_args_finalize (GObject *object)
{
  NoteStoreStopSharingNoteArgs *tobject = NOTE_STORE_STOP_SHARING_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
}

static void
note_store_stop_sharing_note_args_class_init (NoteStoreStopSharingNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_stop_sharing_note_args_read;
  struct_class->write = note_store_stop_sharing_note_args_write;

  gobject_class->finalize = note_store_stop_sharing_note_args_finalize;
  gobject_class->get_property = note_store_stop_sharing_note_args_get_property;
  gobject_class->set_property = note_store_stop_sharing_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_STOP_SHARING_NOTE_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_stop_sharing_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreStopSharingNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_stop_sharing_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreStopSharingNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_stop_sharing_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreStopSharingNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreStopSharingNoteResultProperties
{
  PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_0,
  PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_stop_sharing_note_result object */
static gint32
note_store_stop_sharing_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreStopSharingNoteResult * this_object = NOTE_STORE_STOP_SHARING_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_stop_sharing_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreStopSharingNoteResult * this_object = NOTE_STORE_STOP_SHARING_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreStopSharingNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_stop_sharing_note_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreStopSharingNoteResult *self = NOTE_STORE_STOP_SHARING_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_stop_sharing_note_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreStopSharingNoteResult *self = NOTE_STORE_STOP_SHARING_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_stop_sharing_note_result_instance_init (NoteStoreStopSharingNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_stop_sharing_note_result_finalize (GObject *object)
{
  NoteStoreStopSharingNoteResult *tobject = NOTE_STORE_STOP_SHARING_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_stop_sharing_note_result_class_init (NoteStoreStopSharingNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_stop_sharing_note_result_read;
  struct_class->write = note_store_stop_sharing_note_result_write;

  gobject_class->finalize = note_store_stop_sharing_note_result_finalize;
  gobject_class->get_property = note_store_stop_sharing_note_result_get_property;
  gobject_class->set_property = note_store_stop_sharing_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_STOP_SHARING_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_stop_sharing_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreStopSharingNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_stop_sharing_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreStopSharingNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_stop_sharing_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreStopSharingNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreAuthenticateToSharedNoteArgsProperties
{
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_0,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_GUID,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_NOTE_KEY,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_AUTHENTICATION_TOKEN
};

/* reads a note_store_authenticate_to_shared_note_args object */
static gint32
note_store_authenticate_to_shared_note_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreAuthenticateToSharedNoteArgs * this_object = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->guid != NULL)
          {
            g_free(this_object->guid);
            this_object->guid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->guid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_guid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->noteKey != NULL)
          {
            g_free(this_object->noteKey);
            this_object->noteKey = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->noteKey, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noteKey = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_authenticate_to_shared_note_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreAuthenticateToSharedNoteArgs * this_object = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreAuthenticateToSharedNoteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->guid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "noteKey", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->noteKey, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_authenticate_to_shared_note_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreAuthenticateToSharedNoteArgs *self = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_GUID:
      if (self->guid != NULL)
        g_free (self->guid);
      self->guid = g_value_dup_string (value);
      self->__isset_guid = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_NOTE_KEY:
      if (self->noteKey != NULL)
        g_free (self->noteKey);
      self->noteKey = g_value_dup_string (value);
      self->__isset_noteKey = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_authenticate_to_shared_note_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  NoteStoreAuthenticateToSharedNoteArgs *self = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_GUID:
      g_value_set_string (value, self->guid);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_NOTE_KEY:
      g_value_set_string (value, self->noteKey);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_authenticate_to_shared_note_args_instance_init (NoteStoreAuthenticateToSharedNoteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->guid = NULL;
  object->__isset_guid = FALSE;
  object->noteKey = NULL;
  object->__isset_noteKey = FALSE;
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
}

static void 
note_store_authenticate_to_shared_note_args_finalize (GObject *object)
{
  NoteStoreAuthenticateToSharedNoteArgs *tobject = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->guid != NULL)
  {
    g_free(tobject->guid);
    tobject->guid = NULL;
  }
  if (tobject->noteKey != NULL)
  {
    g_free(tobject->noteKey);
    tobject->noteKey = NULL;
  }
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
}

static void
note_store_authenticate_to_shared_note_args_class_init (NoteStoreAuthenticateToSharedNoteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_authenticate_to_shared_note_args_read;
  struct_class->write = note_store_authenticate_to_shared_note_args_write;

  gobject_class->finalize = note_store_authenticate_to_shared_note_args_finalize;
  gobject_class->get_property = note_store_authenticate_to_shared_note_args_get_property;
  gobject_class->set_property = note_store_authenticate_to_shared_note_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_GUID,
     g_param_spec_string ("guid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_NOTE_KEY,
     g_param_spec_string ("noteKey",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_authenticate_to_shared_note_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreAuthenticateToSharedNoteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_authenticate_to_shared_note_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreAuthenticateToSharedNoteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_authenticate_to_shared_note_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreAuthenticateToSharedNoteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreAuthenticateToSharedNoteResultProperties
{
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_0,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_SUCCESS,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_authenticate_to_shared_note_result object */
static gint32
note_store_authenticate_to_shared_note_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreAuthenticateToSharedNoteResult * this_object = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_authenticate_to_shared_note_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreAuthenticateToSharedNoteResult * this_object = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreAuthenticateToSharedNoteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_authenticate_to_shared_note_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  NoteStoreAuthenticateToSharedNoteResult *self = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_authenticate_to_shared_note_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  NoteStoreAuthenticateToSharedNoteResult *self = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_authenticate_to_shared_note_result_instance_init (NoteStoreAuthenticateToSharedNoteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_AUTHENTICATION_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_authenticate_to_shared_note_result_finalize (GObject *object)
{
  NoteStoreAuthenticateToSharedNoteResult *tobject = NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_authenticate_to_shared_note_result_class_init (NoteStoreAuthenticateToSharedNoteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_authenticate_to_shared_note_result_read;
  struct_class->write = note_store_authenticate_to_shared_note_result_write;

  gobject_class->finalize = note_store_authenticate_to_shared_note_result_finalize;
  gobject_class->get_property = note_store_authenticate_to_shared_note_result_get_property;
  gobject_class->set_property = note_store_authenticate_to_shared_note_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_AUTHENTICATION_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_authenticate_to_shared_note_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreAuthenticateToSharedNoteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_authenticate_to_shared_note_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreAuthenticateToSharedNoteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_authenticate_to_shared_note_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreAuthenticateToSharedNoteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreFindRelatedArgsProperties
{
  PROP_NOTE_STORE_FIND_RELATED_ARGS_0,
  PROP_NOTE_STORE_FIND_RELATED_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_FIND_RELATED_ARGS_QUERY,
  PROP_NOTE_STORE_FIND_RELATED_ARGS_RESULT_SPEC
};

/* reads a note_store_find_related_args object */
static gint32
note_store_find_related_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreFindRelatedArgs * this_object = NOTE_STORE_FIND_RELATED_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_query = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->resultSpec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_resultSpec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_find_related_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreFindRelatedArgs * this_object = NOTE_STORE_FIND_RELATED_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreFindRelatedArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "query", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->query), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "resultSpec", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->resultSpec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_find_related_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreFindRelatedArgs *self = NOTE_STORE_FIND_RELATED_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_RELATED_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_RELATED_ARGS_QUERY:
      if (self->query != NULL)
        g_object_unref (self->query);
      self->query = g_value_dup_object (value);
      self->__isset_query = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_RELATED_ARGS_RESULT_SPEC:
      if (self->resultSpec != NULL)
        g_object_unref (self->resultSpec);
      self->resultSpec = g_value_dup_object (value);
      self->__isset_resultSpec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_find_related_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  NoteStoreFindRelatedArgs *self = NOTE_STORE_FIND_RELATED_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_RELATED_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_FIND_RELATED_ARGS_QUERY:
      g_value_set_object (value, self->query);
      break;

    case PROP_NOTE_STORE_FIND_RELATED_ARGS_RESULT_SPEC:
      g_value_set_object (value, self->resultSpec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_find_related_args_instance_init (NoteStoreFindRelatedArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->query = g_object_new (TYPE_RELATED_QUERY, NULL);
  object->__isset_query = FALSE;
  object->resultSpec = g_object_new (TYPE_RELATED_RESULT_SPEC, NULL);
  object->__isset_resultSpec = FALSE;
}

static void 
note_store_find_related_args_finalize (GObject *object)
{
  NoteStoreFindRelatedArgs *tobject = NOTE_STORE_FIND_RELATED_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->query != NULL)
  {
    g_object_unref(tobject->query);
    tobject->query = NULL;
  }
  if (tobject->resultSpec != NULL)
  {
    g_object_unref(tobject->resultSpec);
    tobject->resultSpec = NULL;
  }
}

static void
note_store_find_related_args_class_init (NoteStoreFindRelatedArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_find_related_args_read;
  struct_class->write = note_store_find_related_args_write;

  gobject_class->finalize = note_store_find_related_args_finalize;
  gobject_class->get_property = note_store_find_related_args_get_property;
  gobject_class->set_property = note_store_find_related_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_RELATED_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_RELATED_ARGS_QUERY,
     g_param_spec_object ("query",
                         NULL,
                         NULL,
                         TYPE_RELATED_QUERY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_RELATED_ARGS_RESULT_SPEC,
     g_param_spec_object ("resultSpec",
                         NULL,
                         NULL,
                         TYPE_RELATED_RESULT_SPEC,
                         G_PARAM_READWRITE));
}

GType
note_store_find_related_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreFindRelatedArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_find_related_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreFindRelatedArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_find_related_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreFindRelatedArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreFindRelatedResultProperties
{
  PROP_NOTE_STORE_FIND_RELATED_RESULT_0,
  PROP_NOTE_STORE_FIND_RELATED_RESULT_SUCCESS,
  PROP_NOTE_STORE_FIND_RELATED_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_FIND_RELATED_RESULT_SYSTEM_EXCEPTION,
  PROP_NOTE_STORE_FIND_RELATED_RESULT_NOT_FOUND_EXCEPTION
};

/* reads a note_store_find_related_result object */
static gint32
note_store_find_related_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreFindRelatedResult * this_object = NOTE_STORE_FIND_RELATED_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_find_related_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreFindRelatedResult * this_object = NOTE_STORE_FIND_RELATED_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreFindRelatedResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_find_related_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreFindRelatedResult *self = NOTE_STORE_FIND_RELATED_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_RELATED_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_RELATED_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_RELATED_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    case PROP_NOTE_STORE_FIND_RELATED_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_find_related_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  NoteStoreFindRelatedResult *self = NOTE_STORE_FIND_RELATED_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_FIND_RELATED_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_FIND_RELATED_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_FIND_RELATED_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    case PROP_NOTE_STORE_FIND_RELATED_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_find_related_result_instance_init (NoteStoreFindRelatedResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_RELATED_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
}

static void 
note_store_find_related_result_finalize (GObject *object)
{
  NoteStoreFindRelatedResult *tobject = NOTE_STORE_FIND_RELATED_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
}

static void
note_store_find_related_result_class_init (NoteStoreFindRelatedResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_find_related_result_read;
  struct_class->write = note_store_find_related_result_write;

  gobject_class->finalize = note_store_find_related_result_finalize;
  gobject_class->get_property = note_store_find_related_result_get_property;
  gobject_class->set_property = note_store_find_related_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_RELATED_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_RELATED_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_RELATED_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_RELATED_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_FIND_RELATED_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_find_related_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreFindRelatedResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_find_related_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreFindRelatedResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_find_related_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreFindRelatedResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateNoteIfUsnMatchesArgsProperties
{
  PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_0,
  PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_NOTE
};

/* reads a note_store_update_note_if_usn_matches_args object */
static gint32
note_store_update_note_if_usn_matches_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateNoteIfUsnMatchesArgs * this_object = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_note = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_note_if_usn_matches_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateNoteIfUsnMatchesArgs * this_object = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateNoteIfUsnMatchesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "note", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->note), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_note_if_usn_matches_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  NoteStoreUpdateNoteIfUsnMatchesArgs *self = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_NOTE:
      if (self->note != NULL)
        g_object_unref (self->note);
      self->note = g_value_dup_object (value);
      self->__isset_note = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_note_if_usn_matches_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  NoteStoreUpdateNoteIfUsnMatchesArgs *self = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_NOTE:
      g_value_set_object (value, self->note);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_note_if_usn_matches_args_instance_init (NoteStoreUpdateNoteIfUsnMatchesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->note = g_object_new (TYPE_NOTE, NULL);
  object->__isset_note = FALSE;
}

static void 
note_store_update_note_if_usn_matches_args_finalize (GObject *object)
{
  NoteStoreUpdateNoteIfUsnMatchesArgs *tobject = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->note != NULL)
  {
    g_object_unref(tobject->note);
    tobject->note = NULL;
  }
}

static void
note_store_update_note_if_usn_matches_args_class_init (NoteStoreUpdateNoteIfUsnMatchesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_note_if_usn_matches_args_read;
  struct_class->write = note_store_update_note_if_usn_matches_args_write;

  gobject_class->finalize = note_store_update_note_if_usn_matches_args_finalize;
  gobject_class->get_property = note_store_update_note_if_usn_matches_args_get_property;
  gobject_class->set_property = note_store_update_note_if_usn_matches_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS_NOTE,
     g_param_spec_object ("note",
                         NULL,
                         NULL,
                         TYPE_NOTE,
                         G_PARAM_READWRITE));
}

GType
note_store_update_note_if_usn_matches_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateNoteIfUsnMatchesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_note_if_usn_matches_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateNoteIfUsnMatchesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_note_if_usn_matches_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateNoteIfUsnMatchesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreUpdateNoteIfUsnMatchesResultProperties
{
  PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_0,
  PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_SUCCESS,
  PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_update_note_if_usn_matches_result object */
static gint32
note_store_update_note_if_usn_matches_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreUpdateNoteIfUsnMatchesResult * this_object = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_update_note_if_usn_matches_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreUpdateNoteIfUsnMatchesResult * this_object = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreUpdateNoteIfUsnMatchesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_update_note_if_usn_matches_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  NoteStoreUpdateNoteIfUsnMatchesResult *self = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_update_note_if_usn_matches_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  NoteStoreUpdateNoteIfUsnMatchesResult *self = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_update_note_if_usn_matches_result_instance_init (NoteStoreUpdateNoteIfUsnMatchesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_UPDATE_NOTE_IF_USN_MATCHES_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_update_note_if_usn_matches_result_finalize (GObject *object)
{
  NoteStoreUpdateNoteIfUsnMatchesResult *tobject = NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_update_note_if_usn_matches_result_class_init (NoteStoreUpdateNoteIfUsnMatchesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_update_note_if_usn_matches_result_read;
  struct_class->write = note_store_update_note_if_usn_matches_result_write;

  gobject_class->finalize = note_store_update_note_if_usn_matches_result_finalize;
  gobject_class->get_property = note_store_update_note_if_usn_matches_result_get_property;
  gobject_class->set_property = note_store_update_note_if_usn_matches_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_UPDATE_NOTE_IF_USN_MATCHES_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_update_note_if_usn_matches_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreUpdateNoteIfUsnMatchesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_update_note_if_usn_matches_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreUpdateNoteIfUsnMatchesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_update_note_if_usn_matches_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreUpdateNoteIfUsnMatchesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreManageNotebookSharesArgsProperties
{
  PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_0,
  PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_PARAMETERS
};

/* reads a note_store_manage_notebook_shares_args object */
static gint32
note_store_manage_notebook_shares_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreManageNotebookSharesArgs * this_object = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->parameters), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_parameters = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_manage_notebook_shares_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreManageNotebookSharesArgs * this_object = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreManageNotebookSharesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "parameters", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->parameters), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_manage_notebook_shares_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreManageNotebookSharesArgs *self = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_PARAMETERS:
      if (self->parameters != NULL)
        g_object_unref (self->parameters);
      self->parameters = g_value_dup_object (value);
      self->__isset_parameters = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_manage_notebook_shares_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  NoteStoreManageNotebookSharesArgs *self = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_PARAMETERS:
      g_value_set_object (value, self->parameters);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_manage_notebook_shares_args_instance_init (NoteStoreManageNotebookSharesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->parameters = g_object_new (TYPE_MANAGE_NOTEBOOK_SHARES_PARAMETERS, NULL);
  object->__isset_parameters = FALSE;
}

static void 
note_store_manage_notebook_shares_args_finalize (GObject *object)
{
  NoteStoreManageNotebookSharesArgs *tobject = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->parameters != NULL)
  {
    g_object_unref(tobject->parameters);
    tobject->parameters = NULL;
  }
}

static void
note_store_manage_notebook_shares_args_class_init (NoteStoreManageNotebookSharesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_manage_notebook_shares_args_read;
  struct_class->write = note_store_manage_notebook_shares_args_write;

  gobject_class->finalize = note_store_manage_notebook_shares_args_finalize;
  gobject_class->get_property = note_store_manage_notebook_shares_args_get_property;
  gobject_class->set_property = note_store_manage_notebook_shares_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS_PARAMETERS,
     g_param_spec_object ("parameters",
                         NULL,
                         NULL,
                         TYPE_MANAGE_NOTEBOOK_SHARES_PARAMETERS,
                         G_PARAM_READWRITE));
}

GType
note_store_manage_notebook_shares_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreManageNotebookSharesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_manage_notebook_shares_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreManageNotebookSharesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_manage_notebook_shares_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreManageNotebookSharesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreManageNotebookSharesResultProperties
{
  PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_0,
  PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_SUCCESS,
  PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_manage_notebook_shares_result object */
static gint32
note_store_manage_notebook_shares_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreManageNotebookSharesResult * this_object = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_manage_notebook_shares_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreManageNotebookSharesResult * this_object = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreManageNotebookSharesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_manage_notebook_shares_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreManageNotebookSharesResult *self = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_manage_notebook_shares_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  NoteStoreManageNotebookSharesResult *self = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_manage_notebook_shares_result_instance_init (NoteStoreManageNotebookSharesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_MANAGE_NOTEBOOK_SHARES_RESULT, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_manage_notebook_shares_result_finalize (GObject *object)
{
  NoteStoreManageNotebookSharesResult *tobject = NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_manage_notebook_shares_result_class_init (NoteStoreManageNotebookSharesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_manage_notebook_shares_result_read;
  struct_class->write = note_store_manage_notebook_shares_result_write;

  gobject_class->finalize = note_store_manage_notebook_shares_result_finalize;
  gobject_class->get_property = note_store_manage_notebook_shares_result_get_property;
  gobject_class->set_property = note_store_manage_notebook_shares_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_MANAGE_NOTEBOOK_SHARES_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_manage_notebook_shares_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreManageNotebookSharesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_manage_notebook_shares_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreManageNotebookSharesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_manage_notebook_shares_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreManageNotebookSharesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNotebookSharesArgsProperties
{
  PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_0,
  PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN,
  PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_NOTEBOOK_GUID
};

/* reads a note_store_get_notebook_shares_args object */
static gint32
note_store_get_notebook_shares_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNotebookSharesArgs * this_object = NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->authenticationToken != NULL)
          {
            g_free(this_object->authenticationToken);
            this_object->authenticationToken = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->authenticationToken, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_authenticationToken = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->notebookGuid != NULL)
          {
            g_free(this_object->notebookGuid);
            this_object->notebookGuid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->notebookGuid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_notebookGuid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_notebook_shares_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNotebookSharesArgs * this_object = NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNotebookSharesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->authenticationToken, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->notebookGuid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_notebook_shares_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreGetNotebookSharesArgs *self = NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN:
      if (self->authenticationToken != NULL)
        g_free (self->authenticationToken);
      self->authenticationToken = g_value_dup_string (value);
      self->__isset_authenticationToken = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_NOTEBOOK_GUID:
      if (self->notebookGuid != NULL)
        g_free (self->notebookGuid);
      self->notebookGuid = g_value_dup_string (value);
      self->__isset_notebookGuid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_notebook_shares_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  NoteStoreGetNotebookSharesArgs *self = NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN:
      g_value_set_string (value, self->authenticationToken);
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_NOTEBOOK_GUID:
      g_value_set_string (value, self->notebookGuid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_notebook_shares_args_instance_init (NoteStoreGetNotebookSharesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->authenticationToken = NULL;
  object->__isset_authenticationToken = FALSE;
  object->notebookGuid = NULL;
  object->__isset_notebookGuid = FALSE;
}

static void 
note_store_get_notebook_shares_args_finalize (GObject *object)
{
  NoteStoreGetNotebookSharesArgs *tobject = NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->authenticationToken != NULL)
  {
    g_free(tobject->authenticationToken);
    tobject->authenticationToken = NULL;
  }
  if (tobject->notebookGuid != NULL)
  {
    g_free(tobject->notebookGuid);
    tobject->notebookGuid = NULL;
  }
}

static void
note_store_get_notebook_shares_args_class_init (NoteStoreGetNotebookSharesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_notebook_shares_args_read;
  struct_class->write = note_store_get_notebook_shares_args_write;

  gobject_class->finalize = note_store_get_notebook_shares_args_finalize;
  gobject_class->get_property = note_store_get_notebook_shares_args_get_property;
  gobject_class->set_property = note_store_get_notebook_shares_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_AUTHENTICATION_TOKEN,
     g_param_spec_string ("authenticationToken",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS_NOTEBOOK_GUID,
     g_param_spec_string ("notebookGuid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
note_store_get_notebook_shares_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNotebookSharesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_notebook_shares_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNotebookSharesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_notebook_shares_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNotebookSharesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _NoteStoreGetNotebookSharesResultProperties
{
  PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_0,
  PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_SUCCESS,
  PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION,
  PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION
};

/* reads a note_store_get_notebook_shares_result object */
static gint32
note_store_get_notebook_shares_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NoteStoreGetNotebookSharesResult * this_object = NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->userException != NULL)
          {
            g_object_unref (this_object->userException);
          }
          this_object->userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
          {
            g_object_unref (this_object->userException);
            this_object->userException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_userException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->notFoundException != NULL)
          {
            g_object_unref (this_object->notFoundException);
          }
          this_object->notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
          {
            g_object_unref (this_object->notFoundException);
            this_object->notFoundException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_notFoundException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->systemException != NULL)
          {
            g_object_unref (this_object->systemException);
          }
          this_object->systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
          {
            g_object_unref (this_object->systemException);
            this_object->systemException = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_systemException = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
note_store_get_notebook_shares_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NoteStoreGetNotebookSharesResult * this_object = NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NoteStoreGetNotebookSharesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_userException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "userException", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->userException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_notFoundException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "notFoundException", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->notFoundException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_systemException == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "systemException", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->systemException), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
note_store_get_notebook_shares_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreGetNotebookSharesResult *self = NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION:
      if (self->userException != NULL)
        g_object_unref (self->userException);
      self->userException = g_value_dup_object (value);
      self->__isset_userException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION:
      if (self->notFoundException != NULL)
        g_object_unref (self->notFoundException);
      self->notFoundException = g_value_dup_object (value);
      self->__isset_notFoundException = TRUE;
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION:
      if (self->systemException != NULL)
        g_object_unref (self->systemException);
      self->systemException = g_value_dup_object (value);
      self->__isset_systemException = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_get_notebook_shares_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  NoteStoreGetNotebookSharesResult *self = NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION:
      g_value_set_object (value, self->userException);
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION:
      g_value_set_object (value, self->notFoundException);
      break;

    case PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION:
      g_value_set_object (value, self->systemException);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
note_store_get_notebook_shares_result_instance_init (NoteStoreGetNotebookSharesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SHARE_RELATIONSHIPS, NULL);
  object->__isset_success = FALSE;
  object->userException = NULL;
  object->__isset_userException = FALSE;
  object->notFoundException = NULL;
  object->__isset_notFoundException = FALSE;
  object->systemException = NULL;
  object->__isset_systemException = FALSE;
}

static void 
note_store_get_notebook_shares_result_finalize (GObject *object)
{
  NoteStoreGetNotebookSharesResult *tobject = NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->userException != NULL)
  {
    g_object_unref(tobject->userException);
    tobject->userException = NULL;
  }
  if (tobject->notFoundException != NULL)
  {
    g_object_unref(tobject->notFoundException);
    tobject->notFoundException = NULL;
  }
  if (tobject->systemException != NULL)
  {
    g_object_unref(tobject->systemException);
    tobject->systemException = NULL;
  }
}

static void
note_store_get_notebook_shares_result_class_init (NoteStoreGetNotebookSharesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = note_store_get_notebook_shares_result_read;
  struct_class->write = note_store_get_notebook_shares_result_write;

  gobject_class->finalize = note_store_get_notebook_shares_result_finalize;
  gobject_class->get_property = note_store_get_notebook_shares_result_get_property;
  gobject_class->set_property = note_store_get_notebook_shares_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SHARE_RELATIONSHIPS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_USER_EXCEPTION,
     g_param_spec_object ("userException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_USER_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_NOT_FOUND_EXCEPTION,
     g_param_spec_object ("notFoundException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_NOT_FOUND_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT_SYSTEM_EXCEPTION,
     g_param_spec_object ("systemException",
                         NULL,
                         NULL,
                         TYPE_E_D_A_M_SYSTEM_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
note_store_get_notebook_shares_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NoteStoreGetNotebookSharesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) note_store_get_notebook_shares_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NoteStoreGetNotebookSharesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) note_store_get_notebook_shares_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NoteStoreGetNotebookSharesResultType",
                                   &type_info, 0);
  }

  return type;
}

