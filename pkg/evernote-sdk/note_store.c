/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <string.h>
#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/thrift_application_exception.h>
#include "note_store.h"

gboolean
note_store_if_get_sync_state (NoteStoreIf *iface, SyncState ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_sync_state (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean
note_store_if_get_filtered_sync_chunk (NoteStoreIf *iface, SyncChunk ** _return, const gchar * authenticationToken, const gint32 afterUSN, const gint32 maxEntries, const SyncChunkFilter * filter, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_filtered_sync_chunk (iface, _return, authenticationToken, afterUSN, maxEntries, filter, userException, systemException, error);
}

gboolean
note_store_if_get_linked_notebook_sync_state (NoteStoreIf *iface, SyncState ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_linked_notebook_sync_state (iface, _return, authenticationToken, linkedNotebook, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_linked_notebook_sync_chunk (NoteStoreIf *iface, SyncChunk ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, const gint32 afterUSN, const gint32 maxEntries, const gboolean fullSyncOnly, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_linked_notebook_sync_chunk (iface, _return, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_list_notebooks (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->list_notebooks (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean
note_store_if_list_accessible_business_notebooks (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->list_accessible_business_notebooks (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean
note_store_if_get_notebook (NoteStoreIf *iface, Notebook ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_notebook (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_default_notebook (NoteStoreIf *iface, Notebook ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_default_notebook (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean
note_store_if_create_notebook (NoteStoreIf *iface, Notebook ** _return, const gchar * authenticationToken, const Notebook * notebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->create_notebook (iface, _return, authenticationToken, notebook, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_update_notebook (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Notebook * notebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->update_notebook (iface, _return, authenticationToken, notebook, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_expunge_notebook (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->expunge_notebook (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_list_tags (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->list_tags (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean
note_store_if_list_tags_by_notebook (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid notebookGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->list_tags_by_notebook (iface, _return, authenticationToken, notebookGuid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_tag (NoteStoreIf *iface, Tag ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_tag (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_create_tag (NoteStoreIf *iface, Tag ** _return, const gchar * authenticationToken, const Tag * tag, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->create_tag (iface, _return, authenticationToken, tag, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_update_tag (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Tag * tag, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->update_tag (iface, _return, authenticationToken, tag, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_untag_all (NoteStoreIf *iface, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->untag_all (iface, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_expunge_tag (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->expunge_tag (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_list_searches (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->list_searches (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean
note_store_if_get_search (NoteStoreIf *iface, SavedSearch ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_search (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_create_search (NoteStoreIf *iface, SavedSearch ** _return, const gchar * authenticationToken, const SavedSearch * search, EDAMUserException ** userException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->create_search (iface, _return, authenticationToken, search, userException, systemException, error);
}

gboolean
note_store_if_update_search (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const SavedSearch * search, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->update_search (iface, _return, authenticationToken, search, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_expunge_search (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->expunge_search (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_find_note_offset (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const NoteFilter * filter, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->find_note_offset (iface, _return, authenticationToken, filter, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_find_notes_metadata (NoteStoreIf *iface, NotesMetadataList ** _return, const gchar * authenticationToken, const NoteFilter * filter, const gint32 offset, const gint32 maxNotes, const NotesMetadataResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->find_notes_metadata (iface, _return, authenticationToken, filter, offset, maxNotes, resultSpec, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_find_note_counts (NoteStoreIf *iface, NoteCollectionCounts ** _return, const gchar * authenticationToken, const NoteFilter * filter, const gboolean withTrash, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->find_note_counts (iface, _return, authenticationToken, filter, withTrash, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_note_with_result_spec (NoteStoreIf *iface, Note ** _return, const gchar * authenticationToken, const Guid guid, const NoteResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_note_with_result_spec (iface, _return, authenticationToken, guid, resultSpec, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_note (NoteStoreIf *iface, Note ** _return, const gchar * authenticationToken, const Guid guid, const gboolean withContent, const gboolean withResourcesData, const gboolean withResourcesRecognition, const gboolean withResourcesAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_note (iface, _return, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_note_application_data (NoteStoreIf *iface, LazyMap ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_note_application_data (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_note_application_data_entry (NoteStoreIf *iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_note_application_data_entry (iface, _return, authenticationToken, guid, key, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_set_note_application_data_entry (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, const gchar * value, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->set_note_application_data_entry (iface, _return, authenticationToken, guid, key, value, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_unset_note_application_data_entry (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->unset_note_application_data_entry (iface, _return, authenticationToken, guid, key, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_note_content (NoteStoreIf *iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_note_content (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_note_search_text (NoteStoreIf *iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gboolean noteOnly, const gboolean tokenizeForIndexing, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_note_search_text (iface, _return, authenticationToken, guid, noteOnly, tokenizeForIndexing, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource_search_text (NoteStoreIf *iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource_search_text (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_note_tag_names (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_note_tag_names (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_create_note (NoteStoreIf *iface, Note ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->create_note (iface, _return, authenticationToken, note, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_update_note (NoteStoreIf *iface, Note ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->update_note (iface, _return, authenticationToken, note, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_delete_note (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->delete_note (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_expunge_note (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->expunge_note (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_copy_note (NoteStoreIf *iface, Note ** _return, const gchar * authenticationToken, const Guid noteGuid, const Guid toNotebookGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->copy_note (iface, _return, authenticationToken, noteGuid, toNotebookGuid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_list_note_versions (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid noteGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->list_note_versions (iface, _return, authenticationToken, noteGuid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_note_version (NoteStoreIf *iface, Note ** _return, const gchar * authenticationToken, const Guid noteGuid, const gint32 updateSequenceNum, const gboolean withResourcesData, const gboolean withResourcesRecognition, const gboolean withResourcesAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_note_version (iface, _return, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource (NoteStoreIf *iface, Resource ** _return, const gchar * authenticationToken, const Guid guid, const gboolean withData, const gboolean withRecognition, const gboolean withAttributes, const gboolean withAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource (iface, _return, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource_application_data (NoteStoreIf *iface, LazyMap ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource_application_data (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource_application_data_entry (NoteStoreIf *iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource_application_data_entry (iface, _return, authenticationToken, guid, key, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_set_resource_application_data_entry (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, const gchar * value, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->set_resource_application_data_entry (iface, _return, authenticationToken, guid, key, value, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_unset_resource_application_data_entry (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->unset_resource_application_data_entry (iface, _return, authenticationToken, guid, key, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_update_resource (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Resource * resource, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->update_resource (iface, _return, authenticationToken, resource, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource_data (NoteStoreIf *iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource_data (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource_by_hash (NoteStoreIf *iface, Resource ** _return, const gchar * authenticationToken, const Guid noteGuid, const GByteArray * contentHash, const gboolean withData, const gboolean withRecognition, const gboolean withAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource_by_hash (iface, _return, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource_recognition (NoteStoreIf *iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource_recognition (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource_alternate_data (NoteStoreIf *iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource_alternate_data (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_resource_attributes (NoteStoreIf *iface, ResourceAttributes ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_resource_attributes (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_get_public_notebook (NoteStoreIf *iface, Notebook ** _return, const UserID userId, const gchar * publicUri, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_public_notebook (iface, _return, userId, publicUri, systemException, notFoundException, error);
}

gboolean
note_store_if_share_notebook (NoteStoreIf *iface, SharedNotebook ** _return, const gchar * authenticationToken, const SharedNotebook * sharedNotebook, const gchar * message, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->share_notebook (iface, _return, authenticationToken, sharedNotebook, message, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_create_or_update_notebook_shares (NoteStoreIf *iface, CreateOrUpdateNotebookSharesResult ** _return, const gchar * authenticationToken, const NotebookShareTemplate * shareTemplate, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMInvalidContactsException ** invalidContactsException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->create_or_update_notebook_shares (iface, _return, authenticationToken, shareTemplate, userException, notFoundException, systemException, invalidContactsException, error);
}

gboolean
note_store_if_update_shared_notebook (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const SharedNotebook * sharedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->update_shared_notebook (iface, _return, authenticationToken, sharedNotebook, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_set_notebook_recipient_settings (NoteStoreIf *iface, Notebook ** _return, const gchar * authenticationToken, const gchar * notebookGuid, const NotebookRecipientSettings * recipientSettings, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->set_notebook_recipient_settings (iface, _return, authenticationToken, notebookGuid, recipientSettings, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_list_shared_notebooks (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->list_shared_notebooks (iface, _return, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_create_linked_notebook (NoteStoreIf *iface, LinkedNotebook ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->create_linked_notebook (iface, _return, authenticationToken, linkedNotebook, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_update_linked_notebook (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->update_linked_notebook (iface, _return, authenticationToken, linkedNotebook, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_list_linked_notebooks (NoteStoreIf *iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->list_linked_notebooks (iface, _return, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_expunge_linked_notebook (NoteStoreIf *iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->expunge_linked_notebook (iface, _return, authenticationToken, guid, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_authenticate_to_shared_notebook (NoteStoreIf *iface, AuthenticationResult ** _return, const gchar * shareKeyOrGlobalId, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->authenticate_to_shared_notebook (iface, _return, shareKeyOrGlobalId, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_get_shared_notebook_by_auth (NoteStoreIf *iface, SharedNotebook ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_shared_notebook_by_auth (iface, _return, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_email_note (NoteStoreIf *iface, const gchar * authenticationToken, const NoteEmailParameters * parameters, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->email_note (iface, authenticationToken, parameters, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_share_note (NoteStoreIf *iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->share_note (iface, _return, authenticationToken, guid, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_stop_sharing_note (NoteStoreIf *iface, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->stop_sharing_note (iface, authenticationToken, guid, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_authenticate_to_shared_note (NoteStoreIf *iface, AuthenticationResult ** _return, const gchar * guid, const gchar * noteKey, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->authenticate_to_shared_note (iface, _return, guid, noteKey, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_find_related (NoteStoreIf *iface, RelatedResult ** _return, const gchar * authenticationToken, const RelatedQuery * query, const RelatedResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->find_related (iface, _return, authenticationToken, query, resultSpec, userException, systemException, notFoundException, error);
}

gboolean
note_store_if_update_note_if_usn_matches (NoteStoreIf *iface, UpdateNoteIfUsnMatchesResult ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->update_note_if_usn_matches (iface, _return, authenticationToken, note, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_manage_notebook_shares (NoteStoreIf *iface, ManageNotebookSharesResult ** _return, const gchar * authenticationToken, const ManageNotebookSharesParameters * parameters, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->manage_notebook_shares (iface, _return, authenticationToken, parameters, userException, notFoundException, systemException, error);
}

gboolean
note_store_if_get_notebook_shares (NoteStoreIf *iface, ShareRelationships ** _return, const gchar * authenticationToken, const gchar * notebookGuid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError **error)
{
  return NOTE_STORE_IF_GET_INTERFACE (iface)->get_notebook_shares (iface, _return, authenticationToken, notebookGuid, userException, notFoundException, systemException, error);
}

GType
note_store_if_get_type (void)
{
  static GType type = 0;
  if (type == 0)
  {
    static const GTypeInfo type_info =
    {
      sizeof (NoteStoreIfInterface),
      NULL,  /* base_init */
      NULL,  /* base_finalize */
      NULL,  /* class_init */
      NULL,  /* class_finalize */
      NULL,  /* class_data */
      0,     /* instance_size */
      0,     /* n_preallocs */
      NULL,  /* instance_init */
      NULL   /* value_table */
    };
    type = g_type_register_static (G_TYPE_INTERFACE,
                                   "NoteStoreIf",
                                   &type_info, 0);
  }
  return type;
}

static void 
note_store_if_interface_init (NoteStoreIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (NoteStoreClient, note_store_client,
                         G_TYPE_OBJECT, 
                         G_IMPLEMENT_INTERFACE (TYPE_NOTE_STORE_IF,
                                                note_store_if_interface_init))

enum _NoteStoreClientProperties
{
  PROP_0,
  PROP_NOTE_STORE_CLIENT_INPUT_PROTOCOL,
  PROP_NOTE_STORE_CLIENT_OUTPUT_PROTOCOL
};

void
note_store_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
{
  NoteStoreClient *client = NOTE_STORE_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CLIENT_INPUT_PROTOCOL:
      client->input_protocol = g_value_get_object (value);
      break;
    case PROP_NOTE_STORE_CLIENT_OUTPUT_PROTOCOL:
      client->output_protocol = g_value_get_object (value);
      break;
  }
}

void
note_store_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
{
  NoteStoreClient *client = NOTE_STORE_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_NOTE_STORE_CLIENT_INPUT_PROTOCOL:
      g_value_set_object (value, client->input_protocol);
      break;
    case PROP_NOTE_STORE_CLIENT_OUTPUT_PROTOCOL:
      g_value_set_object (value, client->output_protocol);
      break;
  }
}

gboolean note_store_client_send_get_sync_state (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getSyncState", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getSyncState_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_sync_state (NoteStoreIf * iface, SyncState ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getSyncState", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getSyncState", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_sync_state (NoteStoreIf * iface, SyncState ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_get_sync_state (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_get_sync_state (iface, _return, userException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_filtered_sync_chunk (NoteStoreIf * iface, const gchar * authenticationToken, const gint32 afterUSN, const gint32 maxEntries, const SyncChunkFilter * filter, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFilteredSyncChunk", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFilteredSyncChunk_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "afterUSN", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, afterUSN, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxEntries", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, maxEntries, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (filter), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_filtered_sync_chunk (NoteStoreIf * iface, SyncChunk ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFilteredSyncChunk", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFilteredSyncChunk", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_filtered_sync_chunk (NoteStoreIf * iface, SyncChunk ** _return, const gchar * authenticationToken, const gint32 afterUSN, const gint32 maxEntries, const SyncChunkFilter * filter, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_get_filtered_sync_chunk (iface, authenticationToken, afterUSN, maxEntries, filter, error))
    return FALSE;
  if (!note_store_client_recv_get_filtered_sync_chunk (iface, _return, userException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_linked_notebook_sync_state (NoteStoreIf * iface, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getLinkedNotebookSyncState", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getLinkedNotebookSyncState_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebook", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (linkedNotebook), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_linked_notebook_sync_state (NoteStoreIf * iface, SyncState ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getLinkedNotebookSyncState", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getLinkedNotebookSyncState", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_linked_notebook_sync_state (NoteStoreIf * iface, SyncState ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_linked_notebook_sync_state (iface, authenticationToken, linkedNotebook, error))
    return FALSE;
  if (!note_store_client_recv_get_linked_notebook_sync_state (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_linked_notebook_sync_chunk (NoteStoreIf * iface, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, const gint32 afterUSN, const gint32 maxEntries, const gboolean fullSyncOnly, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getLinkedNotebookSyncChunk", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getLinkedNotebookSyncChunk_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebook", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (linkedNotebook), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "afterUSN", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, afterUSN, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxEntries", T_I32, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, maxEntries, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "fullSyncOnly", T_BOOL, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, fullSyncOnly, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_linked_notebook_sync_chunk (NoteStoreIf * iface, SyncChunk ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getLinkedNotebookSyncChunk", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getLinkedNotebookSyncChunk", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_linked_notebook_sync_chunk (NoteStoreIf * iface, SyncChunk ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, const gint32 afterUSN, const gint32 maxEntries, const gboolean fullSyncOnly, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_linked_notebook_sync_chunk (iface, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly, error))
    return FALSE;
  if (!note_store_client_recv_get_linked_notebook_sync_chunk (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_list_notebooks (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listNotebooks", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listNotebooks_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_list_notebooks (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listNotebooks", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listNotebooks", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                Notebook * _elem122 = NULL;
                if ( _elem122 != NULL)
                {
                  g_object_unref (_elem122);
                }
                _elem122 = g_object_new (TYPE_NOTEBOOK, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem122), protocol, error)) < 0)
                {
                  g_object_unref (_elem122);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem122);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_list_notebooks (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_list_notebooks (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_list_notebooks (iface, _return, userException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_list_accessible_business_notebooks (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listAccessibleBusinessNotebooks", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listAccessibleBusinessNotebooks_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_list_accessible_business_notebooks (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listAccessibleBusinessNotebooks", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listAccessibleBusinessNotebooks", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                Notebook * _elem123 = NULL;
                if ( _elem123 != NULL)
                {
                  g_object_unref (_elem123);
                }
                _elem123 = g_object_new (TYPE_NOTEBOOK, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem123), protocol, error)) < 0)
                {
                  g_object_unref (_elem123);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem123);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_list_accessible_business_notebooks (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_list_accessible_business_notebooks (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_list_accessible_business_notebooks (iface, _return, userException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_notebook (NoteStoreIf * iface, Notebook ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNotebook", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_notebook (NoteStoreIf * iface, Notebook ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_notebook (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_notebook (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_default_notebook (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDefaultNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDefaultNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_default_notebook (NoteStoreIf * iface, Notebook ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDefaultNotebook", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDefaultNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_default_notebook (NoteStoreIf * iface, Notebook ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_get_default_notebook (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_get_default_notebook (iface, _return, userException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_create_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const Notebook * notebook, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "createNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "createNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebook", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (notebook), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_create_notebook (NoteStoreIf * iface, Notebook ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "createNotebook", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected createNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_create_notebook (NoteStoreIf * iface, Notebook ** _return, const gchar * authenticationToken, const Notebook * notebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_create_notebook (iface, authenticationToken, notebook, error))
    return FALSE;
  if (!note_store_client_recv_create_notebook (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_update_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const Notebook * notebook, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebook", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (notebook), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_update_notebook (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateNotebook", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_update_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Notebook * notebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_update_notebook (iface, authenticationToken, notebook, error))
    return FALSE;
  if (!note_store_client_recv_update_notebook (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_expunge_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "expungeNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "expungeNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_expunge_notebook (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "expungeNotebook", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected expungeNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_expunge_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_expunge_notebook (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_expunge_notebook (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_list_tags (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listTags", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listTags_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_list_tags (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listTags", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listTags", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                Tag * _elem124 = NULL;
                if ( _elem124 != NULL)
                {
                  g_object_unref (_elem124);
                }
                _elem124 = g_object_new (TYPE_TAG, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem124), protocol, error)) < 0)
                {
                  g_object_unref (_elem124);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem124);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_list_tags (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_list_tags (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_list_tags (iface, _return, userException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_list_tags_by_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const Guid notebookGuid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listTagsByNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listTagsByNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, notebookGuid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_list_tags_by_notebook (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listTagsByNotebook", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listTagsByNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                Tag * _elem125 = NULL;
                if ( _elem125 != NULL)
                {
                  g_object_unref (_elem125);
                }
                _elem125 = g_object_new (TYPE_TAG, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem125), protocol, error)) < 0)
                {
                  g_object_unref (_elem125);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem125);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_list_tags_by_notebook (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid notebookGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_list_tags_by_notebook (iface, authenticationToken, notebookGuid, error))
    return FALSE;
  if (!note_store_client_recv_list_tags_by_notebook (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_tag (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getTag", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getTag_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_tag (NoteStoreIf * iface, Tag ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getTag", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getTag", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_tag (NoteStoreIf * iface, Tag ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_tag (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_tag (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_create_tag (NoteStoreIf * iface, const gchar * authenticationToken, const Tag * tag, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "createTag", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "createTag_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tag", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (tag), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_create_tag (NoteStoreIf * iface, Tag ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "createTag", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected createTag", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_create_tag (NoteStoreIf * iface, Tag ** _return, const gchar * authenticationToken, const Tag * tag, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_create_tag (iface, authenticationToken, tag, error))
    return FALSE;
  if (!note_store_client_recv_create_tag (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_update_tag (NoteStoreIf * iface, const gchar * authenticationToken, const Tag * tag, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateTag", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateTag_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tag", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (tag), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_update_tag (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateTag", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateTag", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_update_tag (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Tag * tag, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_update_tag (iface, authenticationToken, tag, error))
    return FALSE;
  if (!note_store_client_recv_update_tag (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_untag_all (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "untagAll", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "untagAll_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_untag_all (NoteStoreIf * iface, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "untagAll", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected untagAll", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_untag_all (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_untag_all (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_untag_all (iface, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_expunge_tag (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "expungeTag", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "expungeTag_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_expunge_tag (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "expungeTag", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected expungeTag", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_expunge_tag (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_expunge_tag (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_expunge_tag (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_list_searches (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listSearches", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listSearches_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_list_searches (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listSearches", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listSearches", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                SavedSearch * _elem126 = NULL;
                if ( _elem126 != NULL)
                {
                  g_object_unref (_elem126);
                }
                _elem126 = g_object_new (TYPE_SAVED_SEARCH, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem126), protocol, error)) < 0)
                {
                  g_object_unref (_elem126);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem126);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_list_searches (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_list_searches (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_list_searches (iface, _return, userException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_search (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getSearch", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getSearch_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_search (NoteStoreIf * iface, SavedSearch ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getSearch", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getSearch", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_search (NoteStoreIf * iface, SavedSearch ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_search (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_search (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_create_search (NoteStoreIf * iface, const gchar * authenticationToken, const SavedSearch * search, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "createSearch", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "createSearch_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "search", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (search), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_create_search (NoteStoreIf * iface, SavedSearch ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "createSearch", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected createSearch", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_create_search (NoteStoreIf * iface, SavedSearch ** _return, const gchar * authenticationToken, const SavedSearch * search, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_create_search (iface, authenticationToken, search, error))
    return FALSE;
  if (!note_store_client_recv_create_search (iface, _return, userException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_update_search (NoteStoreIf * iface, const gchar * authenticationToken, const SavedSearch * search, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateSearch", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateSearch_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "search", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (search), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_update_search (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateSearch", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateSearch", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_update_search (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const SavedSearch * search, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_update_search (iface, authenticationToken, search, error))
    return FALSE;
  if (!note_store_client_recv_update_search (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_expunge_search (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "expungeSearch", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "expungeSearch_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_expunge_search (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "expungeSearch", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected expungeSearch", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_expunge_search (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_expunge_search (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_expunge_search (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_find_note_offset (NoteStoreIf * iface, const gchar * authenticationToken, const NoteFilter * filter, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "findNoteOffset", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "findNoteOffset_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (filter), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_find_note_offset (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "findNoteOffset", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected findNoteOffset", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_find_note_offset (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const NoteFilter * filter, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_find_note_offset (iface, authenticationToken, filter, guid, error))
    return FALSE;
  if (!note_store_client_recv_find_note_offset (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_find_notes_metadata (NoteStoreIf * iface, const gchar * authenticationToken, const NoteFilter * filter, const gint32 offset, const gint32 maxNotes, const NotesMetadataResultSpec * resultSpec, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "findNotesMetadata", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "findNotesMetadata_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (filter), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, offset, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "maxNotes", T_I32, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, maxNotes, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "resultSpec", T_STRUCT, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (resultSpec), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_find_notes_metadata (NoteStoreIf * iface, NotesMetadataList ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "findNotesMetadata", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected findNotesMetadata", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_find_notes_metadata (NoteStoreIf * iface, NotesMetadataList ** _return, const gchar * authenticationToken, const NoteFilter * filter, const gint32 offset, const gint32 maxNotes, const NotesMetadataResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_find_notes_metadata (iface, authenticationToken, filter, offset, maxNotes, resultSpec, error))
    return FALSE;
  if (!note_store_client_recv_find_notes_metadata (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_find_note_counts (NoteStoreIf * iface, const gchar * authenticationToken, const NoteFilter * filter, const gboolean withTrash, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "findNoteCounts", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "findNoteCounts_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "filter", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (filter), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withTrash", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withTrash, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_find_note_counts (NoteStoreIf * iface, NoteCollectionCounts ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "findNoteCounts", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected findNoteCounts", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_find_note_counts (NoteStoreIf * iface, NoteCollectionCounts ** _return, const gchar * authenticationToken, const NoteFilter * filter, const gboolean withTrash, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_find_note_counts (iface, authenticationToken, filter, withTrash, error))
    return FALSE;
  if (!note_store_client_recv_find_note_counts (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_note_with_result_spec (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const NoteResultSpec * resultSpec, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNoteWithResultSpec", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNoteWithResultSpec_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "resultSpec", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (resultSpec), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_note_with_result_spec (NoteStoreIf * iface, Note ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNoteWithResultSpec", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNoteWithResultSpec", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_note_with_result_spec (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Guid guid, const NoteResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_note_with_result_spec (iface, authenticationToken, guid, resultSpec, error))
    return FALSE;
  if (!note_store_client_recv_get_note_with_result_spec (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_note (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gboolean withContent, const gboolean withResourcesData, const gboolean withResourcesRecognition, const gboolean withResourcesAlternateData, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withContent", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withContent, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesData", T_BOOL, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withResourcesData, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesRecognition", T_BOOL, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withResourcesRecognition, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesAlternateData", T_BOOL, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withResourcesAlternateData, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_note (NoteStoreIf * iface, Note ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNote", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_note (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Guid guid, const gboolean withContent, const gboolean withResourcesData, const gboolean withResourcesRecognition, const gboolean withResourcesAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_note (iface, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData, error))
    return FALSE;
  if (!note_store_client_recv_get_note (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_note_application_data (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNoteApplicationData", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNoteApplicationData_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_note_application_data (NoteStoreIf * iface, LazyMap ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNoteApplicationData", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNoteApplicationData", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_note_application_data (NoteStoreIf * iface, LazyMap ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_note_application_data (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_note_application_data (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_note_application_data_entry (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gchar * key, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNoteApplicationDataEntry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNoteApplicationDataEntry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, key, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_note_application_data_entry (NoteStoreIf * iface, gchar ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNoteApplicationDataEntry", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNoteApplicationDataEntry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_note_application_data_entry (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_note_application_data_entry (iface, authenticationToken, guid, key, error))
    return FALSE;
  if (!note_store_client_recv_get_note_application_data_entry (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_set_note_application_data_entry (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gchar * key, const gchar * value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "setNoteApplicationDataEntry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "setNoteApplicationDataEntry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, key, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, value, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_set_note_application_data_entry (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "setNoteApplicationDataEntry", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected setNoteApplicationDataEntry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_set_note_application_data_entry (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, const gchar * value, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_set_note_application_data_entry (iface, authenticationToken, guid, key, value, error))
    return FALSE;
  if (!note_store_client_recv_set_note_application_data_entry (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_unset_note_application_data_entry (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gchar * key, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "unsetNoteApplicationDataEntry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "unsetNoteApplicationDataEntry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, key, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_unset_note_application_data_entry (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "unsetNoteApplicationDataEntry", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected unsetNoteApplicationDataEntry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_unset_note_application_data_entry (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_unset_note_application_data_entry (iface, authenticationToken, guid, key, error))
    return FALSE;
  if (!note_store_client_recv_unset_note_application_data_entry (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_note_content (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNoteContent", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNoteContent_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_note_content (NoteStoreIf * iface, gchar ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNoteContent", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNoteContent", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_note_content (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_note_content (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_note_content (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_note_search_text (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gboolean noteOnly, const gboolean tokenizeForIndexing, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNoteSearchText", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNoteSearchText_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteOnly", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, noteOnly, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "tokenizeForIndexing", T_BOOL, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, tokenizeForIndexing, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_note_search_text (NoteStoreIf * iface, gchar ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNoteSearchText", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNoteSearchText", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_note_search_text (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gboolean noteOnly, const gboolean tokenizeForIndexing, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_note_search_text (iface, authenticationToken, guid, noteOnly, tokenizeForIndexing, error))
    return FALSE;
  if (!note_store_client_recv_get_note_search_text (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource_search_text (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResourceSearchText", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResourceSearchText_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource_search_text (NoteStoreIf * iface, gchar ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResourceSearchText", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResourceSearchText", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource_search_text (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource_search_text (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_resource_search_text (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_note_tag_names (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNoteTagNames", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNoteTagNames_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_note_tag_names (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNoteTagNames", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNoteTagNames", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem127 = NULL;
                if (_elem127 != NULL)
                {
                  g_free(_elem127);
                  _elem127 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem127, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem127);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_note_tag_names (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_note_tag_names (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_note_tag_names (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_create_note (NoteStoreIf * iface, const gchar * authenticationToken, const Note * note, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "createNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "createNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "note", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (note), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_create_note (NoteStoreIf * iface, Note ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "createNote", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected createNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_create_note (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_create_note (iface, authenticationToken, note, error))
    return FALSE;
  if (!note_store_client_recv_create_note (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_update_note (NoteStoreIf * iface, const gchar * authenticationToken, const Note * note, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "note", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (note), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_update_note (NoteStoreIf * iface, Note ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateNote", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_update_note (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_update_note (iface, authenticationToken, note, error))
    return FALSE;
  if (!note_store_client_recv_update_note (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_delete_note (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_delete_note (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteNote", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_delete_note (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_delete_note (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_delete_note (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_expunge_note (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "expungeNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "expungeNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_expunge_note (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "expungeNote", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected expungeNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_expunge_note (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_expunge_note (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_expunge_note (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_copy_note (NoteStoreIf * iface, const gchar * authenticationToken, const Guid noteGuid, const Guid toNotebookGuid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "copyNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "copyNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, noteGuid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "toNotebookGuid", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, toNotebookGuid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_copy_note (NoteStoreIf * iface, Note ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "copyNote", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected copyNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_copy_note (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Guid noteGuid, const Guid toNotebookGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_copy_note (iface, authenticationToken, noteGuid, toNotebookGuid, error))
    return FALSE;
  if (!note_store_client_recv_copy_note (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_list_note_versions (NoteStoreIf * iface, const gchar * authenticationToken, const Guid noteGuid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listNoteVersions", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listNoteVersions_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, noteGuid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_list_note_versions (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listNoteVersions", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listNoteVersions", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                NoteVersionId * _elem128 = NULL;
                if ( _elem128 != NULL)
                {
                  g_object_unref (_elem128);
                }
                _elem128 = g_object_new (TYPE_NOTE_VERSION_ID, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem128), protocol, error)) < 0)
                {
                  g_object_unref (_elem128);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem128);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_list_note_versions (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid noteGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_list_note_versions (iface, authenticationToken, noteGuid, error))
    return FALSE;
  if (!note_store_client_recv_list_note_versions (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_note_version (NoteStoreIf * iface, const gchar * authenticationToken, const Guid noteGuid, const gint32 updateSequenceNum, const gboolean withResourcesData, const gboolean withResourcesRecognition, const gboolean withResourcesAlternateData, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNoteVersion", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNoteVersion_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, noteGuid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateSequenceNum", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, updateSequenceNum, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesData", T_BOOL, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withResourcesData, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesRecognition", T_BOOL, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withResourcesRecognition, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withResourcesAlternateData", T_BOOL, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withResourcesAlternateData, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_note_version (NoteStoreIf * iface, Note ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNoteVersion", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNoteVersion", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_note_version (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Guid noteGuid, const gint32 updateSequenceNum, const gboolean withResourcesData, const gboolean withResourcesRecognition, const gboolean withResourcesAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_note_version (iface, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData, error))
    return FALSE;
  if (!note_store_client_recv_get_note_version (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gboolean withData, const gboolean withRecognition, const gboolean withAttributes, const gboolean withAlternateData, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResource", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResource_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withData", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withData, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withRecognition", T_BOOL, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withRecognition, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withAttributes", T_BOOL, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withAttributes, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withAlternateData", T_BOOL, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withAlternateData, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource (NoteStoreIf * iface, Resource ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResource", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResource", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource (NoteStoreIf * iface, Resource ** _return, const gchar * authenticationToken, const Guid guid, const gboolean withData, const gboolean withRecognition, const gboolean withAttributes, const gboolean withAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource (iface, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData, error))
    return FALSE;
  if (!note_store_client_recv_get_resource (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource_application_data (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResourceApplicationData", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResourceApplicationData_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource_application_data (NoteStoreIf * iface, LazyMap ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResourceApplicationData", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResourceApplicationData", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource_application_data (NoteStoreIf * iface, LazyMap ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource_application_data (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_resource_application_data (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource_application_data_entry (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gchar * key, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResourceApplicationDataEntry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResourceApplicationDataEntry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, key, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource_application_data_entry (NoteStoreIf * iface, gchar ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResourceApplicationDataEntry", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResourceApplicationDataEntry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource_application_data_entry (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource_application_data_entry (iface, authenticationToken, guid, key, error))
    return FALSE;
  if (!note_store_client_recv_get_resource_application_data_entry (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_set_resource_application_data_entry (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gchar * key, const gchar * value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "setResourceApplicationDataEntry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "setResourceApplicationDataEntry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, key, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, value, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_set_resource_application_data_entry (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "setResourceApplicationDataEntry", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected setResourceApplicationDataEntry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_set_resource_application_data_entry (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, const gchar * value, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_set_resource_application_data_entry (iface, authenticationToken, guid, key, value, error))
    return FALSE;
  if (!note_store_client_recv_set_resource_application_data_entry (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_unset_resource_application_data_entry (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, const gchar * key, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "unsetResourceApplicationDataEntry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "unsetResourceApplicationDataEntry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, key, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_unset_resource_application_data_entry (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "unsetResourceApplicationDataEntry", 33) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected unsetResourceApplicationDataEntry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_unset_resource_application_data_entry (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_unset_resource_application_data_entry (iface, authenticationToken, guid, key, error))
    return FALSE;
  if (!note_store_client_recv_unset_resource_application_data_entry (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_update_resource (NoteStoreIf * iface, const gchar * authenticationToken, const Resource * resource, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateResource", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateResource_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "resource", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (resource), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_update_resource (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateResource", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateResource", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_update_resource (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Resource * resource, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_update_resource (iface, authenticationToken, resource, error))
    return FALSE;
  if (!note_store_client_recv_update_resource (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource_data (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResourceData", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResourceData_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource_data (NoteStoreIf * iface, GByteArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResourceData", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResourceData", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
              return 0;
            xfer += ret;
            *_return = g_byte_array_new();
            g_byte_array_append (*_return, (guint8 *) data, (guint) len);
            g_free (data);
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource_data (NoteStoreIf * iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource_data (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_resource_data (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource_by_hash (NoteStoreIf * iface, const gchar * authenticationToken, const Guid noteGuid, const GByteArray * contentHash, const gboolean withData, const gboolean withRecognition, const gboolean withAlternateData, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResourceByHash", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResourceByHash_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteGuid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, noteGuid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "contentHash", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, contentHash ? ((GByteArray *) contentHash)->data : NULL, contentHash ? ((GByteArray *) contentHash)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withData", T_BOOL, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withData, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withRecognition", T_BOOL, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withRecognition, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "withAlternateData", T_BOOL, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, withAlternateData, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource_by_hash (NoteStoreIf * iface, Resource ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResourceByHash", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResourceByHash", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource_by_hash (NoteStoreIf * iface, Resource ** _return, const gchar * authenticationToken, const Guid noteGuid, const GByteArray * contentHash, const gboolean withData, const gboolean withRecognition, const gboolean withAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource_by_hash (iface, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData, error))
    return FALSE;
  if (!note_store_client_recv_get_resource_by_hash (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource_recognition (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResourceRecognition", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResourceRecognition_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource_recognition (NoteStoreIf * iface, GByteArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResourceRecognition", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResourceRecognition", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
              return 0;
            xfer += ret;
            *_return = g_byte_array_new();
            g_byte_array_append (*_return, (guint8 *) data, (guint) len);
            g_free (data);
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource_recognition (NoteStoreIf * iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource_recognition (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_resource_recognition (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource_alternate_data (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResourceAlternateData", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResourceAlternateData_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource_alternate_data (NoteStoreIf * iface, GByteArray ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResourceAlternateData", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResourceAlternateData", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
              return 0;
            xfer += ret;
            *_return = g_byte_array_new();
            g_byte_array_append (*_return, (guint8 *) data, (guint) len);
            g_free (data);
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource_alternate_data (NoteStoreIf * iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource_alternate_data (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_resource_alternate_data (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_resource_attributes (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getResourceAttributes", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getResourceAttributes_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_resource_attributes (NoteStoreIf * iface, ResourceAttributes ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getResourceAttributes", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getResourceAttributes", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_resource_attributes (NoteStoreIf * iface, ResourceAttributes ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_resource_attributes (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_get_resource_attributes (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_public_notebook (NoteStoreIf * iface, const UserID userId, const gchar * publicUri, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPublicNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPublicNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "userId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, userId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "publicUri", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, publicUri, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_public_notebook (NoteStoreIf * iface, Notebook ** _return, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPublicNotebook", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPublicNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_public_notebook (NoteStoreIf * iface, Notebook ** _return, const UserID userId, const gchar * publicUri, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_get_public_notebook (iface, userId, publicUri, error))
    return FALSE;
  if (!note_store_client_recv_get_public_notebook (iface, _return, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_share_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const SharedNotebook * sharedNotebook, const gchar * message, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "shareNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "shareNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "sharedNotebook", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (sharedNotebook), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, message, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_share_notebook (NoteStoreIf * iface, SharedNotebook ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "shareNotebook", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected shareNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_share_notebook (NoteStoreIf * iface, SharedNotebook ** _return, const gchar * authenticationToken, const SharedNotebook * sharedNotebook, const gchar * message, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_share_notebook (iface, authenticationToken, sharedNotebook, message, error))
    return FALSE;
  if (!note_store_client_recv_share_notebook (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_create_or_update_notebook_shares (NoteStoreIf * iface, const gchar * authenticationToken, const NotebookShareTemplate * shareTemplate, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "createOrUpdateNotebookShares", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "createOrUpdateNotebookShares_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "shareTemplate", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (shareTemplate), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_create_or_update_notebook_shares (NoteStoreIf * iface, CreateOrUpdateNotebookSharesResult ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMInvalidContactsException ** invalidContactsException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "createOrUpdateNotebookShares", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected createOrUpdateNotebookShares", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 4:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *invalidContactsException != NULL)
            {
              g_object_unref (*invalidContactsException);
            }
            *invalidContactsException = g_object_new (TYPE_E_D_A_M_INVALID_CONTACTS_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*invalidContactsException), protocol, error)) < 0)
            {
              g_object_unref (*invalidContactsException);
              *invalidContactsException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*invalidContactsException != NULL)
  {
      g_set_error (error, E_D_A_M_INVALID_CONTACTS_EXCEPTION_ERROR, E_D_A_M_INVALID_CONTACTS_EXCEPTION_ERROR_CODE, "EDAMInvalidContactsException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_create_or_update_notebook_shares (NoteStoreIf * iface, CreateOrUpdateNotebookSharesResult ** _return, const gchar * authenticationToken, const NotebookShareTemplate * shareTemplate, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMInvalidContactsException ** invalidContactsException, GError ** error)
{
  if (!note_store_client_send_create_or_update_notebook_shares (iface, authenticationToken, shareTemplate, error))
    return FALSE;
  if (!note_store_client_recv_create_or_update_notebook_shares (iface, _return, userException, notFoundException, systemException, invalidContactsException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_update_shared_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const SharedNotebook * sharedNotebook, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateSharedNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateSharedNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "sharedNotebook", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (sharedNotebook), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_update_shared_notebook (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateSharedNotebook", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateSharedNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_update_shared_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const SharedNotebook * sharedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_update_shared_notebook (iface, authenticationToken, sharedNotebook, error))
    return FALSE;
  if (!note_store_client_recv_update_shared_notebook (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_set_notebook_recipient_settings (NoteStoreIf * iface, const gchar * authenticationToken, const gchar * notebookGuid, const NotebookRecipientSettings * recipientSettings, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "setNotebookRecipientSettings", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "setNotebookRecipientSettings_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, notebookGuid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "recipientSettings", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (recipientSettings), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_set_notebook_recipient_settings (NoteStoreIf * iface, Notebook ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "setNotebookRecipientSettings", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected setNotebookRecipientSettings", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_set_notebook_recipient_settings (NoteStoreIf * iface, Notebook ** _return, const gchar * authenticationToken, const gchar * notebookGuid, const NotebookRecipientSettings * recipientSettings, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_set_notebook_recipient_settings (iface, authenticationToken, notebookGuid, recipientSettings, error))
    return FALSE;
  if (!note_store_client_recv_set_notebook_recipient_settings (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_list_shared_notebooks (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listSharedNotebooks", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listSharedNotebooks_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_list_shared_notebooks (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listSharedNotebooks", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listSharedNotebooks", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                SharedNotebook * _elem129 = NULL;
                if ( _elem129 != NULL)
                {
                  g_object_unref (_elem129);
                }
                _elem129 = g_object_new (TYPE_SHARED_NOTEBOOK, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem129), protocol, error)) < 0)
                {
                  g_object_unref (_elem129);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem129);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_list_shared_notebooks (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_list_shared_notebooks (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_list_shared_notebooks (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_create_linked_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "createLinkedNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "createLinkedNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebook", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (linkedNotebook), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_create_linked_notebook (NoteStoreIf * iface, LinkedNotebook ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "createLinkedNotebook", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected createLinkedNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_create_linked_notebook (NoteStoreIf * iface, LinkedNotebook ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_create_linked_notebook (iface, authenticationToken, linkedNotebook, error))
    return FALSE;
  if (!note_store_client_recv_create_linked_notebook (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_update_linked_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateLinkedNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateLinkedNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "linkedNotebook", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (linkedNotebook), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_update_linked_notebook (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateLinkedNotebook", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateLinkedNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_update_linked_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_update_linked_notebook (iface, authenticationToken, linkedNotebook, error))
    return FALSE;
  if (!note_store_client_recv_update_linked_notebook (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_list_linked_notebooks (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listLinkedNotebooks", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listLinkedNotebooks_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_list_linked_notebooks (NoteStoreIf * iface, GPtrArray ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listLinkedNotebooks", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listLinkedNotebooks", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                LinkedNotebook * _elem130 = NULL;
                if ( _elem130 != NULL)
                {
                  g_object_unref (_elem130);
                }
                _elem130 = g_object_new (TYPE_LINKED_NOTEBOOK, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem130), protocol, error)) < 0)
                {
                  g_object_unref (_elem130);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem130);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_list_linked_notebooks (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_list_linked_notebooks (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_list_linked_notebooks (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_expunge_linked_notebook (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "expungeLinkedNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "expungeLinkedNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_expunge_linked_notebook (NoteStoreIf * iface, gint32* _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "expungeLinkedNotebook", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected expungeLinkedNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_expunge_linked_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_expunge_linked_notebook (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_expunge_linked_notebook (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_authenticate_to_shared_notebook (NoteStoreIf * iface, const gchar * shareKeyOrGlobalId, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "authenticateToSharedNotebook", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "authenticateToSharedNotebook_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "shareKeyOrGlobalId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, shareKeyOrGlobalId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_authenticate_to_shared_notebook (NoteStoreIf * iface, AuthenticationResult ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "authenticateToSharedNotebook", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected authenticateToSharedNotebook", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_authenticate_to_shared_notebook (NoteStoreIf * iface, AuthenticationResult ** _return, const gchar * shareKeyOrGlobalId, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_authenticate_to_shared_notebook (iface, shareKeyOrGlobalId, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_authenticate_to_shared_notebook (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_shared_notebook_by_auth (NoteStoreIf * iface, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getSharedNotebookByAuth", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getSharedNotebookByAuth_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_shared_notebook_by_auth (NoteStoreIf * iface, SharedNotebook ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getSharedNotebookByAuth", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getSharedNotebookByAuth", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_shared_notebook_by_auth (NoteStoreIf * iface, SharedNotebook ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_get_shared_notebook_by_auth (iface, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_get_shared_notebook_by_auth (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_email_note (NoteStoreIf * iface, const gchar * authenticationToken, const NoteEmailParameters * parameters, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "emailNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "emailNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "parameters", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (parameters), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_email_note (NoteStoreIf * iface, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "emailNote", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected emailNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_email_note (NoteStoreIf * iface, const gchar * authenticationToken, const NoteEmailParameters * parameters, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_email_note (iface, authenticationToken, parameters, error))
    return FALSE;
  if (!note_store_client_recv_email_note (iface, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_share_note (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "shareNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "shareNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_share_note (NoteStoreIf * iface, gchar ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "shareNote", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected shareNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_share_note (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_share_note (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_share_note (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_stop_sharing_note (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "stopSharingNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "stopSharingNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_stop_sharing_note (NoteStoreIf * iface, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "stopSharingNote", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected stopSharingNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_stop_sharing_note (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_stop_sharing_note (iface, authenticationToken, guid, error))
    return FALSE;
  if (!note_store_client_recv_stop_sharing_note (iface, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_authenticate_to_shared_note (NoteStoreIf * iface, const gchar * guid, const gchar * noteKey, const gchar * authenticationToken, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "authenticateToSharedNote", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "authenticateToSharedNote_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "guid", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, guid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "noteKey", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, noteKey, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_authenticate_to_shared_note (NoteStoreIf * iface, AuthenticationResult ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "authenticateToSharedNote", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected authenticateToSharedNote", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_authenticate_to_shared_note (NoteStoreIf * iface, AuthenticationResult ** _return, const gchar * guid, const gchar * noteKey, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_authenticate_to_shared_note (iface, guid, noteKey, authenticationToken, error))
    return FALSE;
  if (!note_store_client_recv_authenticate_to_shared_note (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_find_related (NoteStoreIf * iface, const gchar * authenticationToken, const RelatedQuery * query, const RelatedResultSpec * resultSpec, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "findRelated", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "findRelated_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "query", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (query), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "resultSpec", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (resultSpec), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_find_related (NoteStoreIf * iface, RelatedResult ** _return, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "findRelated", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected findRelated", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_find_related (NoteStoreIf * iface, RelatedResult ** _return, const gchar * authenticationToken, const RelatedQuery * query, const RelatedResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  if (!note_store_client_send_find_related (iface, authenticationToken, query, resultSpec, error))
    return FALSE;
  if (!note_store_client_recv_find_related (iface, _return, userException, systemException, notFoundException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_update_note_if_usn_matches (NoteStoreIf * iface, const gchar * authenticationToken, const Note * note, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateNoteIfUsnMatches", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateNoteIfUsnMatches_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "note", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (note), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_update_note_if_usn_matches (NoteStoreIf * iface, UpdateNoteIfUsnMatchesResult ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateNoteIfUsnMatches", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateNoteIfUsnMatches", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_update_note_if_usn_matches (NoteStoreIf * iface, UpdateNoteIfUsnMatchesResult ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_update_note_if_usn_matches (iface, authenticationToken, note, error))
    return FALSE;
  if (!note_store_client_recv_update_note_if_usn_matches (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_manage_notebook_shares (NoteStoreIf * iface, const gchar * authenticationToken, const ManageNotebookSharesParameters * parameters, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "manageNotebookShares", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "manageNotebookShares_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "parameters", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (parameters), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_manage_notebook_shares (NoteStoreIf * iface, ManageNotebookSharesResult ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "manageNotebookShares", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected manageNotebookShares", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_manage_notebook_shares (NoteStoreIf * iface, ManageNotebookSharesResult ** _return, const gchar * authenticationToken, const ManageNotebookSharesParameters * parameters, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_manage_notebook_shares (iface, authenticationToken, parameters, error))
    return FALSE;
  if (!note_store_client_recv_manage_notebook_shares (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

gboolean note_store_client_send_get_notebook_shares (NoteStoreIf * iface, const gchar * authenticationToken, const gchar * notebookGuid, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getNotebookShares", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getNotebookShares_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "authenticationToken", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, authenticationToken, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "notebookGuid", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, notebookGuid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean note_store_client_recv_get_notebook_shares (NoteStoreIf * iface, ShareRelationships ** _return, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = NOTE_STORE_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getNotebookShares", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getNotebookShares", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *userException != NULL)
            {
              g_object_unref (*userException);
            }
            *userException = g_object_new (TYPE_E_D_A_M_USER_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*userException), protocol, error)) < 0)
            {
              g_object_unref (*userException);
              *userException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *notFoundException != NULL)
            {
              g_object_unref (*notFoundException);
            }
            *notFoundException = g_object_new (TYPE_E_D_A_M_NOT_FOUND_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*notFoundException), protocol, error)) < 0)
            {
              g_object_unref (*notFoundException);
              *notFoundException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 3:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *systemException != NULL)
            {
              g_object_unref (*systemException);
            }
            *systemException = g_object_new (TYPE_E_D_A_M_SYSTEM_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*systemException), protocol, error)) < 0)
            {
              g_object_unref (*systemException);
              *systemException = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*userException != NULL)
  {
      g_set_error (error, E_D_A_M_USER_EXCEPTION_ERROR, E_D_A_M_USER_EXCEPTION_ERROR_CODE, "EDAMUserException");
      return FALSE;
  }
  if (*notFoundException != NULL)
  {
      g_set_error (error, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR, E_D_A_M_NOT_FOUND_EXCEPTION_ERROR_CODE, "EDAMNotFoundException");
      return FALSE;
  }
  if (*systemException != NULL)
  {
      g_set_error (error, E_D_A_M_SYSTEM_EXCEPTION_ERROR, E_D_A_M_SYSTEM_EXCEPTION_ERROR_CODE, "EDAMSystemException");
      return FALSE;
  }
  return TRUE;
}

gboolean note_store_client_get_notebook_shares (NoteStoreIf * iface, ShareRelationships ** _return, const gchar * authenticationToken, const gchar * notebookGuid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  if (!note_store_client_send_get_notebook_shares (iface, authenticationToken, notebookGuid, error))
    return FALSE;
  if (!note_store_client_recv_get_notebook_shares (iface, _return, userException, notFoundException, systemException, error))
    return FALSE;
  return TRUE;
}

static void
note_store_if_interface_init (NoteStoreIfInterface *iface)
{
  iface->get_sync_state = note_store_client_get_sync_state;
  iface->get_filtered_sync_chunk = note_store_client_get_filtered_sync_chunk;
  iface->get_linked_notebook_sync_state = note_store_client_get_linked_notebook_sync_state;
  iface->get_linked_notebook_sync_chunk = note_store_client_get_linked_notebook_sync_chunk;
  iface->list_notebooks = note_store_client_list_notebooks;
  iface->list_accessible_business_notebooks = note_store_client_list_accessible_business_notebooks;
  iface->get_notebook = note_store_client_get_notebook;
  iface->get_default_notebook = note_store_client_get_default_notebook;
  iface->create_notebook = note_store_client_create_notebook;
  iface->update_notebook = note_store_client_update_notebook;
  iface->expunge_notebook = note_store_client_expunge_notebook;
  iface->list_tags = note_store_client_list_tags;
  iface->list_tags_by_notebook = note_store_client_list_tags_by_notebook;
  iface->get_tag = note_store_client_get_tag;
  iface->create_tag = note_store_client_create_tag;
  iface->update_tag = note_store_client_update_tag;
  iface->untag_all = note_store_client_untag_all;
  iface->expunge_tag = note_store_client_expunge_tag;
  iface->list_searches = note_store_client_list_searches;
  iface->get_search = note_store_client_get_search;
  iface->create_search = note_store_client_create_search;
  iface->update_search = note_store_client_update_search;
  iface->expunge_search = note_store_client_expunge_search;
  iface->find_note_offset = note_store_client_find_note_offset;
  iface->find_notes_metadata = note_store_client_find_notes_metadata;
  iface->find_note_counts = note_store_client_find_note_counts;
  iface->get_note_with_result_spec = note_store_client_get_note_with_result_spec;
  iface->get_note = note_store_client_get_note;
  iface->get_note_application_data = note_store_client_get_note_application_data;
  iface->get_note_application_data_entry = note_store_client_get_note_application_data_entry;
  iface->set_note_application_data_entry = note_store_client_set_note_application_data_entry;
  iface->unset_note_application_data_entry = note_store_client_unset_note_application_data_entry;
  iface->get_note_content = note_store_client_get_note_content;
  iface->get_note_search_text = note_store_client_get_note_search_text;
  iface->get_resource_search_text = note_store_client_get_resource_search_text;
  iface->get_note_tag_names = note_store_client_get_note_tag_names;
  iface->create_note = note_store_client_create_note;
  iface->update_note = note_store_client_update_note;
  iface->delete_note = note_store_client_delete_note;
  iface->expunge_note = note_store_client_expunge_note;
  iface->copy_note = note_store_client_copy_note;
  iface->list_note_versions = note_store_client_list_note_versions;
  iface->get_note_version = note_store_client_get_note_version;
  iface->get_resource = note_store_client_get_resource;
  iface->get_resource_application_data = note_store_client_get_resource_application_data;
  iface->get_resource_application_data_entry = note_store_client_get_resource_application_data_entry;
  iface->set_resource_application_data_entry = note_store_client_set_resource_application_data_entry;
  iface->unset_resource_application_data_entry = note_store_client_unset_resource_application_data_entry;
  iface->update_resource = note_store_client_update_resource;
  iface->get_resource_data = note_store_client_get_resource_data;
  iface->get_resource_by_hash = note_store_client_get_resource_by_hash;
  iface->get_resource_recognition = note_store_client_get_resource_recognition;
  iface->get_resource_alternate_data = note_store_client_get_resource_alternate_data;
  iface->get_resource_attributes = note_store_client_get_resource_attributes;
  iface->get_public_notebook = note_store_client_get_public_notebook;
  iface->share_notebook = note_store_client_share_notebook;
  iface->create_or_update_notebook_shares = note_store_client_create_or_update_notebook_shares;
  iface->update_shared_notebook = note_store_client_update_shared_notebook;
  iface->set_notebook_recipient_settings = note_store_client_set_notebook_recipient_settings;
  iface->list_shared_notebooks = note_store_client_list_shared_notebooks;
  iface->create_linked_notebook = note_store_client_create_linked_notebook;
  iface->update_linked_notebook = note_store_client_update_linked_notebook;
  iface->list_linked_notebooks = note_store_client_list_linked_notebooks;
  iface->expunge_linked_notebook = note_store_client_expunge_linked_notebook;
  iface->authenticate_to_shared_notebook = note_store_client_authenticate_to_shared_notebook;
  iface->get_shared_notebook_by_auth = note_store_client_get_shared_notebook_by_auth;
  iface->email_note = note_store_client_email_note;
  iface->share_note = note_store_client_share_note;
  iface->stop_sharing_note = note_store_client_stop_sharing_note;
  iface->authenticate_to_shared_note = note_store_client_authenticate_to_shared_note;
  iface->find_related = note_store_client_find_related;
  iface->update_note_if_usn_matches = note_store_client_update_note_if_usn_matches;
  iface->manage_notebook_shares = note_store_client_manage_notebook_shares;
  iface->get_notebook_shares = note_store_client_get_notebook_shares;
}

static void
note_store_client_init (NoteStoreClient *client)
{
  client->input_protocol = NULL;
  client->output_protocol = NULL;
}

static void
note_store_client_class_init (NoteStoreClientClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->set_property = note_store_client_set_property;
  gobject_class->get_property = note_store_client_get_property;

  param_spec = g_param_spec_object ("input_protocol",
                                    "input protocol (construct)",
                                    "Set the client input protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_NOTE_STORE_CLIENT_INPUT_PROTOCOL, param_spec);

  param_spec = g_param_spec_object ("output_protocol",
                                    "output protocol (construct)",
                                    "Set the client output protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_NOTE_STORE_CLIENT_OUTPUT_PROTOCOL, param_spec);
}

static void
note_store_handler_note_store_if_interface_init (NoteStoreIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (NoteStoreHandler, 
                         note_store_handler,
                         G_TYPE_OBJECT,
                         G_IMPLEMENT_INTERFACE (TYPE_NOTE_STORE_IF,
                                                note_store_handler_note_store_if_interface_init))

gboolean note_store_handler_get_sync_state (NoteStoreIf * iface, SyncState ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_sync_state (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean note_store_handler_get_filtered_sync_chunk (NoteStoreIf * iface, SyncChunk ** _return, const gchar * authenticationToken, const gint32 afterUSN, const gint32 maxEntries, const SyncChunkFilter * filter, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_filtered_sync_chunk (iface, _return, authenticationToken, afterUSN, maxEntries, filter, userException, systemException, error);
}

gboolean note_store_handler_get_linked_notebook_sync_state (NoteStoreIf * iface, SyncState ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_linked_notebook_sync_state (iface, _return, authenticationToken, linkedNotebook, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_linked_notebook_sync_chunk (NoteStoreIf * iface, SyncChunk ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, const gint32 afterUSN, const gint32 maxEntries, const gboolean fullSyncOnly, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_linked_notebook_sync_chunk (iface, _return, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_list_notebooks (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->list_notebooks (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean note_store_handler_list_accessible_business_notebooks (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->list_accessible_business_notebooks (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean note_store_handler_get_notebook (NoteStoreIf * iface, Notebook ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_notebook (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_default_notebook (NoteStoreIf * iface, Notebook ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_default_notebook (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean note_store_handler_create_notebook (NoteStoreIf * iface, Notebook ** _return, const gchar * authenticationToken, const Notebook * notebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->create_notebook (iface, _return, authenticationToken, notebook, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_update_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Notebook * notebook, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->update_notebook (iface, _return, authenticationToken, notebook, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_expunge_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->expunge_notebook (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_list_tags (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->list_tags (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean note_store_handler_list_tags_by_notebook (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid notebookGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->list_tags_by_notebook (iface, _return, authenticationToken, notebookGuid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_tag (NoteStoreIf * iface, Tag ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_tag (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_create_tag (NoteStoreIf * iface, Tag ** _return, const gchar * authenticationToken, const Tag * tag, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->create_tag (iface, _return, authenticationToken, tag, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_update_tag (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Tag * tag, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->update_tag (iface, _return, authenticationToken, tag, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_untag_all (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->untag_all (iface, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_expunge_tag (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->expunge_tag (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_list_searches (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->list_searches (iface, _return, authenticationToken, userException, systemException, error);
}

gboolean note_store_handler_get_search (NoteStoreIf * iface, SavedSearch ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_search (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_create_search (NoteStoreIf * iface, SavedSearch ** _return, const gchar * authenticationToken, const SavedSearch * search, EDAMUserException ** userException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->create_search (iface, _return, authenticationToken, search, userException, systemException, error);
}

gboolean note_store_handler_update_search (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const SavedSearch * search, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->update_search (iface, _return, authenticationToken, search, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_expunge_search (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->expunge_search (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_find_note_offset (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const NoteFilter * filter, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->find_note_offset (iface, _return, authenticationToken, filter, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_find_notes_metadata (NoteStoreIf * iface, NotesMetadataList ** _return, const gchar * authenticationToken, const NoteFilter * filter, const gint32 offset, const gint32 maxNotes, const NotesMetadataResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->find_notes_metadata (iface, _return, authenticationToken, filter, offset, maxNotes, resultSpec, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_find_note_counts (NoteStoreIf * iface, NoteCollectionCounts ** _return, const gchar * authenticationToken, const NoteFilter * filter, const gboolean withTrash, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->find_note_counts (iface, _return, authenticationToken, filter, withTrash, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_note_with_result_spec (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Guid guid, const NoteResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_note_with_result_spec (iface, _return, authenticationToken, guid, resultSpec, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_note (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Guid guid, const gboolean withContent, const gboolean withResourcesData, const gboolean withResourcesRecognition, const gboolean withResourcesAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_note (iface, _return, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_note_application_data (NoteStoreIf * iface, LazyMap ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_note_application_data (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_note_application_data_entry (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_note_application_data_entry (iface, _return, authenticationToken, guid, key, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_set_note_application_data_entry (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, const gchar * value, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->set_note_application_data_entry (iface, _return, authenticationToken, guid, key, value, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_unset_note_application_data_entry (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->unset_note_application_data_entry (iface, _return, authenticationToken, guid, key, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_note_content (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_note_content (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_note_search_text (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gboolean noteOnly, const gboolean tokenizeForIndexing, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_note_search_text (iface, _return, authenticationToken, guid, noteOnly, tokenizeForIndexing, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource_search_text (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource_search_text (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_note_tag_names (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_note_tag_names (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_create_note (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->create_note (iface, _return, authenticationToken, note, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_update_note (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->update_note (iface, _return, authenticationToken, note, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_delete_note (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->delete_note (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_expunge_note (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->expunge_note (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_copy_note (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Guid noteGuid, const Guid toNotebookGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->copy_note (iface, _return, authenticationToken, noteGuid, toNotebookGuid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_list_note_versions (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, const Guid noteGuid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->list_note_versions (iface, _return, authenticationToken, noteGuid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_note_version (NoteStoreIf * iface, Note ** _return, const gchar * authenticationToken, const Guid noteGuid, const gint32 updateSequenceNum, const gboolean withResourcesData, const gboolean withResourcesRecognition, const gboolean withResourcesAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_note_version (iface, _return, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource (NoteStoreIf * iface, Resource ** _return, const gchar * authenticationToken, const Guid guid, const gboolean withData, const gboolean withRecognition, const gboolean withAttributes, const gboolean withAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource (iface, _return, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource_application_data (NoteStoreIf * iface, LazyMap ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource_application_data (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource_application_data_entry (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource_application_data_entry (iface, _return, authenticationToken, guid, key, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_set_resource_application_data_entry (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, const gchar * value, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->set_resource_application_data_entry (iface, _return, authenticationToken, guid, key, value, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_unset_resource_application_data_entry (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, const gchar * key, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->unset_resource_application_data_entry (iface, _return, authenticationToken, guid, key, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_update_resource (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Resource * resource, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->update_resource (iface, _return, authenticationToken, resource, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource_data (NoteStoreIf * iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource_data (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource_by_hash (NoteStoreIf * iface, Resource ** _return, const gchar * authenticationToken, const Guid noteGuid, const GByteArray * contentHash, const gboolean withData, const gboolean withRecognition, const gboolean withAlternateData, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource_by_hash (iface, _return, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource_recognition (NoteStoreIf * iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource_recognition (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource_alternate_data (NoteStoreIf * iface, GByteArray ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource_alternate_data (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_resource_attributes (NoteStoreIf * iface, ResourceAttributes ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_resource_attributes (iface, _return, authenticationToken, guid, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_get_public_notebook (NoteStoreIf * iface, Notebook ** _return, const UserID userId, const gchar * publicUri, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_public_notebook (iface, _return, userId, publicUri, systemException, notFoundException, error);
}

gboolean note_store_handler_share_notebook (NoteStoreIf * iface, SharedNotebook ** _return, const gchar * authenticationToken, const SharedNotebook * sharedNotebook, const gchar * message, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->share_notebook (iface, _return, authenticationToken, sharedNotebook, message, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_create_or_update_notebook_shares (NoteStoreIf * iface, CreateOrUpdateNotebookSharesResult ** _return, const gchar * authenticationToken, const NotebookShareTemplate * shareTemplate, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, EDAMInvalidContactsException ** invalidContactsException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->create_or_update_notebook_shares (iface, _return, authenticationToken, shareTemplate, userException, notFoundException, systemException, invalidContactsException, error);
}

gboolean note_store_handler_update_shared_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const SharedNotebook * sharedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->update_shared_notebook (iface, _return, authenticationToken, sharedNotebook, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_set_notebook_recipient_settings (NoteStoreIf * iface, Notebook ** _return, const gchar * authenticationToken, const gchar * notebookGuid, const NotebookRecipientSettings * recipientSettings, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->set_notebook_recipient_settings (iface, _return, authenticationToken, notebookGuid, recipientSettings, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_list_shared_notebooks (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->list_shared_notebooks (iface, _return, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_create_linked_notebook (NoteStoreIf * iface, LinkedNotebook ** _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->create_linked_notebook (iface, _return, authenticationToken, linkedNotebook, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_update_linked_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const LinkedNotebook * linkedNotebook, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->update_linked_notebook (iface, _return, authenticationToken, linkedNotebook, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_list_linked_notebooks (NoteStoreIf * iface, GPtrArray ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->list_linked_notebooks (iface, _return, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_expunge_linked_notebook (NoteStoreIf * iface, gint32* _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->expunge_linked_notebook (iface, _return, authenticationToken, guid, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_authenticate_to_shared_notebook (NoteStoreIf * iface, AuthenticationResult ** _return, const gchar * shareKeyOrGlobalId, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->authenticate_to_shared_notebook (iface, _return, shareKeyOrGlobalId, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_get_shared_notebook_by_auth (NoteStoreIf * iface, SharedNotebook ** _return, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_shared_notebook_by_auth (iface, _return, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_email_note (NoteStoreIf * iface, const gchar * authenticationToken, const NoteEmailParameters * parameters, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->email_note (iface, authenticationToken, parameters, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_share_note (NoteStoreIf * iface, gchar ** _return, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->share_note (iface, _return, authenticationToken, guid, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_stop_sharing_note (NoteStoreIf * iface, const gchar * authenticationToken, const Guid guid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->stop_sharing_note (iface, authenticationToken, guid, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_authenticate_to_shared_note (NoteStoreIf * iface, AuthenticationResult ** _return, const gchar * guid, const gchar * noteKey, const gchar * authenticationToken, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->authenticate_to_shared_note (iface, _return, guid, noteKey, authenticationToken, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_find_related (NoteStoreIf * iface, RelatedResult ** _return, const gchar * authenticationToken, const RelatedQuery * query, const RelatedResultSpec * resultSpec, EDAMUserException ** userException, EDAMSystemException ** systemException, EDAMNotFoundException ** notFoundException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->find_related (iface, _return, authenticationToken, query, resultSpec, userException, systemException, notFoundException, error);
}

gboolean note_store_handler_update_note_if_usn_matches (NoteStoreIf * iface, UpdateNoteIfUsnMatchesResult ** _return, const gchar * authenticationToken, const Note * note, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->update_note_if_usn_matches (iface, _return, authenticationToken, note, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_manage_notebook_shares (NoteStoreIf * iface, ManageNotebookSharesResult ** _return, const gchar * authenticationToken, const ManageNotebookSharesParameters * parameters, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->manage_notebook_shares (iface, _return, authenticationToken, parameters, userException, notFoundException, systemException, error);
}

gboolean note_store_handler_get_notebook_shares (NoteStoreIf * iface, ShareRelationships ** _return, const gchar * authenticationToken, const gchar * notebookGuid, EDAMUserException ** userException, EDAMNotFoundException ** notFoundException, EDAMSystemException ** systemException, GError ** error)
{
  g_return_val_if_fail (IS_NOTE_STORE_HANDLER (iface), FALSE);

  return NOTE_STORE_HANDLER_GET_CLASS (iface)->get_notebook_shares (iface, _return, authenticationToken, notebookGuid, userException, notFoundException, systemException, error);
}

static void
note_store_handler_note_store_if_interface_init (NoteStoreIfInterface *iface)
{
  iface->get_sync_state = note_store_handler_get_sync_state;
  iface->get_filtered_sync_chunk = note_store_handler_get_filtered_sync_chunk;
  iface->get_linked_notebook_sync_state = note_store_handler_get_linked_notebook_sync_state;
  iface->get_linked_notebook_sync_chunk = note_store_handler_get_linked_notebook_sync_chunk;
  iface->list_notebooks = note_store_handler_list_notebooks;
  iface->list_accessible_business_notebooks = note_store_handler_list_accessible_business_notebooks;
  iface->get_notebook = note_store_handler_get_notebook;
  iface->get_default_notebook = note_store_handler_get_default_notebook;
  iface->create_notebook = note_store_handler_create_notebook;
  iface->update_notebook = note_store_handler_update_notebook;
  iface->expunge_notebook = note_store_handler_expunge_notebook;
  iface->list_tags = note_store_handler_list_tags;
  iface->list_tags_by_notebook = note_store_handler_list_tags_by_notebook;
  iface->get_tag = note_store_handler_get_tag;
  iface->create_tag = note_store_handler_create_tag;
  iface->update_tag = note_store_handler_update_tag;
  iface->untag_all = note_store_handler_untag_all;
  iface->expunge_tag = note_store_handler_expunge_tag;
  iface->list_searches = note_store_handler_list_searches;
  iface->get_search = note_store_handler_get_search;
  iface->create_search = note_store_handler_create_search;
  iface->update_search = note_store_handler_update_search;
  iface->expunge_search = note_store_handler_expunge_search;
  iface->find_note_offset = note_store_handler_find_note_offset;
  iface->find_notes_metadata = note_store_handler_find_notes_metadata;
  iface->find_note_counts = note_store_handler_find_note_counts;
  iface->get_note_with_result_spec = note_store_handler_get_note_with_result_spec;
  iface->get_note = note_store_handler_get_note;
  iface->get_note_application_data = note_store_handler_get_note_application_data;
  iface->get_note_application_data_entry = note_store_handler_get_note_application_data_entry;
  iface->set_note_application_data_entry = note_store_handler_set_note_application_data_entry;
  iface->unset_note_application_data_entry = note_store_handler_unset_note_application_data_entry;
  iface->get_note_content = note_store_handler_get_note_content;
  iface->get_note_search_text = note_store_handler_get_note_search_text;
  iface->get_resource_search_text = note_store_handler_get_resource_search_text;
  iface->get_note_tag_names = note_store_handler_get_note_tag_names;
  iface->create_note = note_store_handler_create_note;
  iface->update_note = note_store_handler_update_note;
  iface->delete_note = note_store_handler_delete_note;
  iface->expunge_note = note_store_handler_expunge_note;
  iface->copy_note = note_store_handler_copy_note;
  iface->list_note_versions = note_store_handler_list_note_versions;
  iface->get_note_version = note_store_handler_get_note_version;
  iface->get_resource = note_store_handler_get_resource;
  iface->get_resource_application_data = note_store_handler_get_resource_application_data;
  iface->get_resource_application_data_entry = note_store_handler_get_resource_application_data_entry;
  iface->set_resource_application_data_entry = note_store_handler_set_resource_application_data_entry;
  iface->unset_resource_application_data_entry = note_store_handler_unset_resource_application_data_entry;
  iface->update_resource = note_store_handler_update_resource;
  iface->get_resource_data = note_store_handler_get_resource_data;
  iface->get_resource_by_hash = note_store_handler_get_resource_by_hash;
  iface->get_resource_recognition = note_store_handler_get_resource_recognition;
  iface->get_resource_alternate_data = note_store_handler_get_resource_alternate_data;
  iface->get_resource_attributes = note_store_handler_get_resource_attributes;
  iface->get_public_notebook = note_store_handler_get_public_notebook;
  iface->share_notebook = note_store_handler_share_notebook;
  iface->create_or_update_notebook_shares = note_store_handler_create_or_update_notebook_shares;
  iface->update_shared_notebook = note_store_handler_update_shared_notebook;
  iface->set_notebook_recipient_settings = note_store_handler_set_notebook_recipient_settings;
  iface->list_shared_notebooks = note_store_handler_list_shared_notebooks;
  iface->create_linked_notebook = note_store_handler_create_linked_notebook;
  iface->update_linked_notebook = note_store_handler_update_linked_notebook;
  iface->list_linked_notebooks = note_store_handler_list_linked_notebooks;
  iface->expunge_linked_notebook = note_store_handler_expunge_linked_notebook;
  iface->authenticate_to_shared_notebook = note_store_handler_authenticate_to_shared_notebook;
  iface->get_shared_notebook_by_auth = note_store_handler_get_shared_notebook_by_auth;
  iface->email_note = note_store_handler_email_note;
  iface->share_note = note_store_handler_share_note;
  iface->stop_sharing_note = note_store_handler_stop_sharing_note;
  iface->authenticate_to_shared_note = note_store_handler_authenticate_to_shared_note;
  iface->find_related = note_store_handler_find_related;
  iface->update_note_if_usn_matches = note_store_handler_update_note_if_usn_matches;
  iface->manage_notebook_shares = note_store_handler_manage_notebook_shares;
  iface->get_notebook_shares = note_store_handler_get_notebook_shares;
}

static void
note_store_handler_init (NoteStoreHandler *self)
{
  THRIFT_UNUSED_VAR (self);
}

static void
note_store_handler_class_init (NoteStoreHandlerClass *cls)
{
  cls->get_sync_state = NULL;
  cls->get_filtered_sync_chunk = NULL;
  cls->get_linked_notebook_sync_state = NULL;
  cls->get_linked_notebook_sync_chunk = NULL;
  cls->list_notebooks = NULL;
  cls->list_accessible_business_notebooks = NULL;
  cls->get_notebook = NULL;
  cls->get_default_notebook = NULL;
  cls->create_notebook = NULL;
  cls->update_notebook = NULL;
  cls->expunge_notebook = NULL;
  cls->list_tags = NULL;
  cls->list_tags_by_notebook = NULL;
  cls->get_tag = NULL;
  cls->create_tag = NULL;
  cls->update_tag = NULL;
  cls->untag_all = NULL;
  cls->expunge_tag = NULL;
  cls->list_searches = NULL;
  cls->get_search = NULL;
  cls->create_search = NULL;
  cls->update_search = NULL;
  cls->expunge_search = NULL;
  cls->find_note_offset = NULL;
  cls->find_notes_metadata = NULL;
  cls->find_note_counts = NULL;
  cls->get_note_with_result_spec = NULL;
  cls->get_note = NULL;
  cls->get_note_application_data = NULL;
  cls->get_note_application_data_entry = NULL;
  cls->set_note_application_data_entry = NULL;
  cls->unset_note_application_data_entry = NULL;
  cls->get_note_content = NULL;
  cls->get_note_search_text = NULL;
  cls->get_resource_search_text = NULL;
  cls->get_note_tag_names = NULL;
  cls->create_note = NULL;
  cls->update_note = NULL;
  cls->delete_note = NULL;
  cls->expunge_note = NULL;
  cls->copy_note = NULL;
  cls->list_note_versions = NULL;
  cls->get_note_version = NULL;
  cls->get_resource = NULL;
  cls->get_resource_application_data = NULL;
  cls->get_resource_application_data_entry = NULL;
  cls->set_resource_application_data_entry = NULL;
  cls->unset_resource_application_data_entry = NULL;
  cls->update_resource = NULL;
  cls->get_resource_data = NULL;
  cls->get_resource_by_hash = NULL;
  cls->get_resource_recognition = NULL;
  cls->get_resource_alternate_data = NULL;
  cls->get_resource_attributes = NULL;
  cls->get_public_notebook = NULL;
  cls->share_notebook = NULL;
  cls->create_or_update_notebook_shares = NULL;
  cls->update_shared_notebook = NULL;
  cls->set_notebook_recipient_settings = NULL;
  cls->list_shared_notebooks = NULL;
  cls->create_linked_notebook = NULL;
  cls->update_linked_notebook = NULL;
  cls->list_linked_notebooks = NULL;
  cls->expunge_linked_notebook = NULL;
  cls->authenticate_to_shared_notebook = NULL;
  cls->get_shared_notebook_by_auth = NULL;
  cls->email_note = NULL;
  cls->share_note = NULL;
  cls->stop_sharing_note = NULL;
  cls->authenticate_to_shared_note = NULL;
  cls->find_related = NULL;
  cls->update_note_if_usn_matches = NULL;
  cls->manage_notebook_shares = NULL;
  cls->get_notebook_shares = NULL;
}

enum _NoteStoreProcessorProperties
{
  PROP_NOTE_STORE_PROCESSOR_0,
  PROP_NOTE_STORE_PROCESSOR_HANDLER
};

G_DEFINE_TYPE (NoteStoreProcessor,
               note_store_processor,
               THRIFT_TYPE_DISPATCH_PROCESSOR)

typedef gboolean (* NoteStoreProcessorProcessFunction) (NoteStoreProcessor *, 
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);

typedef struct
{
  gchar *name;
  NoteStoreProcessorProcessFunction function;
} note_store_processor_process_function_def;

static gboolean
note_store_processor_process_get_sync_state (NoteStoreProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
note_store_processor_process_get_filtered_sync_chunk (NoteStoreProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
note_store_processor_process_get_linked_notebook_sync_state (NoteStoreProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
note_store_processor_process_get_linked_notebook_sync_chunk (NoteStoreProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
note_store_processor_process_list_notebooks (NoteStoreProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
note_store_processor_process_list_accessible_business_notebooks (NoteStoreProcessor *,
                                                                 gint32,
                                                                 ThriftProtocol *,
                                                                 ThriftProtocol *,
                                                                 GError **);
static gboolean
note_store_processor_process_get_notebook (NoteStoreProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
note_store_processor_process_get_default_notebook (NoteStoreProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
note_store_processor_process_create_notebook (NoteStoreProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
note_store_processor_process_update_notebook (NoteStoreProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
note_store_processor_process_expunge_notebook (NoteStoreProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
note_store_processor_process_list_tags (NoteStoreProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
note_store_processor_process_list_tags_by_notebook (NoteStoreProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
note_store_processor_process_get_tag (NoteStoreProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
note_store_processor_process_create_tag (NoteStoreProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
note_store_processor_process_update_tag (NoteStoreProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
note_store_processor_process_untag_all (NoteStoreProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
note_store_processor_process_expunge_tag (NoteStoreProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
note_store_processor_process_list_searches (NoteStoreProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
note_store_processor_process_get_search (NoteStoreProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
note_store_processor_process_create_search (NoteStoreProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
note_store_processor_process_update_search (NoteStoreProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
note_store_processor_process_expunge_search (NoteStoreProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
note_store_processor_process_find_note_offset (NoteStoreProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
note_store_processor_process_find_notes_metadata (NoteStoreProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
note_store_processor_process_find_note_counts (NoteStoreProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
note_store_processor_process_get_note_with_result_spec (NoteStoreProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
note_store_processor_process_get_note (NoteStoreProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
note_store_processor_process_get_note_application_data (NoteStoreProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
note_store_processor_process_get_note_application_data_entry (NoteStoreProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
note_store_processor_process_set_note_application_data_entry (NoteStoreProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
note_store_processor_process_unset_note_application_data_entry (NoteStoreProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
note_store_processor_process_get_note_content (NoteStoreProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
note_store_processor_process_get_note_search_text (NoteStoreProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
note_store_processor_process_get_resource_search_text (NoteStoreProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
note_store_processor_process_get_note_tag_names (NoteStoreProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
note_store_processor_process_create_note (NoteStoreProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
note_store_processor_process_update_note (NoteStoreProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
note_store_processor_process_delete_note (NoteStoreProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
note_store_processor_process_expunge_note (NoteStoreProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
note_store_processor_process_copy_note (NoteStoreProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
note_store_processor_process_list_note_versions (NoteStoreProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
note_store_processor_process_get_note_version (NoteStoreProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
note_store_processor_process_get_resource (NoteStoreProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
note_store_processor_process_get_resource_application_data (NoteStoreProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
note_store_processor_process_get_resource_application_data_entry (NoteStoreProcessor *,
                                                                  gint32,
                                                                  ThriftProtocol *,
                                                                  ThriftProtocol *,
                                                                  GError **);
static gboolean
note_store_processor_process_set_resource_application_data_entry (NoteStoreProcessor *,
                                                                  gint32,
                                                                  ThriftProtocol *,
                                                                  ThriftProtocol *,
                                                                  GError **);
static gboolean
note_store_processor_process_unset_resource_application_data_entry (NoteStoreProcessor *,
                                                                    gint32,
                                                                    ThriftProtocol *,
                                                                    ThriftProtocol *,
                                                                    GError **);
static gboolean
note_store_processor_process_update_resource (NoteStoreProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
note_store_processor_process_get_resource_data (NoteStoreProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
note_store_processor_process_get_resource_by_hash (NoteStoreProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
note_store_processor_process_get_resource_recognition (NoteStoreProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
note_store_processor_process_get_resource_alternate_data (NoteStoreProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
note_store_processor_process_get_resource_attributes (NoteStoreProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
note_store_processor_process_get_public_notebook (NoteStoreProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
note_store_processor_process_share_notebook (NoteStoreProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
note_store_processor_process_create_or_update_notebook_shares (NoteStoreProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
note_store_processor_process_update_shared_notebook (NoteStoreProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
note_store_processor_process_set_notebook_recipient_settings (NoteStoreProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
note_store_processor_process_list_shared_notebooks (NoteStoreProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
note_store_processor_process_create_linked_notebook (NoteStoreProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
note_store_processor_process_update_linked_notebook (NoteStoreProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
note_store_processor_process_list_linked_notebooks (NoteStoreProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
note_store_processor_process_expunge_linked_notebook (NoteStoreProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
note_store_processor_process_authenticate_to_shared_notebook (NoteStoreProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
note_store_processor_process_get_shared_notebook_by_auth (NoteStoreProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
note_store_processor_process_email_note (NoteStoreProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
note_store_processor_process_share_note (NoteStoreProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
note_store_processor_process_stop_sharing_note (NoteStoreProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
note_store_processor_process_authenticate_to_shared_note (NoteStoreProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
note_store_processor_process_find_related (NoteStoreProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
note_store_processor_process_update_note_if_usn_matches (NoteStoreProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
note_store_processor_process_manage_notebook_shares (NoteStoreProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
note_store_processor_process_get_notebook_shares (NoteStoreProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);

static note_store_processor_process_function_def
note_store_processor_process_function_defs[74] = {
  {
    "getSyncState",
    note_store_processor_process_get_sync_state
  },
  {
    "getFilteredSyncChunk",
    note_store_processor_process_get_filtered_sync_chunk
  },
  {
    "getLinkedNotebookSyncState",
    note_store_processor_process_get_linked_notebook_sync_state
  },
  {
    "getLinkedNotebookSyncChunk",
    note_store_processor_process_get_linked_notebook_sync_chunk
  },
  {
    "listNotebooks",
    note_store_processor_process_list_notebooks
  },
  {
    "listAccessibleBusinessNotebooks",
    note_store_processor_process_list_accessible_business_notebooks
  },
  {
    "getNotebook",
    note_store_processor_process_get_notebook
  },
  {
    "getDefaultNotebook",
    note_store_processor_process_get_default_notebook
  },
  {
    "createNotebook",
    note_store_processor_process_create_notebook
  },
  {
    "updateNotebook",
    note_store_processor_process_update_notebook
  },
  {
    "expungeNotebook",
    note_store_processor_process_expunge_notebook
  },
  {
    "listTags",
    note_store_processor_process_list_tags
  },
  {
    "listTagsByNotebook",
    note_store_processor_process_list_tags_by_notebook
  },
  {
    "getTag",
    note_store_processor_process_get_tag
  },
  {
    "createTag",
    note_store_processor_process_create_tag
  },
  {
    "updateTag",
    note_store_processor_process_update_tag
  },
  {
    "untagAll",
    note_store_processor_process_untag_all
  },
  {
    "expungeTag",
    note_store_processor_process_expunge_tag
  },
  {
    "listSearches",
    note_store_processor_process_list_searches
  },
  {
    "getSearch",
    note_store_processor_process_get_search
  },
  {
    "createSearch",
    note_store_processor_process_create_search
  },
  {
    "updateSearch",
    note_store_processor_process_update_search
  },
  {
    "expungeSearch",
    note_store_processor_process_expunge_search
  },
  {
    "findNoteOffset",
    note_store_processor_process_find_note_offset
  },
  {
    "findNotesMetadata",
    note_store_processor_process_find_notes_metadata
  },
  {
    "findNoteCounts",
    note_store_processor_process_find_note_counts
  },
  {
    "getNoteWithResultSpec",
    note_store_processor_process_get_note_with_result_spec
  },
  {
    "getNote",
    note_store_processor_process_get_note
  },
  {
    "getNoteApplicationData",
    note_store_processor_process_get_note_application_data
  },
  {
    "getNoteApplicationDataEntry",
    note_store_processor_process_get_note_application_data_entry
  },
  {
    "setNoteApplicationDataEntry",
    note_store_processor_process_set_note_application_data_entry
  },
  {
    "unsetNoteApplicationDataEntry",
    note_store_processor_process_unset_note_application_data_entry
  },
  {
    "getNoteContent",
    note_store_processor_process_get_note_content
  },
  {
    "getNoteSearchText",
    note_store_processor_process_get_note_search_text
  },
  {
    "getResourceSearchText",
    note_store_processor_process_get_resource_search_text
  },
  {
    "getNoteTagNames",
    note_store_processor_process_get_note_tag_names
  },
  {
    "createNote",
    note_store_processor_process_create_note
  },
  {
    "updateNote",
    note_store_processor_process_update_note
  },
  {
    "deleteNote",
    note_store_processor_process_delete_note
  },
  {
    "expungeNote",
    note_store_processor_process_expunge_note
  },
  {
    "copyNote",
    note_store_processor_process_copy_note
  },
  {
    "listNoteVersions",
    note_store_processor_process_list_note_versions
  },
  {
    "getNoteVersion",
    note_store_processor_process_get_note_version
  },
  {
    "getResource",
    note_store_processor_process_get_resource
  },
  {
    "getResourceApplicationData",
    note_store_processor_process_get_resource_application_data
  },
  {
    "getResourceApplicationDataEntry",
    note_store_processor_process_get_resource_application_data_entry
  },
  {
    "setResourceApplicationDataEntry",
    note_store_processor_process_set_resource_application_data_entry
  },
  {
    "unsetResourceApplicationDataEntry",
    note_store_processor_process_unset_resource_application_data_entry
  },
  {
    "updateResource",
    note_store_processor_process_update_resource
  },
  {
    "getResourceData",
    note_store_processor_process_get_resource_data
  },
  {
    "getResourceByHash",
    note_store_processor_process_get_resource_by_hash
  },
  {
    "getResourceRecognition",
    note_store_processor_process_get_resource_recognition
  },
  {
    "getResourceAlternateData",
    note_store_processor_process_get_resource_alternate_data
  },
  {
    "getResourceAttributes",
    note_store_processor_process_get_resource_attributes
  },
  {
    "getPublicNotebook",
    note_store_processor_process_get_public_notebook
  },
  {
    "shareNotebook",
    note_store_processor_process_share_notebook
  },
  {
    "createOrUpdateNotebookShares",
    note_store_processor_process_create_or_update_notebook_shares
  },
  {
    "updateSharedNotebook",
    note_store_processor_process_update_shared_notebook
  },
  {
    "setNotebookRecipientSettings",
    note_store_processor_process_set_notebook_recipient_settings
  },
  {
    "listSharedNotebooks",
    note_store_processor_process_list_shared_notebooks
  },
  {
    "createLinkedNotebook",
    note_store_processor_process_create_linked_notebook
  },
  {
    "updateLinkedNotebook",
    note_store_processor_process_update_linked_notebook
  },
  {
    "listLinkedNotebooks",
    note_store_processor_process_list_linked_notebooks
  },
  {
    "expungeLinkedNotebook",
    note_store_processor_process_expunge_linked_notebook
  },
  {
    "authenticateToSharedNotebook",
    note_store_processor_process_authenticate_to_shared_notebook
  },
  {
    "getSharedNotebookByAuth",
    note_store_processor_process_get_shared_notebook_by_auth
  },
  {
    "emailNote",
    note_store_processor_process_email_note
  },
  {
    "shareNote",
    note_store_processor_process_share_note
  },
  {
    "stopSharingNote",
    note_store_processor_process_stop_sharing_note
  },
  {
    "authenticateToSharedNote",
    note_store_processor_process_authenticate_to_shared_note
  },
  {
    "findRelated",
    note_store_processor_process_find_related
  },
  {
    "updateNoteIfUsnMatches",
    note_store_processor_process_update_note_if_usn_matches
  },
  {
    "manageNotebookShares",
    note_store_processor_process_manage_notebook_shares
  },
  {
    "getNotebookShares",
    note_store_processor_process_get_notebook_shares
  }
};

static gboolean
note_store_processor_process_get_sync_state (NoteStoreProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetSyncStateArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_SYNC_STATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    SyncState * return_value;
    NoteStoreGetSyncStateResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_SYNC_STATE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_sync_state (NOTE_STORE_IF (self->handler),
                                           &return_value,
                                           authenticationToken,
                                           &user_exception,
                                           &system_exception,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getSyncState",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSyncState",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSyncState",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getSyncState implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSyncState",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_filtered_sync_chunk (NoteStoreProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetFilteredSyncChunkArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    gint afterUSN;
    gint maxEntries;
    SyncChunkFilter * filter;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    SyncChunk * return_value;
    NoteStoreGetFilteredSyncChunkResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "afterUSN", &afterUSN,
                  "maxEntries", &maxEntries,
                  "filter", &filter,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_FILTERED_SYNC_CHUNK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_filtered_sync_chunk (NOTE_STORE_IF (self->handler),
                                                    &return_value,
                                                    authenticationToken,
                                                    afterUSN,
                                                    maxEntries,
                                                    filter,
                                                    &user_exception,
                                                    &system_exception,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFilteredSyncChunk",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFilteredSyncChunk",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFilteredSyncChunk",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getFilteredSyncChunk implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFilteredSyncChunk",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (filter != NULL)
      g_object_unref (filter);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_linked_notebook_sync_state (NoteStoreProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetLinkedNotebookSyncStateArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    LinkedNotebook * linkedNotebook;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    SyncState * return_value;
    NoteStoreGetLinkedNotebookSyncStateResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "linkedNotebook", &linkedNotebook,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_STATE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_linked_notebook_sync_state (NOTE_STORE_IF (self->handler),
                                                           &return_value,
                                                           authenticationToken,
                                                           linkedNotebook,
                                                           &user_exception,
                                                           &system_exception,
                                                           &not_found_exception,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getLinkedNotebookSyncState",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLinkedNotebookSyncState",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLinkedNotebookSyncState",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLinkedNotebookSyncState",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getLinkedNotebookSyncState implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLinkedNotebookSyncState",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (linkedNotebook != NULL)
      g_object_unref (linkedNotebook);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_linked_notebook_sync_chunk (NoteStoreProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetLinkedNotebookSyncChunkArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    LinkedNotebook * linkedNotebook;
    gint afterUSN;
    gint maxEntries;
    gboolean fullSyncOnly;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    SyncChunk * return_value;
    NoteStoreGetLinkedNotebookSyncChunkResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "linkedNotebook", &linkedNotebook,
                  "afterUSN", &afterUSN,
                  "maxEntries", &maxEntries,
                  "fullSyncOnly", &fullSyncOnly,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_LINKED_NOTEBOOK_SYNC_CHUNK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_linked_notebook_sync_chunk (NOTE_STORE_IF (self->handler),
                                                           &return_value,
                                                           authenticationToken,
                                                           linkedNotebook,
                                                           afterUSN,
                                                           maxEntries,
                                                           fullSyncOnly,
                                                           &user_exception,
                                                           &system_exception,
                                                           &not_found_exception,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getLinkedNotebookSyncChunk",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLinkedNotebookSyncChunk",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLinkedNotebookSyncChunk",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLinkedNotebookSyncChunk",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getLinkedNotebookSyncChunk implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLinkedNotebookSyncChunk",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (linkedNotebook != NULL)
      g_object_unref (linkedNotebook);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_list_notebooks (NoteStoreProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreListNotebooksArgs * args =
    g_object_new (TYPE_NOTE_STORE_LIST_NOTEBOOKS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    GPtrArray * return_value;
    NoteStoreListNotebooksResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_LIST_NOTEBOOKS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_list_notebooks (NOTE_STORE_IF (self->handler),
                                           &return_value,
                                           authenticationToken,
                                           &user_exception,
                                           &system_exception,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listNotebooks",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.listNotebooks implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listNotebooks",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_list_accessible_business_notebooks (NoteStoreProcessor *self,
                                                                 gint32 sequence_id,
                                                                 ThriftProtocol *input_protocol,
                                                                 ThriftProtocol *output_protocol,
                                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreListAccessibleBusinessNotebooksArgs * args =
    g_object_new (TYPE_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    GPtrArray * return_value;
    NoteStoreListAccessibleBusinessNotebooksResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_LIST_ACCESSIBLE_BUSINESS_NOTEBOOKS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_list_accessible_business_notebooks (NOTE_STORE_IF (self->handler),
                                                               &return_value,
                                                               authenticationToken,
                                                               &user_exception,
                                                               &system_exception,
                                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listAccessibleBusinessNotebooks",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listAccessibleBusinessNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listAccessibleBusinessNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.listAccessibleBusinessNotebooks implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listAccessibleBusinessNotebooks",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_notebook (NoteStoreProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Notebook * return_value;
    NoteStoreGetNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_notebook (NOTE_STORE_IF (self->handler),
                                         &return_value,
                                         authenticationToken,
                                         guid,
                                         &user_exception,
                                         &system_exception,
                                         &not_found_exception,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_default_notebook (NoteStoreProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetDefaultNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_DEFAULT_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    Notebook * return_value;
    NoteStoreGetDefaultNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_DEFAULT_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_default_notebook (NOTE_STORE_IF (self->handler),
                                                 &return_value,
                                                 authenticationToken,
                                                 &user_exception,
                                                 &system_exception,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDefaultNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDefaultNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDefaultNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getDefaultNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDefaultNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_create_notebook (NoteStoreProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreCreateNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_CREATE_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Notebook * notebook;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Notebook * return_value;
    NoteStoreCreateNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "notebook", &notebook,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_CREATE_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_create_notebook (NOTE_STORE_IF (self->handler),
                                            &return_value,
                                            authenticationToken,
                                            notebook,
                                            &user_exception,
                                            &system_exception,
                                            &not_found_exception,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "createNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.createNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (notebook != NULL)
      g_object_unref (notebook);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_update_notebook (NoteStoreProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUpdateNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_UPDATE_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Notebook * notebook;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreUpdateNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "notebook", &notebook,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UPDATE_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_update_notebook (NOTE_STORE_IF (self->handler),
                                            (gint32 *)&return_value,
                                            authenticationToken,
                                            notebook,
                                            &user_exception,
                                            &system_exception,
                                            &not_found_exception,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.updateNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (notebook != NULL)
      g_object_unref (notebook);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_expunge_notebook (NoteStoreProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreExpungeNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_EXPUNGE_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreExpungeNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_EXPUNGE_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_expunge_notebook (NOTE_STORE_IF (self->handler),
                                             (gint32 *)&return_value,
                                             authenticationToken,
                                             guid,
                                             &user_exception,
                                             &system_exception,
                                             &not_found_exception,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "expungeNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.expungeNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_list_tags (NoteStoreProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreListTagsArgs * args =
    g_object_new (TYPE_NOTE_STORE_LIST_TAGS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    GPtrArray * return_value;
    NoteStoreListTagsResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_LIST_TAGS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_list_tags (NOTE_STORE_IF (self->handler),
                                      &return_value,
                                      authenticationToken,
                                      &user_exception,
                                      &system_exception,
                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listTags",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listTags",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listTags",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.listTags implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listTags",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_list_tags_by_notebook (NoteStoreProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreListTagsByNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid notebookGuid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    GPtrArray * return_value;
    NoteStoreListTagsByNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "notebookGuid", &notebookGuid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_LIST_TAGS_BY_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_list_tags_by_notebook (NOTE_STORE_IF (self->handler),
                                                  &return_value,
                                                  authenticationToken,
                                                  notebookGuid,
                                                  &user_exception,
                                                  &system_exception,
                                                  &not_found_exception,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listTagsByNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listTagsByNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listTagsByNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listTagsByNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.listTagsByNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listTagsByNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (notebookGuid != NULL)
      g_free (notebookGuid);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_tag (NoteStoreProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetTagArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_TAG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Tag * return_value;
    NoteStoreGetTagResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_TAG_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_tag (NOTE_STORE_IF (self->handler),
                                    &return_value,
                                    authenticationToken,
                                    guid,
                                    &user_exception,
                                    &system_exception,
                                    &not_found_exception,
                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getTag",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getTag implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getTag",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_create_tag (NoteStoreProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreCreateTagArgs * args =
    g_object_new (TYPE_NOTE_STORE_CREATE_TAG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Tag * tag;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Tag * return_value;
    NoteStoreCreateTagResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "tag", &tag,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_CREATE_TAG_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_create_tag (NOTE_STORE_IF (self->handler),
                                       &return_value,
                                       authenticationToken,
                                       tag,
                                       &user_exception,
                                       &system_exception,
                                       &not_found_exception,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "createTag",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.createTag implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createTag",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (tag != NULL)
      g_object_unref (tag);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_update_tag (NoteStoreProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUpdateTagArgs * args =
    g_object_new (TYPE_NOTE_STORE_UPDATE_TAG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Tag * tag;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreUpdateTagResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "tag", &tag,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UPDATE_TAG_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_update_tag (NOTE_STORE_IF (self->handler),
                                       (gint32 *)&return_value,
                                       authenticationToken,
                                       tag,
                                       &user_exception,
                                       &system_exception,
                                       &not_found_exception,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateTag",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.updateTag implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateTag",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (tag != NULL)
      g_object_unref (tag);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_untag_all (NoteStoreProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUntagAllArgs * args =
    g_object_new (TYPE_NOTE_STORE_UNTAG_ALL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    NoteStoreUntagAllResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UNTAG_ALL_RESULT, NULL);

    if (note_store_handler_untag_all (NOTE_STORE_IF (self->handler),
                                      authenticationToken,
                                      guid,
                                      &user_exception,
                                      &system_exception,
                                      &not_found_exception,
                                      error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "untagAll",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "untagAll",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "untagAll",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "untagAll",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.untagAll implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "untagAll",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_expunge_tag (NoteStoreProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreExpungeTagArgs * args =
    g_object_new (TYPE_NOTE_STORE_EXPUNGE_TAG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreExpungeTagResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_EXPUNGE_TAG_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_expunge_tag (NOTE_STORE_IF (self->handler),
                                        (gint32 *)&return_value,
                                        authenticationToken,
                                        guid,
                                        &user_exception,
                                        &system_exception,
                                        &not_found_exception,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "expungeTag",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeTag",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.expungeTag implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeTag",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_list_searches (NoteStoreProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreListSearchesArgs * args =
    g_object_new (TYPE_NOTE_STORE_LIST_SEARCHES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    GPtrArray * return_value;
    NoteStoreListSearchesResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_LIST_SEARCHES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_list_searches (NOTE_STORE_IF (self->handler),
                                          &return_value,
                                          authenticationToken,
                                          &user_exception,
                                          &system_exception,
                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listSearches",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listSearches",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listSearches",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.listSearches implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listSearches",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_search (NoteStoreProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetSearchArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_SEARCH_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    SavedSearch * return_value;
    NoteStoreGetSearchResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_SEARCH_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_search (NOTE_STORE_IF (self->handler),
                                       &return_value,
                                       authenticationToken,
                                       guid,
                                       &user_exception,
                                       &system_exception,
                                       &not_found_exception,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getSearch",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getSearch implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSearch",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_create_search (NoteStoreProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreCreateSearchArgs * args =
    g_object_new (TYPE_NOTE_STORE_CREATE_SEARCH_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    SavedSearch * search;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    SavedSearch * return_value;
    NoteStoreCreateSearchResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "search", &search,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_CREATE_SEARCH_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_create_search (NOTE_STORE_IF (self->handler),
                                          &return_value,
                                          authenticationToken,
                                          search,
                                          &user_exception,
                                          &system_exception,
                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "createSearch",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.createSearch implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createSearch",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (search != NULL)
      g_object_unref (search);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_update_search (NoteStoreProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUpdateSearchArgs * args =
    g_object_new (TYPE_NOTE_STORE_UPDATE_SEARCH_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    SavedSearch * search;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreUpdateSearchResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "search", &search,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UPDATE_SEARCH_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_update_search (NOTE_STORE_IF (self->handler),
                                          (gint32 *)&return_value,
                                          authenticationToken,
                                          search,
                                          &user_exception,
                                          &system_exception,
                                          &not_found_exception,
                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateSearch",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.updateSearch implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateSearch",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (search != NULL)
      g_object_unref (search);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_expunge_search (NoteStoreProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreExpungeSearchArgs * args =
    g_object_new (TYPE_NOTE_STORE_EXPUNGE_SEARCH_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreExpungeSearchResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_EXPUNGE_SEARCH_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_expunge_search (NOTE_STORE_IF (self->handler),
                                           (gint32 *)&return_value,
                                           authenticationToken,
                                           guid,
                                           &user_exception,
                                           &system_exception,
                                           &not_found_exception,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "expungeSearch",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeSearch",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.expungeSearch implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeSearch",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_find_note_offset (NoteStoreProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreFindNoteOffsetArgs * args =
    g_object_new (TYPE_NOTE_STORE_FIND_NOTE_OFFSET_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    NoteFilter * filter;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreFindNoteOffsetResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "filter", &filter,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_FIND_NOTE_OFFSET_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_find_note_offset (NOTE_STORE_IF (self->handler),
                                             (gint32 *)&return_value,
                                             authenticationToken,
                                             filter,
                                             guid,
                                             &user_exception,
                                             &system_exception,
                                             &not_found_exception,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "findNoteOffset",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNoteOffset",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNoteOffset",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNoteOffset",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.findNoteOffset implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNoteOffset",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (filter != NULL)
      g_object_unref (filter);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_find_notes_metadata (NoteStoreProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreFindNotesMetadataArgs * args =
    g_object_new (TYPE_NOTE_STORE_FIND_NOTES_METADATA_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    NoteFilter * filter;
    gint offset;
    gint maxNotes;
    NotesMetadataResultSpec * resultSpec;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    NotesMetadataList * return_value;
    NoteStoreFindNotesMetadataResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "filter", &filter,
                  "offset", &offset,
                  "maxNotes", &maxNotes,
                  "resultSpec", &resultSpec,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_FIND_NOTES_METADATA_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_find_notes_metadata (NOTE_STORE_IF (self->handler),
                                                &return_value,
                                                authenticationToken,
                                                filter,
                                                offset,
                                                maxNotes,
                                                resultSpec,
                                                &user_exception,
                                                &system_exception,
                                                &not_found_exception,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "findNotesMetadata",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNotesMetadata",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNotesMetadata",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNotesMetadata",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.findNotesMetadata implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNotesMetadata",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (filter != NULL)
      g_object_unref (filter);
    if (resultSpec != NULL)
      g_object_unref (resultSpec);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_find_note_counts (NoteStoreProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreFindNoteCountsArgs * args =
    g_object_new (TYPE_NOTE_STORE_FIND_NOTE_COUNTS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    NoteFilter * filter;
    gboolean withTrash;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    NoteCollectionCounts * return_value;
    NoteStoreFindNoteCountsResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "filter", &filter,
                  "withTrash", &withTrash,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_FIND_NOTE_COUNTS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_find_note_counts (NOTE_STORE_IF (self->handler),
                                             &return_value,
                                             authenticationToken,
                                             filter,
                                             withTrash,
                                             &user_exception,
                                             &system_exception,
                                             &not_found_exception,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "findNoteCounts",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNoteCounts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNoteCounts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNoteCounts",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.findNoteCounts implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findNoteCounts",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (filter != NULL)
      g_object_unref (filter);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_note_with_result_spec (NoteStoreProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNoteWithResultSpecArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    NoteResultSpec * resultSpec;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Note * return_value;
    NoteStoreGetNoteWithResultSpecResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "resultSpec", &resultSpec,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTE_WITH_RESULT_SPEC_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_note_with_result_spec (NOTE_STORE_IF (self->handler),
                                                      &return_value,
                                                      authenticationToken,
                                                      guid,
                                                      resultSpec,
                                                      &user_exception,
                                                      &system_exception,
                                                      &not_found_exception,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNoteWithResultSpec",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteWithResultSpec",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteWithResultSpec",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteWithResultSpec",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNoteWithResultSpec implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteWithResultSpec",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (resultSpec != NULL)
      g_object_unref (resultSpec);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_note (NoteStoreProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gboolean withContent;
    gboolean withResourcesData;
    gboolean withResourcesRecognition;
    gboolean withResourcesAlternateData;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Note * return_value;
    NoteStoreGetNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "withContent", &withContent,
                  "withResourcesData", &withResourcesData,
                  "withResourcesRecognition", &withResourcesRecognition,
                  "withResourcesAlternateData", &withResourcesAlternateData,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_note (NOTE_STORE_IF (self->handler),
                                     &return_value,
                                     authenticationToken,
                                     guid,
                                     withContent,
                                     withResourcesData,
                                     withResourcesRecognition,
                                     withResourcesAlternateData,
                                     &user_exception,
                                     &system_exception,
                                     &not_found_exception,
                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_note_application_data (NoteStoreProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNoteApplicationDataArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    LazyMap * return_value;
    NoteStoreGetNoteApplicationDataResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTE_APPLICATION_DATA_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_note_application_data (NOTE_STORE_IF (self->handler),
                                                      &return_value,
                                                      authenticationToken,
                                                      guid,
                                                      &user_exception,
                                                      &system_exception,
                                                      &not_found_exception,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNoteApplicationData",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteApplicationData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteApplicationData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteApplicationData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNoteApplicationData implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteApplicationData",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_note_application_data_entry (NoteStoreProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNoteApplicationDataEntryArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gchar * key;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gchar * return_value;
    NoteStoreGetNoteApplicationDataEntryResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "key", &key,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTE_APPLICATION_DATA_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_note_application_data_entry (NOTE_STORE_IF (self->handler),
                                                            &return_value,
                                                            authenticationToken,
                                                            guid,
                                                            key,
                                                            &user_exception,
                                                            &system_exception,
                                                            &not_found_exception,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNoteApplicationDataEntry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNoteApplicationDataEntry implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteApplicationDataEntry",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (key != NULL)
      g_free (key);
    if (return_value != NULL)
      g_free (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_set_note_application_data_entry (NoteStoreProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreSetNoteApplicationDataEntryArgs * args =
    g_object_new (TYPE_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gchar * key;
    gchar * value;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreSetNoteApplicationDataEntryResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "key", &key,
                  "value", &value,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_SET_NOTE_APPLICATION_DATA_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_set_note_application_data_entry (NOTE_STORE_IF (self->handler),
                                                            (gint32 *)&return_value,
                                                            authenticationToken,
                                                            guid,
                                                            key,
                                                            value,
                                                            &user_exception,
                                                            &system_exception,
                                                            &not_found_exception,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "setNoteApplicationDataEntry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.setNoteApplicationDataEntry implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setNoteApplicationDataEntry",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (key != NULL)
      g_free (key);
    if (value != NULL)
      g_free (value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_unset_note_application_data_entry (NoteStoreProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUnsetNoteApplicationDataEntryArgs * args =
    g_object_new (TYPE_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gchar * key;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreUnsetNoteApplicationDataEntryResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "key", &key,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UNSET_NOTE_APPLICATION_DATA_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_unset_note_application_data_entry (NOTE_STORE_IF (self->handler),
                                                              (gint32 *)&return_value,
                                                              authenticationToken,
                                                              guid,
                                                              key,
                                                              &user_exception,
                                                              &system_exception,
                                                              &not_found_exception,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "unsetNoteApplicationDataEntry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unsetNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unsetNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unsetNoteApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.unsetNoteApplicationDataEntry implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unsetNoteApplicationDataEntry",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (key != NULL)
      g_free (key);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_note_content (NoteStoreProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNoteContentArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTE_CONTENT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gchar * return_value;
    NoteStoreGetNoteContentResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTE_CONTENT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_note_content (NOTE_STORE_IF (self->handler),
                                             &return_value,
                                             authenticationToken,
                                             guid,
                                             &user_exception,
                                             &system_exception,
                                             &not_found_exception,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNoteContent",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteContent",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteContent",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteContent",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNoteContent implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteContent",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_free (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_note_search_text (NoteStoreProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNoteSearchTextArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTE_SEARCH_TEXT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gboolean noteOnly;
    gboolean tokenizeForIndexing;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gchar * return_value;
    NoteStoreGetNoteSearchTextResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "noteOnly", &noteOnly,
                  "tokenizeForIndexing", &tokenizeForIndexing,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTE_SEARCH_TEXT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_note_search_text (NOTE_STORE_IF (self->handler),
                                                 &return_value,
                                                 authenticationToken,
                                                 guid,
                                                 noteOnly,
                                                 tokenizeForIndexing,
                                                 &user_exception,
                                                 &system_exception,
                                                 &not_found_exception,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNoteSearchText",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteSearchText",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteSearchText",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteSearchText",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNoteSearchText implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteSearchText",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_free (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource_search_text (NoteStoreProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceSearchTextArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gchar * return_value;
    NoteStoreGetResourceSearchTextResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_SEARCH_TEXT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource_search_text (NOTE_STORE_IF (self->handler),
                                                     &return_value,
                                                     authenticationToken,
                                                     guid,
                                                     &user_exception,
                                                     &system_exception,
                                                     &not_found_exception,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResourceSearchText",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceSearchText",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceSearchText",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceSearchText",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResourceSearchText implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceSearchText",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_free (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_note_tag_names (NoteStoreProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNoteTagNamesArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTE_TAG_NAMES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    GPtrArray * return_value;
    NoteStoreGetNoteTagNamesResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTE_TAG_NAMES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_note_tag_names (NOTE_STORE_IF (self->handler),
                                               &return_value,
                                               authenticationToken,
                                               guid,
                                               &user_exception,
                                               &system_exception,
                                               &not_found_exception,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNoteTagNames",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteTagNames",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteTagNames",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteTagNames",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNoteTagNames implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteTagNames",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_create_note (NoteStoreProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreCreateNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_CREATE_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Note * note;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Note * return_value;
    NoteStoreCreateNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "note", &note,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_CREATE_NOTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_create_note (NOTE_STORE_IF (self->handler),
                                        &return_value,
                                        authenticationToken,
                                        note,
                                        &user_exception,
                                        &system_exception,
                                        &not_found_exception,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "createNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.createNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (note != NULL)
      g_object_unref (note);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_update_note (NoteStoreProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUpdateNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_UPDATE_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Note * note;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Note * return_value;
    NoteStoreUpdateNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "note", &note,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UPDATE_NOTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_update_note (NOTE_STORE_IF (self->handler),
                                        &return_value,
                                        authenticationToken,
                                        note,
                                        &user_exception,
                                        &system_exception,
                                        &not_found_exception,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.updateNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (note != NULL)
      g_object_unref (note);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_delete_note (NoteStoreProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreDeleteNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_DELETE_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreDeleteNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_DELETE_NOTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_delete_note (NOTE_STORE_IF (self->handler),
                                        (gint32 *)&return_value,
                                        authenticationToken,
                                        guid,
                                        &user_exception,
                                        &system_exception,
                                        &not_found_exception,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.deleteNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_expunge_note (NoteStoreProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreExpungeNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_EXPUNGE_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreExpungeNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_EXPUNGE_NOTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_expunge_note (NOTE_STORE_IF (self->handler),
                                         (gint32 *)&return_value,
                                         authenticationToken,
                                         guid,
                                         &user_exception,
                                         &system_exception,
                                         &not_found_exception,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "expungeNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.expungeNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_copy_note (NoteStoreProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreCopyNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_COPY_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid noteGuid;
    Guid toNotebookGuid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Note * return_value;
    NoteStoreCopyNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "noteGuid", &noteGuid,
                  "toNotebookGuid", &toNotebookGuid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_COPY_NOTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_copy_note (NOTE_STORE_IF (self->handler),
                                      &return_value,
                                      authenticationToken,
                                      noteGuid,
                                      toNotebookGuid,
                                      &user_exception,
                                      &system_exception,
                                      &not_found_exception,
                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "copyNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "copyNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "copyNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "copyNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.copyNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "copyNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (noteGuid != NULL)
      g_free (noteGuid);
    if (toNotebookGuid != NULL)
      g_free (toNotebookGuid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_list_note_versions (NoteStoreProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreListNoteVersionsArgs * args =
    g_object_new (TYPE_NOTE_STORE_LIST_NOTE_VERSIONS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid noteGuid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    GPtrArray * return_value;
    NoteStoreListNoteVersionsResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "noteGuid", &noteGuid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_LIST_NOTE_VERSIONS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_list_note_versions (NOTE_STORE_IF (self->handler),
                                               &return_value,
                                               authenticationToken,
                                               noteGuid,
                                               &user_exception,
                                               &system_exception,
                                               &not_found_exception,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listNoteVersions",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listNoteVersions",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listNoteVersions",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listNoteVersions",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.listNoteVersions implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listNoteVersions",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (noteGuid != NULL)
      g_free (noteGuid);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_note_version (NoteStoreProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNoteVersionArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTE_VERSION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid noteGuid;
    gint updateSequenceNum;
    gboolean withResourcesData;
    gboolean withResourcesRecognition;
    gboolean withResourcesAlternateData;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Note * return_value;
    NoteStoreGetNoteVersionResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "noteGuid", &noteGuid,
                  "updateSequenceNum", &updateSequenceNum,
                  "withResourcesData", &withResourcesData,
                  "withResourcesRecognition", &withResourcesRecognition,
                  "withResourcesAlternateData", &withResourcesAlternateData,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTE_VERSION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_note_version (NOTE_STORE_IF (self->handler),
                                             &return_value,
                                             authenticationToken,
                                             noteGuid,
                                             updateSequenceNum,
                                             withResourcesData,
                                             withResourcesRecognition,
                                             withResourcesAlternateData,
                                             &user_exception,
                                             &system_exception,
                                             &not_found_exception,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNoteVersion",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteVersion",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteVersion",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteVersion",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNoteVersion implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNoteVersion",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (noteGuid != NULL)
      g_free (noteGuid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource (NoteStoreProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gboolean withData;
    gboolean withRecognition;
    gboolean withAttributes;
    gboolean withAlternateData;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Resource * return_value;
    NoteStoreGetResourceResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "withData", &withData,
                  "withRecognition", &withRecognition,
                  "withAttributes", &withAttributes,
                  "withAlternateData", &withAlternateData,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource (NOTE_STORE_IF (self->handler),
                                         &return_value,
                                         authenticationToken,
                                         guid,
                                         withData,
                                         withRecognition,
                                         withAttributes,
                                         withAlternateData,
                                         &user_exception,
                                         &system_exception,
                                         &not_found_exception,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResource",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResource",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResource",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResource",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResource implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResource",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource_application_data (NoteStoreProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceApplicationDataArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    LazyMap * return_value;
    NoteStoreGetResourceApplicationDataResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource_application_data (NOTE_STORE_IF (self->handler),
                                                          &return_value,
                                                          authenticationToken,
                                                          guid,
                                                          &user_exception,
                                                          &system_exception,
                                                          &not_found_exception,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResourceApplicationData",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceApplicationData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceApplicationData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceApplicationData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResourceApplicationData implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceApplicationData",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource_application_data_entry (NoteStoreProcessor *self,
                                                                  gint32 sequence_id,
                                                                  ThriftProtocol *input_protocol,
                                                                  ThriftProtocol *output_protocol,
                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceApplicationDataEntryArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gchar * key;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gchar * return_value;
    NoteStoreGetResourceApplicationDataEntryResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "key", &key,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource_application_data_entry (NOTE_STORE_IF (self->handler),
                                                                &return_value,
                                                                authenticationToken,
                                                                guid,
                                                                key,
                                                                &user_exception,
                                                                &system_exception,
                                                                &not_found_exception,
                                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResourceApplicationDataEntry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResourceApplicationDataEntry implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceApplicationDataEntry",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (key != NULL)
      g_free (key);
    if (return_value != NULL)
      g_free (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_set_resource_application_data_entry (NoteStoreProcessor *self,
                                                                  gint32 sequence_id,
                                                                  ThriftProtocol *input_protocol,
                                                                  ThriftProtocol *output_protocol,
                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreSetResourceApplicationDataEntryArgs * args =
    g_object_new (TYPE_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gchar * key;
    gchar * value;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreSetResourceApplicationDataEntryResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "key", &key,
                  "value", &value,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_SET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_set_resource_application_data_entry (NOTE_STORE_IF (self->handler),
                                                                (gint32 *)&return_value,
                                                                authenticationToken,
                                                                guid,
                                                                key,
                                                                value,
                                                                &user_exception,
                                                                &system_exception,
                                                                &not_found_exception,
                                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "setResourceApplicationDataEntry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.setResourceApplicationDataEntry implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setResourceApplicationDataEntry",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (key != NULL)
      g_free (key);
    if (value != NULL)
      g_free (value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_unset_resource_application_data_entry (NoteStoreProcessor *self,
                                                                    gint32 sequence_id,
                                                                    ThriftProtocol *input_protocol,
                                                                    ThriftProtocol *output_protocol,
                                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUnsetResourceApplicationDataEntryArgs * args =
    g_object_new (TYPE_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    gchar * key;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreUnsetResourceApplicationDataEntryResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  "key", &key,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UNSET_RESOURCE_APPLICATION_DATA_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_unset_resource_application_data_entry (NOTE_STORE_IF (self->handler),
                                                                  (gint32 *)&return_value,
                                                                  authenticationToken,
                                                                  guid,
                                                                  key,
                                                                  &user_exception,
                                                                  &system_exception,
                                                                  &not_found_exception,
                                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "unsetResourceApplicationDataEntry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unsetResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unsetResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unsetResourceApplicationDataEntry",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.unsetResourceApplicationDataEntry implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unsetResourceApplicationDataEntry",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (key != NULL)
      g_free (key);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_update_resource (NoteStoreProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUpdateResourceArgs * args =
    g_object_new (TYPE_NOTE_STORE_UPDATE_RESOURCE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Resource * resource;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    gint return_value;
    NoteStoreUpdateResourceResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "resource", &resource,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UPDATE_RESOURCE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_update_resource (NOTE_STORE_IF (self->handler),
                                            (gint32 *)&return_value,
                                            authenticationToken,
                                            resource,
                                            &user_exception,
                                            &system_exception,
                                            &not_found_exception,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateResource",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateResource",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateResource",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateResource",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.updateResource implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateResource",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (resource != NULL)
      g_object_unref (resource);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource_data (NoteStoreProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceDataArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_DATA_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    GByteArray * return_value;
    NoteStoreGetResourceDataResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_DATA_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource_data (NOTE_STORE_IF (self->handler),
                                              &return_value,
                                              authenticationToken,
                                              guid,
                                              &user_exception,
                                              &system_exception,
                                              &not_found_exception,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResourceData",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResourceData implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceData",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_byte_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource_by_hash (NoteStoreProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceByHashArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_BY_HASH_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid noteGuid;
    GByteArray * contentHash;
    gboolean withData;
    gboolean withRecognition;
    gboolean withAlternateData;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Resource * return_value;
    NoteStoreGetResourceByHashResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "noteGuid", &noteGuid,
                  "contentHash", &contentHash,
                  "withData", &withData,
                  "withRecognition", &withRecognition,
                  "withAlternateData", &withAlternateData,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_BY_HASH_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource_by_hash (NOTE_STORE_IF (self->handler),
                                                 &return_value,
                                                 authenticationToken,
                                                 noteGuid,
                                                 contentHash,
                                                 withData,
                                                 withRecognition,
                                                 withAlternateData,
                                                 &user_exception,
                                                 &system_exception,
                                                 &not_found_exception,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResourceByHash",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceByHash",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceByHash",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceByHash",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResourceByHash implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceByHash",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (noteGuid != NULL)
      g_free (noteGuid);
    if (contentHash != NULL)
      g_byte_array_unref (contentHash);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource_recognition (NoteStoreProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceRecognitionArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_RECOGNITION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    GByteArray * return_value;
    NoteStoreGetResourceRecognitionResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_RECOGNITION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource_recognition (NOTE_STORE_IF (self->handler),
                                                     &return_value,
                                                     authenticationToken,
                                                     guid,
                                                     &user_exception,
                                                     &system_exception,
                                                     &not_found_exception,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResourceRecognition",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceRecognition",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceRecognition",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceRecognition",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResourceRecognition implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceRecognition",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_byte_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource_alternate_data (NoteStoreProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceAlternateDataArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    GByteArray * return_value;
    NoteStoreGetResourceAlternateDataResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_ALTERNATE_DATA_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource_alternate_data (NOTE_STORE_IF (self->handler),
                                                        &return_value,
                                                        authenticationToken,
                                                        guid,
                                                        &user_exception,
                                                        &system_exception,
                                                        &not_found_exception,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResourceAlternateData",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceAlternateData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceAlternateData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceAlternateData",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResourceAlternateData implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceAlternateData",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_byte_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_resource_attributes (NoteStoreProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetResourceAttributesArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    ResourceAttributes * return_value;
    NoteStoreGetResourceAttributesResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_RESOURCE_ATTRIBUTES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_resource_attributes (NOTE_STORE_IF (self->handler),
                                                    &return_value,
                                                    authenticationToken,
                                                    guid,
                                                    &user_exception,
                                                    &system_exception,
                                                    &not_found_exception,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getResourceAttributes",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceAttributes",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceAttributes",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceAttributes",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getResourceAttributes implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getResourceAttributes",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_public_notebook (NoteStoreProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetPublicNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_PUBLIC_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    UserID userId;
    gchar * publicUri;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    Notebook * return_value;
    NoteStoreGetPublicNotebookResult * result_struct;

    g_object_get (args,
                  "userId", &userId,
                  "publicUri", &publicUri,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_PUBLIC_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_public_notebook (NOTE_STORE_IF (self->handler),
                                                &return_value,
                                                userId,
                                                publicUri,
                                                &system_exception,
                                                &not_found_exception,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPublicNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPublicNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPublicNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getPublicNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPublicNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (publicUri != NULL)
      g_free (publicUri);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_share_notebook (NoteStoreProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreShareNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_SHARE_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    SharedNotebook * sharedNotebook;
    gchar * message;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    SharedNotebook * return_value;
    NoteStoreShareNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "sharedNotebook", &sharedNotebook,
                  "message", &message,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_SHARE_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_share_notebook (NOTE_STORE_IF (self->handler),
                                           &return_value,
                                           authenticationToken,
                                           sharedNotebook,
                                           message,
                                           &user_exception,
                                           &not_found_exception,
                                           &system_exception,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "shareNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "shareNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "shareNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "shareNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.shareNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "shareNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (sharedNotebook != NULL)
      g_object_unref (sharedNotebook);
    if (message != NULL)
      g_free (message);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_create_or_update_notebook_shares (NoteStoreProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreCreateOrUpdateNotebookSharesArgs * args =
    g_object_new (TYPE_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    NotebookShareTemplate * shareTemplate;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMInvalidContactsException * invalid_contacts_exception = NULL;
    CreateOrUpdateNotebookSharesResult * return_value;
    NoteStoreCreateOrUpdateNotebookSharesResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "shareTemplate", &shareTemplate,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_CREATE_OR_UPDATE_NOTEBOOK_SHARES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_create_or_update_notebook_shares (NOTE_STORE_IF (self->handler),
                                                             &return_value,
                                                             authenticationToken,
                                                             shareTemplate,
                                                             &user_exception,
                                                             &not_found_exception,
                                                             &system_exception,
                                                             &invalid_contacts_exception,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "createOrUpdateNotebookShares",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createOrUpdateNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createOrUpdateNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createOrUpdateNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (invalid_contacts_exception != NULL)
      {
        g_object_set (result_struct,
                      "invalidContactsException", invalid_contacts_exception,
                      NULL);

        g_object_unref (invalid_contacts_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createOrUpdateNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.createOrUpdateNotebookShares implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createOrUpdateNotebookShares",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (shareTemplate != NULL)
      g_object_unref (shareTemplate);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_update_shared_notebook (NoteStoreProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUpdateSharedNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    SharedNotebook * sharedNotebook;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    gint return_value;
    NoteStoreUpdateSharedNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "sharedNotebook", &sharedNotebook,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UPDATE_SHARED_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_update_shared_notebook (NOTE_STORE_IF (self->handler),
                                                   (gint32 *)&return_value,
                                                   authenticationToken,
                                                   sharedNotebook,
                                                   &user_exception,
                                                   &not_found_exception,
                                                   &system_exception,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateSharedNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateSharedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateSharedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateSharedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.updateSharedNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateSharedNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (sharedNotebook != NULL)
      g_object_unref (sharedNotebook);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_set_notebook_recipient_settings (NoteStoreProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreSetNotebookRecipientSettingsArgs * args =
    g_object_new (TYPE_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    gchar * notebookGuid;
    NotebookRecipientSettings * recipientSettings;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    Notebook * return_value;
    NoteStoreSetNotebookRecipientSettingsResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "notebookGuid", &notebookGuid,
                  "recipientSettings", &recipientSettings,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_SET_NOTEBOOK_RECIPIENT_SETTINGS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_set_notebook_recipient_settings (NOTE_STORE_IF (self->handler),
                                                            &return_value,
                                                            authenticationToken,
                                                            notebookGuid,
                                                            recipientSettings,
                                                            &user_exception,
                                                            &not_found_exception,
                                                            &system_exception,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "setNotebookRecipientSettings",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setNotebookRecipientSettings",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setNotebookRecipientSettings",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setNotebookRecipientSettings",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.setNotebookRecipientSettings implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setNotebookRecipientSettings",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (notebookGuid != NULL)
      g_free (notebookGuid);
    if (recipientSettings != NULL)
      g_object_unref (recipientSettings);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_list_shared_notebooks (NoteStoreProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreListSharedNotebooksArgs * args =
    g_object_new (TYPE_NOTE_STORE_LIST_SHARED_NOTEBOOKS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    GPtrArray * return_value;
    NoteStoreListSharedNotebooksResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_LIST_SHARED_NOTEBOOKS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_list_shared_notebooks (NOTE_STORE_IF (self->handler),
                                                  &return_value,
                                                  authenticationToken,
                                                  &user_exception,
                                                  &not_found_exception,
                                                  &system_exception,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listSharedNotebooks",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listSharedNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listSharedNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listSharedNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.listSharedNotebooks implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listSharedNotebooks",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_create_linked_notebook (NoteStoreProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreCreateLinkedNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_CREATE_LINKED_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    LinkedNotebook * linkedNotebook;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    LinkedNotebook * return_value;
    NoteStoreCreateLinkedNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "linkedNotebook", &linkedNotebook,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_CREATE_LINKED_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_create_linked_notebook (NOTE_STORE_IF (self->handler),
                                                   &return_value,
                                                   authenticationToken,
                                                   linkedNotebook,
                                                   &user_exception,
                                                   &not_found_exception,
                                                   &system_exception,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "createLinkedNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.createLinkedNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "createLinkedNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (linkedNotebook != NULL)
      g_object_unref (linkedNotebook);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_update_linked_notebook (NoteStoreProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUpdateLinkedNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    LinkedNotebook * linkedNotebook;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    gint return_value;
    NoteStoreUpdateLinkedNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "linkedNotebook", &linkedNotebook,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UPDATE_LINKED_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_update_linked_notebook (NOTE_STORE_IF (self->handler),
                                                   (gint32 *)&return_value,
                                                   authenticationToken,
                                                   linkedNotebook,
                                                   &user_exception,
                                                   &not_found_exception,
                                                   &system_exception,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateLinkedNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.updateLinkedNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateLinkedNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (linkedNotebook != NULL)
      g_object_unref (linkedNotebook);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_list_linked_notebooks (NoteStoreProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreListLinkedNotebooksArgs * args =
    g_object_new (TYPE_NOTE_STORE_LIST_LINKED_NOTEBOOKS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    GPtrArray * return_value;
    NoteStoreListLinkedNotebooksResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_LIST_LINKED_NOTEBOOKS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_list_linked_notebooks (NOTE_STORE_IF (self->handler),
                                                  &return_value,
                                                  authenticationToken,
                                                  &user_exception,
                                                  &not_found_exception,
                                                  &system_exception,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listLinkedNotebooks",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listLinkedNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listLinkedNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listLinkedNotebooks",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.listLinkedNotebooks implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listLinkedNotebooks",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_ptr_array_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_expunge_linked_notebook (NoteStoreProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreExpungeLinkedNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    gint return_value;
    NoteStoreExpungeLinkedNotebookResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_EXPUNGE_LINKED_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_expunge_linked_notebook (NOTE_STORE_IF (self->handler),
                                                    (gint32 *)&return_value,
                                                    authenticationToken,
                                                    guid,
                                                    &user_exception,
                                                    &not_found_exception,
                                                    &system_exception,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "expungeLinkedNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeLinkedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.expungeLinkedNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "expungeLinkedNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_authenticate_to_shared_notebook (NoteStoreProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreAuthenticateToSharedNotebookArgs * args =
    g_object_new (TYPE_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * shareKeyOrGlobalId;
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    AuthenticationResult * return_value;
    NoteStoreAuthenticateToSharedNotebookResult * result_struct;

    g_object_get (args,
                  "shareKeyOrGlobalId", &shareKeyOrGlobalId,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTEBOOK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_authenticate_to_shared_notebook (NOTE_STORE_IF (self->handler),
                                                            &return_value,
                                                            shareKeyOrGlobalId,
                                                            authenticationToken,
                                                            &user_exception,
                                                            &not_found_exception,
                                                            &system_exception,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "authenticateToSharedNotebook",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "authenticateToSharedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "authenticateToSharedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "authenticateToSharedNotebook",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.authenticateToSharedNotebook implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "authenticateToSharedNotebook",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (shareKeyOrGlobalId != NULL)
      g_free (shareKeyOrGlobalId);
    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_shared_notebook_by_auth (NoteStoreProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetSharedNotebookByAuthArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    SharedNotebook * return_value;
    NoteStoreGetSharedNotebookByAuthResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_SHARED_NOTEBOOK_BY_AUTH_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_shared_notebook_by_auth (NOTE_STORE_IF (self->handler),
                                                        &return_value,
                                                        authenticationToken,
                                                        &user_exception,
                                                        &not_found_exception,
                                                        &system_exception,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getSharedNotebookByAuth",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSharedNotebookByAuth",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSharedNotebookByAuth",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSharedNotebookByAuth",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getSharedNotebookByAuth implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSharedNotebookByAuth",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_email_note (NoteStoreProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreEmailNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_EMAIL_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    NoteEmailParameters * parameters;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    NoteStoreEmailNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "parameters", &parameters,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_EMAIL_NOTE_RESULT, NULL);

    if (note_store_handler_email_note (NOTE_STORE_IF (self->handler),
                                       authenticationToken,
                                       parameters,
                                       &user_exception,
                                       &not_found_exception,
                                       &system_exception,
                                       error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "emailNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "emailNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "emailNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "emailNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.emailNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "emailNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (parameters != NULL)
      g_object_unref (parameters);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_share_note (NoteStoreProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreShareNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_SHARE_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    gchar * return_value;
    NoteStoreShareNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_SHARE_NOTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_share_note (NOTE_STORE_IF (self->handler),
                                       &return_value,
                                       authenticationToken,
                                       guid,
                                       &user_exception,
                                       &not_found_exception,
                                       &system_exception,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "shareNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "shareNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "shareNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "shareNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.shareNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "shareNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    if (return_value != NULL)
      g_free (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_stop_sharing_note (NoteStoreProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreStopSharingNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_STOP_SHARING_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Guid guid;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    NoteStoreStopSharingNoteResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "guid", &guid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_STOP_SHARING_NOTE_RESULT, NULL);

    if (note_store_handler_stop_sharing_note (NOTE_STORE_IF (self->handler),
                                              authenticationToken,
                                              guid,
                                              &user_exception,
                                              &not_found_exception,
                                              &system_exception,
                                              error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "stopSharingNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "stopSharingNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "stopSharingNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "stopSharingNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.stopSharingNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "stopSharingNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (guid != NULL)
      g_free (guid);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_authenticate_to_shared_note (NoteStoreProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreAuthenticateToSharedNoteArgs * args =
    g_object_new (TYPE_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * guid;
    gchar * noteKey;
    gchar * authenticationToken;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    AuthenticationResult * return_value;
    NoteStoreAuthenticateToSharedNoteResult * result_struct;

    g_object_get (args,
                  "guid", &guid,
                  "noteKey", &noteKey,
                  "authenticationToken", &authenticationToken,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_AUTHENTICATE_TO_SHARED_NOTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_authenticate_to_shared_note (NOTE_STORE_IF (self->handler),
                                                        &return_value,
                                                        guid,
                                                        noteKey,
                                                        authenticationToken,
                                                        &user_exception,
                                                        &not_found_exception,
                                                        &system_exception,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "authenticateToSharedNote",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "authenticateToSharedNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "authenticateToSharedNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "authenticateToSharedNote",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.authenticateToSharedNote implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "authenticateToSharedNote",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (guid != NULL)
      g_free (guid);
    if (noteKey != NULL)
      g_free (noteKey);
    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_find_related (NoteStoreProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreFindRelatedArgs * args =
    g_object_new (TYPE_NOTE_STORE_FIND_RELATED_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    RelatedQuery * query;
    RelatedResultSpec * resultSpec;
    EDAMUserException * user_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    RelatedResult * return_value;
    NoteStoreFindRelatedResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "query", &query,
                  "resultSpec", &resultSpec,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_FIND_RELATED_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_find_related (NOTE_STORE_IF (self->handler),
                                         &return_value,
                                         authenticationToken,
                                         query,
                                         resultSpec,
                                         &user_exception,
                                         &system_exception,
                                         &not_found_exception,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "findRelated",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findRelated",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findRelated",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findRelated",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.findRelated implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "findRelated",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (query != NULL)
      g_object_unref (query);
    if (resultSpec != NULL)
      g_object_unref (resultSpec);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_update_note_if_usn_matches (NoteStoreProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreUpdateNoteIfUsnMatchesArgs * args =
    g_object_new (TYPE_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    Note * note;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    UpdateNoteIfUsnMatchesResult * return_value;
    NoteStoreUpdateNoteIfUsnMatchesResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "note", &note,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_UPDATE_NOTE_IF_USN_MATCHES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_update_note_if_usn_matches (NOTE_STORE_IF (self->handler),
                                                       &return_value,
                                                       authenticationToken,
                                                       note,
                                                       &user_exception,
                                                       &not_found_exception,
                                                       &system_exception,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateNoteIfUsnMatches",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNoteIfUsnMatches",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNoteIfUsnMatches",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNoteIfUsnMatches",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.updateNoteIfUsnMatches implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateNoteIfUsnMatches",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (note != NULL)
      g_object_unref (note);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_manage_notebook_shares (NoteStoreProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreManageNotebookSharesArgs * args =
    g_object_new (TYPE_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    ManageNotebookSharesParameters * parameters;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    ManageNotebookSharesResult * return_value;
    NoteStoreManageNotebookSharesResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "parameters", &parameters,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_MANAGE_NOTEBOOK_SHARES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_manage_notebook_shares (NOTE_STORE_IF (self->handler),
                                                   &return_value,
                                                   authenticationToken,
                                                   parameters,
                                                   &user_exception,
                                                   &not_found_exception,
                                                   &system_exception,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "manageNotebookShares",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "manageNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "manageNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "manageNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.manageNotebookShares implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "manageNotebookShares",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (parameters != NULL)
      g_object_unref (parameters);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_process_get_notebook_shares (NoteStoreProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  NoteStoreGetNotebookSharesArgs * args =
    g_object_new (TYPE_NOTE_STORE_GET_NOTEBOOK_SHARES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * authenticationToken;
    gchar * notebookGuid;
    EDAMUserException * user_exception = NULL;
    EDAMNotFoundException * not_found_exception = NULL;
    EDAMSystemException * system_exception = NULL;
    ShareRelationships * return_value;
    NoteStoreGetNotebookSharesResult * result_struct;

    g_object_get (args,
                  "authenticationToken", &authenticationToken,
                  "notebookGuid", &notebookGuid,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_NOTE_STORE_GET_NOTEBOOK_SHARES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (note_store_handler_get_notebook_shares (NOTE_STORE_IF (self->handler),
                                                &return_value,
                                                authenticationToken,
                                                notebookGuid,
                                                &user_exception,
                                                &not_found_exception,
                                                &system_exception,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getNotebookShares",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (user_exception != NULL)
      {
        g_object_set (result_struct,
                      "userException", user_exception,
                      NULL);

        g_object_unref (user_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (not_found_exception != NULL)
      {
        g_object_set (result_struct,
                      "notFoundException", not_found_exception,
                      NULL);

        g_object_unref (not_found_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (system_exception != NULL)
      {
        g_object_set (result_struct,
                      "systemException", system_exception,
                      NULL);

        g_object_unref (system_exception);
        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNotebookShares",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("NoteStore.getNotebookShares implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getNotebookShares",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (authenticationToken != NULL)
      g_free (authenticationToken);
    if (notebookGuid != NULL)
      g_free (notebookGuid);
    if (return_value != NULL)
      g_object_unref (return_value);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
note_store_processor_dispatch_call (ThriftDispatchProcessor *dispatch_processor,
                                    ThriftProtocol *input_protocol,
                                    ThriftProtocol *output_protocol,
                                    gchar *method_name,
                                    gint32 sequence_id,
                                    GError **error)
{
  note_store_processor_process_function_def *process_function_def;
  gboolean dispatch_result = FALSE;

  NoteStoreProcessor *self = NOTE_STORE_PROCESSOR (dispatch_processor);
  ThriftDispatchProcessorClass *parent_class =
    g_type_class_peek_parent (NOTE_STORE_PROCESSOR_GET_CLASS (self));

  process_function_def = g_hash_table_lookup (self->process_map, method_name);
  if (process_function_def != NULL)
  {
    g_free (method_name);
    dispatch_result = (*process_function_def->function) (self,
                                                         sequence_id,
                                                         input_protocol,
                                                         output_protocol,
                                                         error);
  }
  else
  {
    dispatch_result = parent_class->dispatch_call (dispatch_processor,
                                                   input_protocol,
                                                   output_protocol,
                                                   method_name,
                                                   sequence_id,
                                                   error);
  }

  return dispatch_result;
}

static void
note_store_processor_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  NoteStoreProcessor *self = NOTE_STORE_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_PROCESSOR_HANDLER:
      if (self->handler != NULL)
        g_object_unref (self->handler);
      self->handler = g_value_get_object (value);
      g_object_ref (self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_processor_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  NoteStoreProcessor *self = NOTE_STORE_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_NOTE_STORE_PROCESSOR_HANDLER:
      g_value_set_object (value, self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
note_store_processor_dispose (GObject *gobject)
{
  NoteStoreProcessor *self = NOTE_STORE_PROCESSOR (gobject);

  if (self->handler != NULL)
  {
    g_object_unref (self->handler);
    self->handler = NULL;
  }

  G_OBJECT_CLASS (note_store_processor_parent_class)->dispose (gobject);
}

static void
note_store_processor_finalize (GObject *gobject)
{
  NoteStoreProcessor *self = NOTE_STORE_PROCESSOR (gobject);

  thrift_safe_hash_table_destroy (self->process_map);

  G_OBJECT_CLASS (note_store_processor_parent_class)->finalize (gobject);
}

static void
note_store_processor_init (NoteStoreProcessor *self)
{
  guint index;

  self->handler = NULL;
  self->process_map = g_hash_table_new (g_str_hash, g_str_equal);

  for (index = 0; index < 74; index += 1)
    g_hash_table_insert (self->process_map,
                         note_store_processor_process_function_defs[index].name,
                         &note_store_processor_process_function_defs[index]);
}

static void
note_store_processor_class_init (NoteStoreProcessorClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftDispatchProcessorClass *dispatch_processor_class =
    THRIFT_DISPATCH_PROCESSOR_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->dispose = note_store_processor_dispose;
  gobject_class->finalize = note_store_processor_finalize;
  gobject_class->set_property = note_store_processor_set_property;
  gobject_class->get_property = note_store_processor_get_property;

  dispatch_processor_class->dispatch_call = note_store_processor_dispatch_call;
  cls->dispatch_call = note_store_processor_dispatch_call;

  param_spec = g_param_spec_object ("handler",
                                    "Service handler implementation",
                                    "The service handler implementation "
                                    "to which method calls are dispatched.",
                                    TYPE_NOTE_STORE_HANDLER,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_NOTE_STORE_PROCESSOR_HANDLER,
                                   param_spec);
}
